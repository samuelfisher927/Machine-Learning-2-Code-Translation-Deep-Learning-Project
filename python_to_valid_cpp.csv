filename,code,cpp_code
1.py,"def twoSum(self, nums, target):
        nums_hash = {}
        for i in range(len(nums)):
            if target - nums[i] in nums_hash: 
                return [nums_hash[target - nums[i]], i]
            nums_hash[nums[i]] = i","auto twoSum(auto nums, auto target) {
    nums_hash = {}
    for i in range(len(nums)):
    if target - nums[i] in nums_hash:
    return [nums_hash[target - nums[i]], i]
    nums_hash[nums[i]] = i
}"
10.py,"def isMatch(self, s, p):
        return bool(re.match(r""%s"" %p, s)) and re.match(r""%s"" %p, s).group(0) == s ","auto isMatch(auto s, auto p) {
    return bool(re.match(r""%s"" %p, s)) and re.match(r""%s"" %p, s).group(0) == s
}"
100.py,"def isSameTree(self, p, q):
        return p == q if not p or not q else p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)","auto isSameTree(auto p, auto q) {
    return p == q if not p or not q else p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
}"
1000.py,"def mergeStones(self, stones, K):
        n = len(stones)
        if (n - 1) % (K - 1): return -1
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i + 1] = prefix[i] + stones[i]

        import functools
        @functools.lru_cache(None)
        def dp(i, j):
            if j - i + 1 < K: return 0
            res = min(dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1))
            if (j - i) % (K - 1) == 0:
                res += prefix[j + 1] - prefix[i]
            return res
        return dp(0, n - 1)","auto mergeStones(auto stones, auto K) {
    n = len(stones)
    if (n - 1) % (K - 1): return -1
    prefix = [0] * (n + 1)
    for i in range(n):
    prefix[i + 1] = prefix[i] + stones[i]
    
    import functools
    @functools.lru_cache(None)
    def dp(i, j):
    if j - i + 1 < K: return 0
    res = min(dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1))
    if (j - i) % (K - 1) == 0:
    res += prefix[j + 1] - prefix[i]
    return res
    return dp(0, n - 1)
}"
1001.py,"def gridIllumination(self, N: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:
        lampsOn = set()
        rowsOn = collections.defaultdict(int)
        colsOn = collections.defaultdict(int)
        diagOnTopLeftBottomRight = collections.defaultdict(int)
        diagOnBottomLeftTopRight = collections.defaultdict(int)
        for r, c in lamps:
            lampsOn.add((r, c))
            rowsOn[r] += 1
            colsOn[c] += 1
            diagOnTopLeftBottomRight[c-r] += 1
            diagOnBottomLeftTopRight[c+r-N] += 1
        
        result = []
        for r, c in queries:
            if rowsOn[r] > 0 or colsOn[c] > 0 or diagOnTopLeftBottomRight[c-r] > 0 or diagOnBottomLeftTopRight[c+r-N] > 0:
                result.append(1)
            else:
                result.append(0)
            adjacentLamps = [(r, c), (r, c-1), (r, c+1), (r-1, c), (r-1, c-1), (r-1, c+1), (r+1, c), (r+1, c-1), (r+1, c+1)]
            for r, c in adjacentLamps:
                if (r, c) in lampsOn:
                    lampsOn.discard((r, c))
                    rowsOn[r] -= 1
                    colsOn[c] -= 1
                    diagOnTopLeftBottomRight[c-r] -= 1
                    diagOnBottomLeftTopRight[c+r-N] -= 1
        return result","auto gridIllumination(auto N, auto lamps, auto queries) {
    lampsOn = set()
    rowsOn = collections.defaultdict(int)
    colsOn = collections.defaultdict(int)
    diagOnTopLeftBottomRight = collections.defaultdict(int)
    diagOnBottomLeftTopRight = collections.defaultdict(int)
    for r, c in lamps:
    lampsOn.add((r, c))
    rowsOn[r] += 1
    colsOn[c] += 1
    diagOnTopLeftBottomRight[c-r] += 1
    diagOnBottomLeftTopRight[c+r-N] += 1
    
    result = []
    for r, c in queries:
    if rowsOn[r] > 0 or colsOn[c] > 0 or diagOnTopLeftBottomRight[c-r] > 0 or diagOnBottomLeftTopRight[c+r-N] > 0:
    result.append(1)
    else:
    result.append(0)
    adjacentLamps = [(r, c), (r, c-1), (r, c+1), (r-1, c), (r-1, c-1), (r-1, c+1), (r+1, c), (r+1, c-1), (r+1, c+1)]
    for r, c in adjacentLamps:
    if (r, c) in lampsOn:
    lampsOn.discard((r, c))
    rowsOn[r] -= 1
    colsOn[c] -= 1
    diagOnTopLeftBottomRight[c-r] -= 1
    diagOnBottomLeftTopRight[c+r-N] -= 1
    return result
}"
1002.py,"def commonChars(self, A: List[str]) -> List[str]:
        cnt, res = {s: [float('inf'), 0] for s in string.ascii_lowercase}, []
        for w in A:
            for k, v in collections.Counter(w).items():
                cnt[k][0] = min(cnt[k][0], v)
                cnt[k][1] += 1
        for k in cnt:
            if cnt[k][1] == len(A):
                res += [k] * cnt[k][0]
        return res","auto commonChars(auto A) {
    cnt, res = {s: [float('inf'), 0] for s in string.ascii_lowercase}, []
    for w in A:
    for k, v in collections.Counter(w).items():
    cnt[k][0] = min(cnt[k][0], v)
    cnt[k][1] += 1
    for k in cnt:
    if cnt[k][1] == len(A):
    res += [k] * cnt[k][0]
    return res
}"
1003.py,"def isValid(self, S: str) -> bool:
        stack = []
        for i in S:
            if i == 'c':
                if stack[-2:] != ['a', 'b']:
                    return False
                stack.pop()
                stack.pop()
            else:
                stack.append(i)
        return not stack","auto isValid(auto S) {
    stack = []
    for i in S:
    if i == 'c':
    if stack[-2:] != ['a', 'b']:
    return false
    stack.pop()
    stack.pop()
    else:
    stack.append(i)
    return not stack
}"
1004.py,"def longestOnes(self, A: List[int], K: int) -> int:
        zeros, res = [-1] + [i for i, c in enumerate(A) if not c] + [len(A)], 0
        for j in range(K + 1, len(zeros)):
            res = max(res, zeros[j] - zeros[j - K - 1] - 1)
        return res or K and len(A)","auto longestOnes(auto A, auto K) {
    zeros, res = [-1] + [i for i, c in enumerate(A) if not c] + [len(A)], 0
    for j in range(K + 1, len(zeros)):
    res = max(res, zeros[j] - zeros[j - K - 1] - 1)
    return res or K and len(A)
}"
1005.py,"def largestSumAfterKNegations(self, A: List[int], K: int) -> int:
        heapq.heapify(A)
        for _ in range(K):
            val = heapq.heappop(A)
            heapq.heappush(A, -val)
        return sum(A)","auto largestSumAfterKNegations(auto A, auto K) {
    heapq.heapify(A)
    for _ in range(K):
    val = heapq.heappop(A)
    heapq.heappush(A, -val)
    return sum(A)
}"
1006.py,"def clumsy(self, N: int) -> int:
        if N <= 2:
            return N
        if N <= 4:
            return N + 3
        if N % 4 == 0:
            return N + 1
        elif N % 4 <= 2:
            return N + 2
        else:
            return N - 1","auto clumsy(auto N) {
    if N <= 2:
    return N
    if N <= 4:
    return N + 3
    if N % 4 == 0:
    return N + 1
    elif N % 4 <= 2:
    return N + 2
    else:
    return N - 1
}"
1007.py,"def minDominoRotations(self, A: List[int], B: List[int]) -> int:
        res = min(len(A) - max(A.count(c), B.count(c)) if all(a == c or b == c for a, b in zip(A, B)) else float('inf') for c in (A[0], B[0]))
        return res if res < float('inf') else -1","auto minDominoRotations(auto A, auto B) {
    res = min(len(A) - max(A.count(c), B.count(c)) if all(a == c or b == c for a, b in zip(A, B)) else float('inf') for c in (A[0], B[0]))
    return res if res < float('inf') else -1
}"
1008.py,"def bstFromPreorder(self, preorder: List[int]) -> TreeNode:
        root = TreeNode(preorder[0])
        stack = [root]
        for value in preorder[1:]:
            if value < stack[-1].val:
                stack[-1].left = TreeNode(value)
                stack.append(stack[-1].left)
            else:
                while stack and stack[-1].val < value:
                    last = stack.pop()
                last.right = TreeNode(value)
                stack.append(last.right)
        return root","auto bstFromPreorder(auto preorder) {
    root = TreeNode(preorder[0])
    stack = [root]
    for value in preorder[1:]:
    if value < stack[-1].val:
    stack[-1].left = TreeNode(value)
    stack.append(stack[-1].left)
    else:
    while stack and stack[-1].val < value:
    last = stack.pop()
    last.right = TreeNode(value)
    stack.append(last.right)
    return root
}"
1009.py,"def bitwiseComplement(self, N: int, M = 0, m = 0) -> int:
        return N ^ M if M and M >= N else self.bitwiseComplement(N, M + 2 ** m, m + 1)","auto bitwiseComplement(auto N, auto M = 0, auto m = 0) {
    return N ^ M if M and M >= N else self.bitwiseComplement(N, M + 2 ** m, m + 1)
}"
1010.py,"def numPairsDivisibleBy60(self, time: List[int]) -> int:
        mod = [0] * 61
        for t in time:
            mod[-1] += mod[(60 - t % 60) % 60]
            mod[t % 60] += 1
        return mod[-1]","auto numPairsDivisibleBy60(auto time) {
    mod = [0] * 61
    for t in time:
    mod[-1] += mod[(60 - t % 60) % 60]
    mod[t % 60] += 1
    return mod[-1]
}"
1011.py,"def shipWithinDays(self, weights: List[int], D: int) -> int:
        def check(mx):
            days, cur = 1, 0
            for w in weights:
                if cur + w <= mx:
                    cur += w
                else:
                    days += 1
                    cur = w
            return days
            
        l, r = max(weights), sum(weights)
        while l < r:
            mid = (l + r) // 2
            days = check(mid)
            if days <= D:
                r = mid
            else:
                l = mid + 1
        return r","auto shipWithinDays(auto weights, auto D) {
    def check(mx):
    days, cur = 1, 0
    for w in weights:
    if cur + w <= mx:
    cur += w
    else:
    days += 1
    cur = w
    return days
    
    l, r = max(weights), sum(weights)
    while l < r:
    mid = (l + r) // 2
    days = check(mid)
    if days <= D:
    r = mid
    else:
    l = mid + 1
    return r
}"
1013.py,"def canThreePartsEqualSum(self, A: List[int]) -> bool:
        tar = sum(A) // 3
        sm = cnt = 0
        for a in A:
            sm += a
            if sm == tar:
                sm = 0
                cnt += 1
        return cnt == 3","auto canThreePartsEqualSum(auto A) {
    tar = sum(A) // 3
    sm = cnt = 0
    for a in A:
    sm += a
    if sm == tar:
    sm = 0
    cnt += 1
    return cnt == 3
}"
1014.py,"def maxScoreSightseeingPair(self, A: List[int]) -> int:
        pre, mx = 0, -float('inf')
        for j, a in enumerate(A):
            mx = max(mx, pre + a - j)
            pre = max(pre, a + j)
        return mx","auto maxScoreSightseeingPair(auto A) {
    pre, mx = 0, -float('inf')
    for j, a in enumerate(A):
    mx = max(mx, pre + a - j)
    pre = max(pre, a + j)
    return mx
}"
1015.py,"def smallestRepunitDivByK(self, K: int) -> int:
        used, mod, cnt = set(), 1 % K, 1
        while mod:
            mod = (mod * 10 + 1) % K
            cnt += 1
            if mod in used:
                return -1
            used.add(mod)
        return cnt","auto smallestRepunitDivByK(auto K) {
    used, mod, cnt = set(), 1 % K, 1
    while mod:
    mod = (mod * 10 + 1) % K
    cnt += 1
    if mod in used:
    return -1
    used.add(mod)
    return cnt
}"
1016.py,"def queryString(self, S: str, N: int) -> bool:
        return not set(range(1, N + 1)) - {int(S[i:j + 1], 2) for i in range(len(S)) for j in range(i, len(S))}","auto queryString(auto S, auto N) {
    return not set(range(1, N + 1)) - {int(S[i:j + 1], 2) for i in range(len(S)) for j in range(i, len(S))}
}"
1017.py,"def baseNeg2(self, n: int) -> str:
        bits = []
        while n:
            n, rem = divmod(n, -2)
            if rem < 0:
                n += 1
                rem -= -2
            bits.append(str(rem))
        return """".join(bits[::-1]) if bits else '0'","auto baseNeg2(auto n) {
    bits = []
    while n:
    n, rem = divmod(n, -2)
    if rem < 0:
    n += 1
    rem -= -2
    bits.append(str(rem))
    return """".join(bits[::-1]) if bits else '0'
}"
1018.py,"def prefixesDivBy5(self, A: List[int]) -> List[bool]:
        num = 0
        for i in range(len(A)):
            num = (num << 1) + A[i]
            A[i] = num % 5 == 0
        return A","auto prefixesDivBy5(auto A) {
    num = 0
    for i in range(len(A)):
    num = (num << 1) + A[i]
    A[i] = num % 5 == 0
    return A
}"
1020.py,"def numEnclaves(self, A: List[List[int]]) -> int:
        def dfs(i, j):
            A[i][j] = 0
            for x, y in (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1):
                if 0 <= x < m and 0 <= y < n and A[x][y]:
                    dfs(x, y)
        m, n = len(A), len(A[0])
        for i in range(m):
            for j in range(n):
                if A[i][j] == 1 and (i == 0 or j == 0 or i == m - 1 or j == n - 1):
                    dfs(i, j)
        return sum(sum(row) for row in A)","auto numEnclaves(auto A) {
    def dfs(i, j):
    A[i][j] = 0
    for x, y in (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1):
    if 0 <= x < m and 0 <= y < n and A[x][y]:
    dfs(x, y)
    m, n = len(A), len(A[0])
    for i in range(m):
    for j in range(n):
    if A[i][j] == 1 and (i == 0 or j == 0 or i == m - 1 or j == n - 1):
    dfs(i, j)
    return sum(sum(row) for row in A)
}"
1021.py,"def removeOuterParentheses(self, S: str) -> str:
        l = r = 0
        res = cur = ''
        for s in S:
            cur += s
            l += s == '('
            r += s == ')'
            if l == r:
                res += cur[1:-1]
                cur = ''
        return res ","auto removeOuterParentheses(auto S) {
    l = r = 0
    res = cur = ''
    for s in S:
    cur += s
    l += s == '('
    r += s == ')'
    if l == r:
    res += cur[1:-1]
    cur = ''
    return res
}"
1023.py,"def camelMatch(self, queries: List[str], pattern: str) -> List[bool]:
        res = []
        for w in queries:
            j = 0
            for c in w:
                if j < len(pattern) and c == pattern[j]:
                    j += 1
                elif c.isupper():
                    j = len(pattern) + 1
            res.append(j == len(pattern))
        return res","auto camelMatch(auto queries, auto pattern) {
    res = []
    for w in queries:
    j = 0
    for c in w:
    if j < len(pattern) and c == pattern[j]:
    j += 1
    elif c.isupper():
    j = len(pattern) + 1
    res.append(j == len(pattern))
    return res
}"
1024.py,"def videoStitching(self, clips: List[List[int]], T: int) -> int:
        clips.sort(key = lambda x: (-x[0], x[1]))
        x = cnt = mx = 0
        while clips and clips[-1][0] <= x < T:
            while clips and clips[-1][0] <= x:
                mx = max(mx, clips.pop()[1])
            if mx > x:
                x = mx
                cnt += 1
        return cnt if x >= T else -1","auto videoStitching(auto clips, auto T) {
    clips.sort(key = lambda x: (-x[0], x[1]))
    x = cnt = mx = 0
    while clips and clips[-1][0] <= x < T:
    while clips and clips[-1][0] <= x:
    mx = max(mx, clips.pop()[1])
    if mx > x:
    x = mx
    cnt += 1
    return cnt if x >= T else -1
}"
1025.py,"def divisorGame(self, N: int) -> bool:
        return N % 2 == 0","auto divisorGame(auto N) {
    return N % 2 == 0
}"
1027.py,"def longestArithSeqLength(self, A: List[int]) -> int:
        dp = collections.defaultdict(int)
        for i in range(len(A)):
            for j in range(i + 1, len(A)):
                a, b = A[i], A[j]
                dp[b - a, j] = max(dp[b - a, j], dp[b - a, i] + 1)
        return max(dp.values()) + 1","auto longestArithSeqLength(auto A) {
    dp = collections.defaultdict(int)
    for i in range(len(A)):
    for j in range(i + 1, len(A)):
    a, b = A[i], A[j]
    dp[b - a, j] = max(dp[b - a, j], dp[b - a, i] + 1)
    return max(dp.values()) + 1
}"
1029.py,"def twoCitySchedCost(self, costs: List[List[int]]) -> int:
        costs.sort(key = lambda x: abs(x[0] - x[1]))
        a = b = 0
        N = len(costs) // 2
        c = 0
        for c1, c2 in costs[::-1]:
            if c1 <= c2 and a < N or b >= N:
                c += c1
                a += 1
            else:
                c += c2
                b += 1
        return c","auto twoCitySchedCost(auto costs) {
    costs.sort(key = lambda x: abs(x[0] - x[1]))
    a = b = 0
    N = len(costs) // 2
    c = 0
    for c1, c2 in costs[::-1]:
    if c1 <= c2 and a < N or b >= N:
    c += c1
    a += 1
    else:
    c += c2
    b += 1
    return c
}"
1030.py,"def allCellsDistOrder(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:
        bfs, res, seen = [[r0, c0]], [], {(r0, c0)}
        while bfs:
            res += bfs
            new = []
            for i, j in bfs:
                for x, y in (i - 1, j), (i + 1, j), (i, j + 1), (i, j - 1):
                    if 0 <= x < R and 0 <= y < C and (x, y) not in seen:
                        seen.add((x, y))
                        new.append([x, y])
            bfs = new
        return res
                        ","auto allCellsDistOrder(auto R, auto C, auto r0, auto c0) {
    bfs, res, seen = [[r0, c0]], [], {(r0, c0)}
    while bfs:
    res += bfs
    new = []
    for i, j in bfs:
    for x, y in (i - 1, j), (i + 1, j), (i, j + 1), (i, j - 1):
    if 0 <= x < R and 0 <= y < C and (x, y) not in seen:
    seen.add((x, y))
    new.append([x, y])
    bfs = new
    return res
}"
1031.py,"def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:
        n = len(A)
        l = [0] * n
        r = [0] * n
        sm = 0 
        for i in range(M - 1):
            sm += A[i]
        for j in range(n - M + 1):
            sm += A[j + M - 1]
            for i in range(j + 1):
                r[i] = max(r[i], sm)
            sm -= A[j]
        
        sm = 0
        for i in range(n - 1, n - M, -1):
            sm += A[i]
        for i in range(n - 1, M - 2, -1):
            sm += A[i - M + 1]
            for j in range(i + 1, n):
                l[j] = max(l[j], sm)
            sm -= A[i]
            
        
        
        
        sm = 0
        for i in range(L - 1):
            sm += A[i]
        res = 0
        for j in range(n - L + 1):
            sm += A[j + L - 1]
            if j >= M:
                res = max(res, sm + l[j - 1])
            if j + L < n:
                res = max(res, sm + r[j + L])
            sm -= A[j]
        return res","auto maxSumTwoNoOverlap(auto A, auto L, auto M) {
    n = len(A)
    l = [0] * n
    r = [0] * n
    sm = 0
    for i in range(M - 1):
    sm += A[i]
    for j in range(n - M + 1):
    sm += A[j + M - 1]
    for i in range(j + 1):
    r[i] = max(r[i], sm)
    sm -= A[j]
    
    sm = 0
    for i in range(n - 1, n - M, -1):
    sm += A[i]
    for i in range(n - 1, M - 2, -1):
    sm += A[i - M + 1]
    for j in range(i + 1, n):
    l[j] = max(l[j], sm)
    sm -= A[i]
    
    
    
    
    sm = 0
    for i in range(L - 1):
    sm += A[i]
    res = 0
    for j in range(n - L + 1):
    sm += A[j + L - 1]
    if j >= M:
    res = max(res, sm + l[j - 1])
    if j + L < n:
    res = max(res, sm + r[j + L])
    sm -= A[j]
    return res
}"
1033.py,"def numMovesStones(self, a: int, b: int, c: int) -> List[int]:
        a, b, c = sorted([a, b, c])
        m1 = b - 1 - a
        m2 = c - b - 1
        m1 + m2
        if a + 2 == b or b + 2 == c:
            return [1, m1 + m2]
        n1 = int(b - 1 > a)
        n2 = int(b + 1 < c)
        return [n1 + n2, m1 + m2]       
                ","auto numMovesStones(auto a, auto b, auto c) {
    a, b, c = sorted([a, b, c])
    m1 = b - 1 - a
    m2 = c - b - 1
    m1 + m2
    if a + 2 == b or b + 2 == c:
    return [1, m1 + m2]
    n1 = int(b - 1 > a)
    n2 = int(b + 1 < c)
    return [n1 + n2, m1 + m2]
}"
1034.py,"def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:
        def dfs(i, j):
            seen.add((i, j))
            if not (0 < i < m - 1 and 0 < j < n - 1 and grid[i - 1][j] == grid[i + 1][j] == grid[i][j - 1] == grid[i][j + 1] == grid[i][j]):
                matrix[i][j] = 0
            for x, y in (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1):
                if 0 <= x < m and 0 <= y < n and grid[x][y] == self.tar and (x, y) not in seen:
                    dfs(x, y)
        m, n = len(grid), len(grid[0])
        seen = set()
        self.tar = grid[r0][c0]
        matrix = [row[:] for row in grid]
        dfs(r0, c0)
        for i in range(m):
            for j in range(n):
                if not matrix[i][j]:
                    matrix[i][j] = color
        return matrix","auto colorBorder(auto grid, auto r0, auto c0, auto color) {
    def dfs(i, j):
    seen.add((i, j))
    if not (0 < i < m - 1 and 0 < j < n - 1 and grid[i - 1][j] == grid[i + 1][j] == grid[i][j - 1] == grid[i][j + 1] == grid[i][j]):
    matrix[i][j] = 0
    for x, y in (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1):
    if 0 <= x < m and 0 <= y < n and grid[x][y] == self.tar and (x, y) not in seen:
    dfs(x, y)
    m, n = len(grid), len(grid[0])
    seen = set()
    self.tar = grid[r0][c0]
    matrix = [row[:] for row in grid]
    dfs(r0, c0)
    for i in range(m):
    for j in range(n):
    if not matrix[i][j]:
    matrix[i][j] = color
    return matrix
}"
1035.py,"def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:
        dp, m, n = collections.defaultdict(int), len(A), len(B)
        for i in range(m):
            for j in range(n):
                dp[i, j] = max(dp[i - 1, j - 1] + (A[i] == B[j]), dp[i - 1, j], dp[i, j - 1])
        return dp[m - 1, n - 1]","auto maxUncrossedLines(auto A, auto B) {
    dp, m, n = collections.defaultdict(int), len(A), len(B)
    for i in range(m):
    for j in range(n):
    dp[i, j] = max(dp[i - 1, j - 1] + (A[i] == B[j]), dp[i - 1, j], dp[i, j - 1])
    return dp[m - 1, n - 1]
}"
1036.py,"def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:
        if not blocked: return True
        blocked = set(map(tuple, blocked))
        
        def check(blocked, source, target):
            si, sj = source
            ti, tj = target
            level = 0
            q = collections.deque([(si,sj)])
            vis = set()
            while q:
                for _ in range(len(q)):
                    i,j = q.popleft()
                    if i == ti and j == tj: return True
                    for x,y in ((i+1,j),(i-1,j),(i,j+1),(i,j-1)):
                        if 0<=x<10**6 and 0<=y<10**6 and (x,y) not in vis and (x,y) not in blocked:
                            vis.add((x,y))
                            q.append((x,y))
                level += 1
                if level == len(blocked): break
            else:
                return False
            return True
        
        return check(blocked, source, target) and check(blocked, target, source)","auto isEscapePossible(auto blocked, auto source, auto target) {
    if not blocked: return true
    blocked = set(map(tuple, blocked))
    
    def check(blocked, source, target):
    si, sj = source
    ti, tj = target
    level = 0
    q = collections.deque([(si,sj)])
    vis = set()
    while q:
    for _ in range(len(q)):
    i,j = q.popleft()
    if i == ti and j == tj: return true
    for x,y in ((i+1,j),(i-1,j),(i,j+1),(i,j-1)):
    if 0<=x<10**6 and 0<=y<10**6 and (x,y) not in vis and (x,y) not in blocked:
    vis.add((x,y))
    q.append((x,y))
    level += 1
    if level == len(blocked): break
    else:
    return false
    return true
    
    return check(blocked, source, target) and check(blocked, target, source)
}"
1037.py,"def isBoomerang(self, p: List[List[int]]) -> bool:
        return (p[0][0] - p[1][0]) * (p[0][1] - p[2][1]) != (p[0][0] - p[2][0]) * (p[0][1] - p[1][1])","auto isBoomerang(auto p) {
    return (p[0][0] - p[1][0]) * (p[0][1] - p[2][1]) != (p[0][0] - p[2][0]) * (p[0][1] - p[1][1])
}"
1039.py,"def minScoreTriangulation(self, A: List[int]) -> int:
        memo = {}
        def dp(i, j):
            if (i, j) not in memo:
                memo[i, j] = min([dp(i, k) + dp(k, j) + A[i] * A[j] * A[k] for k in range(i + 1, j)] or [0])
            return memo[i, j]
        return dp(0, len(A) - 1)","auto minScoreTriangulation(auto A) {
    memo = {}
    def dp(i, j):
    if (i, j) not in memo:
    memo[i, j] = min([dp(i, k) + dp(k, j) + A[i] * A[j] * A[k] for k in range(i + 1, j)] or [0])
    return memo[i, j]
    return dp(0, len(A) - 1)
}"
1040.py,"def numMovesStonesII(self, A: List[int]) -> List[int]:
        A.sort()
        i, n, low = 0, len(A), len(A)
        high = max(A[-1] - n + 2 - A[1], A[-2] - A[0] - n + 2)
        for j in range(n):
            while A[j] - A[i] >= n: i += 1
            if j - i + 1 == n - 1 and A[j] - A[i] == n - 2:
                low = min(low, 2)
            else:
                low = min(low, n - (j - i + 1))
        return [low, high]","auto numMovesStonesII(auto A) {
    A.sort()
    i, n, low = 0, len(A), len(A)
    high = max(A[-1] - n + 2 - A[1], A[-2] - A[0] - n + 2)
    for j in range(n):
    while A[j] - A[i] >= n: i += 1
    if j - i + 1 == n - 1 and A[j] - A[i] == n - 2:
    low = min(low, 2)
    else:
    low = min(low, n - (j - i + 1))
    return [low, high]
}"
1041.py,"def isRobotBounded(self, instructions: str) -> bool:
        x, y, dx, dy = 0, 0, 0, 1
        for _ in range(4):
            for ins in instructions:
                if ins == 'G':
                    x += dx
                    y += dy
                elif ins == 'L':
                    dx, dy = -dy, dx
                else:
                    dx, dy = dy, -dx
        return x == y == 0","auto isRobotBounded(auto instructions) {
    x, y, dx, dy = 0, 0, 0, 1
    for _ in range(4):
    for ins in instructions:
    if ins == 'G':
    x += dx
    y += dy
    elif ins == 'L':
    dx, dy = -dy, dx
    else:
    dx, dy = dy, -dx
    return x == y == 0
}"
1042.py,"def gardenNoAdj(self, N: int, paths: List[List[int]]) -> List[int]:
        res = [0] * N
        G = [[] for i in range(N)]
        for x, y in paths:
            G[x - 1].append(y - 1)
            G[y - 1].append(x - 1)
        for i in range(N):
            res[i] = ({1, 2, 3, 4} - {res[j] for j in G[i]}).pop()
        return res","auto gardenNoAdj(auto N, auto paths) {
    res = [0] * N
    G = [[] for i in range(N)]
    for x, y in paths:
    G[x - 1].append(y - 1)
    G[y - 1].append(x - 1)
    for i in range(N):
    res[i] = ({1, 2, 3, 4} - {res[j] for j in G[i]}).pop()
    return res
}"
1043.py,"def maxSumAfterPartitioning(self, A: List[int], K: int) -> int:
        N = len(A)
        dp = [0] * (N + K)
        for i in range(N):
            curMax = 0
            for k in range(1, min(K, i + 1) + 1):
                curMax = max(curMax, A[i - k + 1])
                dp[i] = max(dp[i], dp[i - k] + curMax * k)
        return dp[N - 1]","auto maxSumAfterPartitioning(auto A, auto K) {
    N = len(A)
    dp = [0] * (N + K)
    for i in range(N):
    curMax = 0
    for k in range(1, min(K, i + 1) + 1):
    curMax = max(curMax, A[i - k + 1])
    dp[i] = max(dp[i], dp[i - k] + curMax * k)
    return dp[N - 1]
}"
1046.py,"def lastStoneWeight(self, stones: List[int]) -> int:
        stones.sort()
        for _ in range(len(stones) - 1):
            bisect.insort(stones, stones.pop() - stones.pop())
        return stones[0]","auto lastStoneWeight(auto stones) {
    stones.sort()
    for _ in range(len(stones) - 1):
    bisect.insort(stones, stones.pop() - stones.pop())
    return stones[0]
}"
1047.py,"def removeDuplicates(self, S: str) -> str:
        stack = []
        for s in S:
            if stack and stack[-1] == s:
                stack.pop()
            else:
                stack.append(s)
        return ''.join(stack)","auto removeDuplicates(auto S) {
    stack = []
    for s in S:
    if stack and stack[-1] == s:
    stack.pop()
    else:
    stack.append(s)
    return ''.join(stack)
}"
1048.py,"def longestStrChain(self, words: List[str]) -> int:
        def dfs(w1, size):
            return max([dfs(w2, size + 1) for w2 in graph[w1]], default = size)
        graph = collections.defaultdict(list)
        for w in words:
            graph[len(w)].append(w)
        for w1 in words:
            for w2 in graph[len(w1) + 1]:
                for i in range(len(w2)):
                    if w2[:i] + w2[i + 1:] == w1:
                        graph[w1].append(w2)
        return max(dfs(w, 1) for w in words)","auto longestStrChain(auto words) {
    def dfs(w1, size):
    return max([dfs(w2, size + 1) for w2 in graph[w1]], default = size)
    graph = collections.defaultdict(list)
    for w in words:
    graph[len(w)].append(w)
    for w1 in words:
    for w2 in graph[len(w1) + 1]:
    for i in range(len(w2)):
    if w2[:i] + w2[i + 1:] == w1:
    graph[w1].append(w2)
    return max(dfs(w, 1) for w in words)
}"
1049.py,"def lastStoneWeightII(self, A: List[int]) -> int:
        dp = {0}
        sumA = sum(A)
        for a in A:
            dp |= {a + i for i in dp}
        return min(abs(sumA - i - i) for i in dp)","auto lastStoneWeightII(auto A) {
    dp = {0}
    sumA = sum(A)
    for a in A:
    dp |= {a + i for i in dp}
    return min(abs(sumA - i - i) for i in dp)
}"
1051.py,"def heightChecker(self, heights: List[int]) -> int:
        return sum(h1 != h2 for h1, h2 in zip(heights, sorted(heights)))","auto heightChecker(auto heights) {
    return sum(h1 != h2 for h1, h2 in zip(heights, sorted(heights)))
}"
1052.py,"def maxSatisfied(self, customers: List[int], grumpy: List[int], x: int) -> int:
        dif = mx = sum(c * g for c, g in zip(customers[:x], grumpy[:x]))
        for j in range(x, len(grumpy)):
            dif += (grumpy[j] * customers[j]) - (grumpy[j - x] * customers[j - x])
            mx = max(mx, dif)
        return mx + sum(c * (1- g) for c, g in zip(customers, grumpy))","auto maxSatisfied(auto customers, auto grumpy, auto x) {
    dif = mx = sum(c * g for c, g in zip(customers[:x], grumpy[:x]))
    for j in range(x, len(grumpy)):
    dif += (grumpy[j] * customers[j]) - (grumpy[j - x] * customers[j - x])
    mx = max(mx, dif)
    return mx + sum(c * (1- g) for c, g in zip(customers, grumpy))
}"
1053.py,"def prevPermOpt1(self, A: List[int]) -> List[int]:
        pre = []
        for i in range(len(A) - 1, -1, -1):
            bisect.insort_left(pre, (A[i], i))
            if pre.index((A[i], i)):
                j = pre[pre.index((A[i], i)) - 1][1]
                A[i], A[j] = A[j], A[i]
                break
        return A","auto prevPermOpt1(auto A) {
    pre = []
    for i in range(len(A) - 1, -1, -1):
    bisect.insort_left(pre, (A[i], i))
    if pre.index((A[i], i)):
    j = pre[pre.index((A[i], i)) - 1][1]
    A[i], A[j] = A[j], A[i]
    break
    return A
}"
1054.py,"def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:
        cnt = collections.Counter(barcodes).most_common()[::-1]
        ref = [val for val, t in cnt for _ in range(t)]
        for i in range(0, len(barcodes), 2):
            barcodes[i] = ref.pop()
        for i in range(1, len(barcodes), 2):
            barcodes[i] = ref.pop()
        return barcodes","auto rearrangeBarcodes(auto barcodes) {
    cnt = collections.Counter(barcodes).most_common()[::-1]
    ref = [val for val, t in cnt for _ in range(t)]
    for i in range(0, len(barcodes), 2):
    barcodes[i] = ref.pop()
    for i in range(1, len(barcodes), 2):
    barcodes[i] = ref.pop()
    return barcodes
}"
1055.py,"def shortestWay(self, source: str, target: str) -> int:
        cnt = i = 0
        for t in target:
            i = source.find(t, i)
            if i == -1:
                i = source.find(t, 0)
                if i == -1:
                    return -1
                cnt += 1
            i += 1
        return cnt + 1","auto shortestWay(auto source, auto target) {
    cnt = i = 0
    for t in target:
    i = source.find(t, i)
    if i == -1:
    i = source.find(t, 0)
    if i == -1:
    return -1
    cnt += 1
    i += 1
    return cnt + 1
}"
1056.py,"def confusingNumber(self, N: int) -> bool:
        ret = ''.join(""01####9#86""[int(n)] for n in str(N)[::-1])
        return '#' not in ret and ret != str(N)","auto confusingNumber(auto N) {
    ret = ''.join(""01####9#86""[int(n)] for n in str(N)[::-1])
    return '#' not in ret and ret != str(N)
}"
1057.py,"def assignBikes(self, W: List[List[int]], B: List[List[int]]) -> List[int]:
        ans, used = [-1] * len(W), set()
        for d, w, b in sorted([abs(W[i][0] - B[j][0]) + abs(W[i][1] - B[j][1]), i, j] for i in range(len(W)) for j in range(len(B))):
            if ans[w] == -1 and b not in used:
                ans[w] = b
                used.add(b)
            if len(used) == len(ans):
                break
        return ans","auto assignBikes(auto W, auto B) {
    ans, used = [-1] * len(W), set()
    for d, w, b in sorted([abs(W[i][0] - B[j][0]) + abs(W[i][1] - B[j][1]), i, j] for i in range(len(W)) for j in range(len(B))):
    if ans[w] == -1 and b not in used:
    ans[w] = b
    used.add(b)
    if len(used) == len(ans):
    break
    return ans
}"
1058.py,"def minimizeError(self, prices: List[str], target: int) -> str:
        prices = [float(p) for p in prices]
        sm = sum(math.floor(p) for p in prices)
        prices = sorted(p - math.floor(p) for p in prices if p - math.floor(p))
        if sm > target or target - sm > len(prices):
            return ""-1""
        return ""{:.3f}"".format(sum([p - math.floor(p) for p in  prices[:sm - target]]) + sum([math.ceil(p) - p for p in prices[sm - target:]]))","auto minimizeError(auto prices, auto target) {
    prices = [float(p) for p in prices]
    sm = sum(math.floor(p) for p in prices)
    prices = sorted(p - math.floor(p) for p in prices if p - math.floor(p))
    if sm > target or target - sm > len(prices):
    return ""-1""
    return ""{:.3f}"".format(sum([p - math.floor(p) for p in  prices[:sm - target]]) + sum([math.ceil(p) - p for p in prices[sm - target:]]))
}"
1059.py,"def leadsToDestination(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:
        def dfs(i):
            seen.add(i)
            for j in graph[i]:
                if j == i or j in seen or not dfs(j):
                    return False
            seen.discard(i)
            return len(graph[i]) != 0 or i == destination
        graph, seen = collections.defaultdict(set), set()
        for a, b in edges:
            graph[a].add(b)
        return dfs(source)
        ","auto leadsToDestination(auto n, auto edges, auto source, auto destination) {
    def dfs(i):
    seen.add(i)
    for j in graph[i]:
    if j == i or j in seen or not dfs(j):
    return false
    seen.discard(i)
    return len(graph[i]) != 0 or i == destination
    graph, seen = collections.defaultdict(set), set()
    for a, b in edges:
    graph[a].add(b)
    return dfs(source)
}"
106.py,"def buildTree(self, inorder, postorder):
        if inorder:
            ind = inorder.index(postorder.pop())
            root = TreeNode(inorder[ind])
            root.right = self.buildTree(inorder[ind+1:], postorder)
            root.left = self.buildTree(inorder[:ind], postorder)
            return root","auto buildTree(auto inorder, auto postorder) {
    if inorder:
    ind = inorder.index(postorder.pop())
    root = TreeNode(inorder[ind])
    root.right = self.buildTree(inorder[ind+1:], postorder)
    root.left = self.buildTree(inorder[:ind], postorder)
    return root
}"
1060.py,"def missingElement(self, nums: List[int], k: int) -> int:
        cur = nums[0]
        for num in nums[1:]:
            if num - cur - 1 >= k:
                break
            else:
                k -= num - cur - 1
            cur = num
        return cur + k","auto missingElement(auto nums, auto k) {
    cur = nums[0]
    for num in nums[1:]:
    if num - cur - 1 >= k:
    break
    else:
    k -= num - cur - 1
    cur = num
    return cur + k
}"
1061.py,"def smallestEquivalentString(self, A: str, B: str, S: str) -> str:
        def root(c):
            return c if parent[c] == c else root(parent[c])
        parent = {s: s for s in string.ascii_lowercase}
        for a, b in zip(A, B):
            p1, p2 = root(a), root(b)
            if p1 <= p2:
                parent[p2] = p1
            else:
                parent[p1] = p2
        return ''.join(root(s) for s in S)","auto smallestEquivalentString(auto A, auto B, auto S) {
    def root(c):
    return c if parent[c] == c else root(parent[c])
    parent = {s: s for s in string.ascii_lowercase}
    for a, b in zip(A, B):
    p1, p2 = root(a), root(b)
    if p1 <= p2:
    parent[p2] = p1
    else:
    parent[p1] = p2
    return ''.join(root(s) for s in S)
}"
1062.py,"def longestRepeatingSubstring(self, S: str) -> int:
        for l in range(len(S), 0, -1):
            s = S[:l]
            seen = {s}
            for j in range(l, len(S)):
                s = s[1:] + S[j]
                if s in seen:
                    return l
                seen.add(s)
        return 0
                ","auto longestRepeatingSubstring(auto S) {
    for l in range(len(S), 0, -1):
    s = S[:l]
    seen = {s}
    for j in range(l, len(S)):
    s = s[1:] + S[j]
    if s in seen:
    return l
    seen.add(s)
    return 0
}"
1063.py,"def validSubarrays(self, nums: List[int]) -> int:
        stack, res = [], 0
        for num in nums:
            while stack and stack[-1] > num:
                stack.pop()
            stack.append(num)
            res += len(stack)
        return res","auto validSubarrays(auto nums) {
    stack, res = [], 0
    for num in nums:
    while stack and stack[-1] > num:
    stack.pop()
    stack.append(num)
    res += len(stack)
    return res
}"
1064.py,"def fixedPoint(self, A: List[int]) -> int:
        return ([i for i in range(len(A)) if A[i] == i] + [-1])[0]","auto fixedPoint(auto A) {
    return ([i for i in range(len(A)) if A[i] == i] + [-1])[0]
}"
1065.py,"def indexPairs(self, text: str, words: List[str]) -> List[List[int]]:
        return [[i, j] for i in range(len(text)) for j in range(i, len(text)) if text[i:j + 1] in words]","auto indexPairs(auto text, auto words) {
    return [[i, j] for i in range(len(text)) for j in range(i, len(text)) if text[i:j + 1] in words]
}"
1066.py,"def assignBikes(self, workers: List[List[int]], bikes: List[List[int]]) -> int:
        def dis(i, j):
            return abs(workers[i][0] - bikes[j][0]) + abs(workers[i][1] - bikes[j][1])
        h = [[0, 0, 0]]
        seen = set()
        while True:
            cost, i, taken = heapq.heappop(h)
            if (i, taken) in seen: continue
            seen.add((i, taken))
            if i == len(workers):
                return cost
            for j in range(len(bikes)):
                if taken & (1 << j) == 0:
                    heapq.heappush(h, [cost + dis(i, j), i + 1, taken | (1 << j)])","auto assignBikes(auto workers, auto bikes) {
    def dis(i, j):
    return abs(workers[i][0] - bikes[j][0]) + abs(workers[i][1] - bikes[j][1])
    h = [[0, 0, 0]]
    seen = set()
    while true:
    cost, i, taken = heapq.heappop(h)
    if (i, taken) in seen: continue
    seen.add((i, taken))
    if i == len(workers):
    return cost
    for j in range(len(bikes)):
    if taken & (1 << j) == 0:
    heapq.heappush(h, [cost + dis(i, j), i + 1, taken | (1 << j)])
}"
1071.py,"def gcdOfStrings(self, str1: str, str2: str) -> str:
        if len(str1) == len(str2):
            return str1 if str1==str2 else ''
        else:
            if len(str1) < len(str2):
                str1,str2 = str2,str1
            if str1[:len(str2)] == str2:
                return self.gcdOfStrings(str1[len(str2):],str2)
            else:
                return ''","auto gcdOfStrings(auto str1, auto str2) {
    if len(str1) == len(str2):
    return str1 if str1==str2 else ''
    else:
    if len(str1) < len(str2):
    str1,str2 = str2,str1
    if str1[:len(str2)] == str2:
    return self.gcdOfStrings(str1[len(str2):],str2)
    else:
    return ''
}"
1072.py,"def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:
        res = 0
        for row in matrix:
            inv = [1 - r for r in row]
            res = max(res, sum(row == r or inv == r for r in matrix))
        return res
            ","auto maxEqualRowsAfterFlips(auto matrix) {
    res = 0
    for row in matrix:
    inv = [1 - r for r in row]
    res = max(res, sum(row == r or inv == r for r in matrix))
    return res
}"
1074.py,"def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:
        m, n = len(matrix), len(matrix[0])
        for row in matrix:
            for i in range(1, n):
                row[i] += row[i-1]
                
        res = 0
        for i in range(n):
            for j in range(i, n):
                c = {0:1}
                cur = 0
                for row in matrix:
                    cur += row[j] - (row[i-1] if i else 0)
                    
                    if cur - target in c:
                        res += c[cur-target]
                    
                    c[cur] = c.get(cur, 0) + 1
        return res","auto numSubmatrixSumTarget(auto matrix, auto target) {
    m, n = len(matrix), len(matrix[0])
    for row in matrix:
    for i in range(1, n):
    row[i] += row[i-1]
    
    res = 0
    for i in range(n):
    for j in range(i, n):
    c = {0:1}
    cur = 0
    for row in matrix:
    cur += row[j] - (row[i-1] if i else 0)
    
    if cur - target in c:
    res += c[cur-target]
    
    c[cur] = c.get(cur, 0) + 1
    return res
}"
1078.py,"def findOcurrences(self, text: str, first: str, second: str) -> List[str]:
        text = text.split()
        return [text[i] for i in range(2, len(text)) if text[i-1] == second and text[i-2] == first]                         ","auto findOcurrences(auto text, auto first, auto second) {
    text = text.split()
    return [text[i] for i in range(2, len(text)) if text[i-1] == second and text[i-2] == first]
}"
1079.py,"def numTilePossibilities(self, tiles: str) -> int:
        return sum(len(set(itertools.permutations(tiles, i))) for i in range(1, len(tiles) + 1))","auto numTilePossibilities(auto tiles) {
    return sum(len(set(itertools.permutations(tiles, i))) for i in range(1, len(tiles) + 1))
}"
1080.py,"def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:
        if root.left == root.right is None:
            return None if root.val < limit else root
        if root.left:
            root.left = self.sufficientSubset(root.left, limit - root.val)
        if root.right:
            root.right = self.sufficientSubset(root.right, limit - root.val)
        return root if root.left or root.right else None","auto sufficientSubset(auto root, auto limit) {
    if root.left == root.right is nullptr:
    return nullptr if root.val < limit else root
    if root.left:
    root.left = self.sufficientSubset(root.left, limit - root.val)
    if root.right:
    root.right = self.sufficientSubset(root.right, limit - root.val)
    return root if root.left or root.right else nullptr
}"
1081.py,"def smallestSubsequence(self, S: str) -> str:
        last = {c: i for i, c in enumerate(S)}
        res = """"
        left = 0
        while last:
            right = min(last.values())
            c, i = min((S[i], i) for i in range(left, right + 1) if S[i] not in res)
            left = i + 1
            res += c
            del last[c]
        return res","auto smallestSubsequence(auto S) {
    last = {c: i for i, c in enumerate(S)}
    res = """"
    left = 0
    while last:
    right = min(last.values())
    c, i = min((S[i], i) for i in range(left, right + 1) if S[i] not in res)
    left = i + 1
    res += c
    del last[c]
    return res
}"
1085.py,"def sumOfDigits(self, A: List[int]) -> int:
        return 1 - sum(map(int, str(min(A)))) % 2
        return 1 - sum(int(c) for c in str(min(A))) % 2","auto sumOfDigits(auto A) {
    return 1 - sum(map(int, str(min(A)))) % 2
    return 1 - sum(int(c) for c in str(min(A))) % 2
}"
1086.py,"def highFive(self, items: List[List[int]]) -> List[List[int]]:
        res = []
        items.sort(key = lambda x: (-x[0], x[1]))
        while items:
            res.append([items[-1][0], sum(b for a, b in items[-5:]) // 5])
            while items and items[-1][0] == res[-1][0]:
                items.pop()
        return res","auto highFive(auto items) {
    res = []
    items.sort(key = lambda x: (-x[0], x[1]))
    while items:
    res.append([items[-1][0], sum(b for a, b in items[-5:]) // 5])
    while items and items[-1][0] == res[-1][0]:
    items.pop()
    return res
}"
1087.py,"def permute(self, S: str) -> List[str]:
        bfs = [""""]
        mult = False
        chars = []
        for s in S:
            if s == ',': 
                continue
            elif s == '{':
                mult = True
            elif s == '}':
                bfs = [st + c for st in bfs for c in chars]
                chars = []
                mult = False
            elif mult:
                chars.append(s)
            else:
                bfs = [st + s for st in bfs]
        return sorted(bfs)
                ","auto permute(auto S) {
    bfs = [""""]
    mult = false
    chars = []
    for s in S:
    if s == ',':
    continue
    elif s == '{':
    mult = true
    elif s == '}':
    bfs = [st + c for st in bfs for c in chars]
    chars = []
    mult = false
    elif mult:
    chars.append(s)
    else:
    bfs = [st + s for st in bfs]
    return sorted(bfs)
}"
1088.py,"def confusingNumberII(self, N: int) -> int:
        def diff(num):
            return num != ''.join('9' if c == '6' else '6' if c == '9' else c for c in num[::-1])
        def dfs(num):
            return sum(dfs(num * 10 + dig) for dig in [0, 1, 6, 8, 9]) + diff(str(num)) if num <= N else 0
        return sum(dfs(n) for n in [1, 6, 8, 9]) if N != 1000000000 else 1950627","auto confusingNumberII(auto N) {
    def diff(num):
    return num != ''.join('9' if c == '6' else '6' if c == '9' else c for c in num[::-1])
    def dfs(num):
    return sum(dfs(num * 10 + dig) for dig in [0, 1, 6, 8, 9]) + diff(str(num)) if num <= N else 0
    return sum(dfs(n) for n in [1, 6, 8, 9]) if N != 1000000000 else 1950627
}"
1089.py,"def duplicateZeros(self, arr: List[int]) -> None:
        """"""
        Do not return anything, modify arr in-place instead.
        """"""
        i = 0
        for num in list(arr):
            if i >= len(arr): break
            arr[i] = num
            if not num:
                i += 1
                if i < len(arr):
                    arr[i] = num
            i += 1","auto duplicateZeros(auto arr) {
    """"""
    Do not return anything, modify arr in-place instead.
    """"""
    i = 0
    for num in list(arr):
    if i >= len(arr): break
    arr[i] = num
    if not num:
    i += 1
    if i < len(arr):
    arr[i] = num
    i += 1
}"
1090.py,"def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:
        cnt = collections.defaultdict(int)
        heap = [[-a, b] for a, b in zip(values, labels)]
        heapq.heapify(heap)
        use = sm =0 
        while use < num_wanted and heap:
            a, b = heapq.heappop(heap)
            if cnt[b] < use_limit:
                sm -= a
                use += 1
                cnt[b] += 1
        return sm","auto largestValsFromLabels(auto values, auto labels, auto num_wanted, auto use_limit) {
    cnt = collections.defaultdict(int)
    heap = [[-a, b] for a, b in zip(values, labels)]
    heapq.heapify(heap)
    use = sm =0
    while use < num_wanted and heap:
    a, b = heapq.heappop(heap)
    if cnt[b] < use_limit:
    sm -= a
    use += 1
    cnt[b] += 1
    return sm
}"
1091.py,"def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        n = len(grid)
        if grid[0][0] == 1:
            return -1
        bfs = [[0, 0]]
        cnt = 1
        seen = {(0, 0)}
        while bfs:
            new = []
            for i, j in bfs:
                for x, y in (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1), (i - 1, j - 1), (i + 1, j + 1), (i - 1, j + 1), (i + 1, j - 1):
                    if 0 <= x < n and 0 <= y < n and (x, y) not in seen and not grid[x][y]:
                        if x == y == n - 1:
                            return cnt + 1
                        new.append((x, y))
                        seen.add((x, y))
            cnt += 1
            bfs = new
        return -1","auto shortestPathBinaryMatrix(auto grid) {
    n = len(grid)
    if grid[0][0] == 1:
    return -1
    bfs = [[0, 0]]
    cnt = 1
    seen = {(0, 0)}
    while bfs:
    new = []
    for i, j in bfs:
    for x, y in (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1), (i - 1, j - 1), (i + 1, j + 1), (i - 1, j + 1), (i + 1, j - 1):
    if 0 <= x < n and 0 <= y < n and (x, y) not in seen and not grid[x][y]:
    if x == y == n - 1:
    return cnt + 1
    new.append((x, y))
    seen.add((x, y))
    cnt += 1
    bfs = new
    return -1
}"
1092.py,"def shortestCommonSupersequence(self, str1: str, str2: str) -> str:
        def compute_lcs(s, t):
            m, n = len(s), len(t)
            dp = [[""""] * (n + 1) for _ in range(m + 1)]
            for i in range(1, m + 1):
                for j in range(1, n + 1):
                    if s[i - 1] != t[j - 1]:
                        dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], key=len)
                    else:
                        dp[i][j] = dp[i - 1][j - 1] + s[i - 1]
            return dp[-1][-1]
        cs = compute_lcs(str1, str2)
        ans = []
        i, j = 0, 0
        m, n = len(str1), len(str2)
        for ch in cs:
            while i < m and str1[i] != ch:
                ans.append(str1[i])
                i += 1
            while j < n and str2[j] != ch:
                ans.append(str2[j])
                j += 1
            ans.append(ch)
            i += 1
            j += 1
        return ''.join(ans) + str1[i:] + str2[j:]","auto shortestCommonSupersequence(auto str1, auto str2) {
    def compute_lcs(s, t):
    m, n = len(s), len(t)
    dp = [[""""] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
    for j in range(1, n + 1):
    if s[i - 1] != t[j - 1]:
    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], key=len)
    else:
    dp[i][j] = dp[i - 1][j - 1] + s[i - 1]
    return dp[-1][-1]
    cs = compute_lcs(str1, str2)
    ans = []
    i, j = 0, 0
    m, n = len(str1), len(str2)
    for ch in cs:
    while i < m and str1[i] != ch:
    ans.append(str1[i])
    i += 1
    while j < n and str2[j] != ch:
    ans.append(str2[j])
    j += 1
    ans.append(ch)
    i += 1
    j += 1
    return ''.join(ans) + str1[i:] + str2[j:]
}"
1093.py,"def sampleStats(self, count: List[int]) -> List[float]:
        arr = [(i, c * 1.0) for i, c in enumerate(count) if c]
        acc = list(itertools.accumulate(count, lambda x, y: x + y))
        mean = sum(i * c for i, c in arr) / acc[-1] 
        mode = max(arr, key = lambda x: x[1])[0] * 1.0
        m1 = bisect.bisect(acc, (acc[-1] - 1) // 2)
        m2 = bisect.bisect(acc, acc[-1] // 2)
        return [arr[0][0] * 1.0, arr[-1][0] * 1.0, mean, (m1 + m2) / 2.0, mode]
        ","auto sampleStats(auto count) {
    arr = [(i, c * 1.0) for i, c in enumerate(count) if c]
    acc = list(itertools.accumulate(count, lambda x, y: x + y))
    mean = sum(i * c for i, c in arr) / acc[-1]
    mode = max(arr, key = lambda x: x[1])[0] * 1.0
    m1 = bisect.bisect(acc, (acc[-1] - 1) // 2)
    m2 = bisect.bisect(acc, acc[-1] // 2)
    return [arr[0][0] * 1.0, arr[-1][0] * 1.0, mean, (m1 + m2) / 2.0, mode]
}"
1094.py,"def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
        heap = []
        for a, b, c in trips:
            heapq.heappush(heap, (b, a))
            heapq.heappush(heap, (c, -a))
        cur = 0
        while heap:
            cur += heapq.heappop(heap)[1]
            if cur > capacity: return False
        return True","auto carPooling(auto trips, auto capacity) {
    heap = []
    for a, b, c in trips:
    heapq.heappush(heap, (b, a))
    heapq.heappush(heap, (c, -a))
    cur = 0
    while heap:
    cur += heapq.heappop(heap)[1]
    if cur > capacity: return false
    return true
}"
1096.py,"def braceExpansionII(self, expression: str) -> List[str]:
        stack,res,cur=[],[],[]
        for i in range(len(expression)):
            v=expression[i]
            if v.isalpha():
                cur=[c+v for c in cur or ['']]
            elif v=='{':
                stack.append(res)
                stack.append(cur)
                res,cur=[],[]
            elif v=='}':
                pre=stack.pop()
                preRes=stack.pop()
                cur=[p+c for c in res+cur for p in pre or ['']]
                res=preRes
            elif v==',':
                res+=cur
                cur=[]
        return sorted(set(res+cur))
        ","auto braceExpansionII(auto expression) {
    stack,res,cur=[],[],[]
    for i in range(len(expression)):
    v=expression[i]
    if v.isalpha():
    cur=[c+v for c in cur or ['']]
    elif v=='{':
    stack.append(res)
    stack.append(cur)
    res,cur=[],[]
    elif v=='}':
    pre=stack.pop()
    preRes=stack.pop()
    cur=[p+c for c in res+cur for p in pre or ['']]
    res=preRes
    elif v==',':
    res+=cur
    cur=[]
    return sorted(set(res+cur))
}"
1099.py,"def twoSumLessThanK(self, A: List[int], K: int) -> int:
        A.sort()
        res, l, r = -1, 0, len(A) - 1
        while l < r:
            if A[l] + A[r] >= K:
                r -= 1
            else:
                res = max(res, A[l] + A[r])
                l += 1
        return res","auto twoSumLessThanK(auto A, auto K) {
    A.sort()
    res, l, r = -1, 0, len(A) - 1
    while l < r:
    if A[l] + A[r] >= K:
    r -= 1
    else:
    res = max(res, A[l] + A[r])
    l += 1
    return res
}"
11.py,"def maxArea(self, height):
        left, right, mx = 0, len(height) - 1, 0
        while left < right:
            mx = max(mx, (right - left) * min(height[left], height[right]))
            if height[left] < height[right]: 
                left += 1
            else: 
                right -= 1
        return mx","auto maxArea(auto height) {
    left, right, mx = 0, len(height) - 1, 0
    while left < right:
    mx = max(mx, (right - left) * min(height[left], height[right]))
    if height[left] < height[right]:
    left += 1
    else:
    right -= 1
    return mx
}"
1100.py,"def numKLenSubstrNoRepeats(self, S: str, K: int) -> int:
        cnt = collections.Counter(S[:K - 1])
        res = 0
        for i in range(K - 1, len(S)):
            cnt[S[i]] += 1
            if len(cnt) == K:
                res += 1
            cnt[S[i - K + 1]] -= 1
            if not cnt[S[i - K + 1]]:
                cnt.pop(S[i - K + 1])
        return res","auto numKLenSubstrNoRepeats(auto S, auto K) {
    cnt = collections.Counter(S[:K - 1])
    res = 0
    for i in range(K - 1, len(S)):
    cnt[S[i]] += 1
    if len(cnt) == K:
    res += 1
    cnt[S[i - K + 1]] -= 1
    if not cnt[S[i - K + 1]]:
    cnt.pop(S[i - K + 1])
    return res
}"
1101.py,"def earliestAcq(self, logs: List[List[int]], N: int) -> int:
        def root(a):
            return a if parent[a] == a else root(parent[a])
        parent = [i for i in range(N)]
        time = -1
        for t, a, b in sorted(logs):
            A, B = root(a), root(b)
            parent[A] = parent[a] = parent[b] = B
            if A != B:
                time = t
        return time if all(root(a) == root(b) for a, b in zip(parent, parent[1:])) else -1","auto earliestAcq(auto logs, auto N) {
    def root(a):
    return a if parent[a] == a else root(parent[a])
    parent = [i for i in range(N)]
    time = -1
    for t, a, b in sorted(logs):
    A, B = root(a), root(b)
    parent[A] = parent[a] = parent[b] = B
    if A != B:
    time = t
    return time if all(root(a) == root(b) for a, b in zip(parent, parent[1:])) else -1
}"
1102.py,"def maximumMinimumPath(self, A: List[List[int]]) -> int:
        heap = [(-A[0][0], 0, 0)]
        res = A[0][0]
        m, n = len(A), len(A[0])
        while heap:
            val, i, j = heapq.heappop(heap)
            A[i][j] = -1
            res = min(res, -val)
            if i == m - 1 and j == n - 1:
                break
            for x, y in (i + 1, j) , (i - 1, j), (i, j + 1), (i, j - 1):
                if 0 <= x < m and 0 <= y < n and A[x][y] >= 0:
                    heapq.heappush(heap, (-A[x][y], x, y))
        return res
            ","auto maximumMinimumPath(auto A) {
    heap = [(-A[0][0], 0, 0)]
    res = A[0][0]
    m, n = len(A), len(A[0])
    while heap:
    val, i, j = heapq.heappop(heap)
    A[i][j] = -1
    res = min(res, -val)
    if i == m - 1 and j == n - 1:
    break
    for x, y in (i + 1, j) , (i - 1, j), (i, j + 1), (i, j - 1):
    if 0 <= x < m and 0 <= y < n and A[x][y] >= 0:
    heapq.heappush(heap, (-A[x][y], x, y))
    return res
}"
1103.py,"def distributeCandies(self, candies: int, num_people: int) -> List[int]:
        res = [0] * num_people
        i = 0
        while candies > 0:
            res[i % num_people] += min(candies, i + 1)
            i += 1
            candies -= i
        return res","auto distributeCandies(auto candies, auto num_people) {
    res = [0] * num_people
    i = 0
    while candies > 0:
    res[i % num_people] += min(candies, i + 1)
    i += 1
    candies -= i
    return res
}"
1104.py,"def pathInZigZagTree(self, label: int) -> List[int]:
        res = [label]
        while label != 1:
            d = int(math.log(label) / math.log(2))
            offset = int(2 ** (d + 1)) - label - 1
            label = (int(2 ** d) + offset) // 2
            res = [label] + res
        return res","auto pathInZigZagTree(auto label) {
    res = [label]
    while label != 1:
    d = int(math.log(label) / math.log(2))
    offset = int(2 ** (d + 1)) - label - 1
    label = (int(2 ** d) + offset) // 2
    res = [label] + res
    return res
}"
1105.py,"def minHeightShelves(self, books: List[List[int]], shelf_width: int) -> int:
        n = len(books)
        dp = [float('inf') for _ in range(n + 1)]
        dp[0] = 0
        for i in range(1, n + 1):
            max_width = shelf_width
            max_height = 0
            j = i - 1
            while j >= 0 and max_width - books[j][0] >= 0:
                max_width -= books[j][0]
                max_height = max(max_height, books[j][1])
                dp[i] = min(dp[i], dp[j] + max_height)
                j -= 1
        return dp[n] 
    ","auto minHeightShelves(auto books, auto shelf_width) {
    n = len(books)
    dp = [float('inf') for _ in range(n + 1)]
    dp[0] = 0
    for i in range(1, n + 1):
    max_width = shelf_width
    max_height = 0
    j = i - 1
    while j >= 0 and max_width - books[j][0] >= 0:
    max_width -= books[j][0]
    max_height = max(max_height, books[j][1])
    dp[i] = min(dp[i], dp[j] + max_height)
    j -= 1
    return dp[n]
}"
1106.py,"def parseBoolExpr(self, expression: str) -> bool:
        stack = []
        for c in expression:
            if c == ')':
                cache = []
                while stack[-1] != '(':
                    cache.append(stack.pop())
                stack.pop()
                cur = stack.pop()
                stack.append(all(cache) if cur == '&' else any(cache) if cur == '|' else not cache.pop())
            elif c != ',':
                stack.append(True if c == 't' else False if c == 'f' else c)
        return stack.pop()        ","auto parseBoolExpr(auto expression) {
    stack = []
    for c in expression:
    if c == ')':
    cache = []
    while stack[-1] != '(':
    cache.append(stack.pop())
    stack.pop()
    cur = stack.pop()
    stack.append(all(cache) if cur == '&' else any(cache) if cur == '|' else not cache.pop())
    elif c != ',':
    stack.append(true if c == 't' else false if c == 'f' else c)
    return stack.pop()
}"
1108.py,"def defangIPaddr(self, address: str) -> str:
        return address.replace(""."", ""[.]"")","auto defangIPaddr(auto address) {
    return address.replace(""."", ""[.]"")
}"
1109.py,"def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:
        res = [0] * n
        i = cur = 0
        for j, val in sorted([[i - 1, k] for i, j, k in bookings] + [[j, -k] for i, j, k in bookings]):
            while i < j:
                res[i] = cur
                i += 1
            cur += val
        return res","auto corpFlightBookings(auto bookings, auto n) {
    res = [0] * n
    i = cur = 0
    for j, val in sorted([[i - 1, k] for i, j, k in bookings] + [[j, -k] for i, j, k in bookings]):
    while i < j:
    res[i] = cur
    i += 1
    cur += val
    return res
}"
1111.py,"def maxDepthAfterSplit(self, seq: str) -> List[int]:
        stack = []
        res = [0] * len(seq)
        for i, c in enumerate(seq):
            if c == '(':
                stack.append(i if not stack or stack[-1] < 0 else -i)
            else:
                ind = stack.pop()
                if ind >= 0:
                    res[i] = res[ind] = 1
        return res       ","auto maxDepthAfterSplit(auto seq) {
    stack = []
    res = [0] * len(seq)
    for i, c in enumerate(seq):
    if c == '(':
    stack.append(i if not stack or stack[-1] < 0 else -i)
    else:
    ind = stack.pop()
    if ind >= 0:
    res[i] = res[ind] = 1
    return res
}"
1118.py,"def numberOfDays(self, Y: int, M: int) -> int:
        return 29 + {2: Y % (Y % 25 and 4 or 16) and -1}.get(M, ((M % 2) ^ (M > 7)) + 1)","auto numberOfDays(auto Y, auto M) {
    return 29 + {2: Y % (Y % 25 and 4 or 16) and -1}.get(M, ((M % 2) ^ (M > 7)) + 1)
}"
1119.py,"def removeVowels(self, S: str) -> str:
        return ''.join(filter(lambda x: x not in 'aeiou', S))
        return ''.join(c for c in S if c not in 'aeiou')
        ","auto removeVowels(auto S) {
    return ''.join(filter(lambda x: x not in 'aeiou', S))
    return ''.join(c for c in S if c not in 'aeiou')
}"
1121.py,"def canDivideIntoSubsequences(self, nums: List[int], K: int) -> bool:
        return K * max(collections.Counter(nums).values()) <= len(nums)              ","auto canDivideIntoSubsequences(auto nums, auto K) {
    return K * max(collections.Counter(nums).values()) <= len(nums)
}"
1122.py,"def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:
        return sorted(arr1, key = lambda x: arr2.index(x) if x in arr2 else len(arr2) + x)","auto relativeSortArray(auto arr1, auto arr2) {
    return sorted(arr1, key = lambda x: arr2.index(x) if x in arr2 else len(arr2) + x)
}"
1124.py,"def longestWPI(self, hours: List[int]) -> int:
        res = score = 0
        seen = {}
        for i, h in enumerate(hours):
            score += h > 8
            score -= h < 9
            if score > 0:
                res = i + 1
            seen.setdefault(score, i)
            if score - 1 in seen:
                res = max(res, i - seen[score - 1])
        return res","auto longestWPI(auto hours) {
    res = score = 0
    seen = {}
    for i, h in enumerate(hours):
    score += h > 8
    score -= h < 9
    if score > 0:
    res = i + 1
    seen.setdefault(score, i)
    if score - 1 in seen:
    res = max(res, i - seen[score - 1])
    return res
}"
1125.py,"def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:
        n, m = len(req_skills), len(people)
        key = {v: i for i, v in enumerate(req_skills)}
        dp = {0: []}
        for i, p in enumerate(people):
            his_skill = 0
            for skill in p:
                if skill in key:
                    his_skill |= 1 << key[skill]
            for skill_set, need in list(dp.items()):
                with_him = skill_set | his_skill
                if with_him == skill_set: continue
                if with_him not in dp or len(dp[with_him]) > len(need) + 1:
                    dp[with_him] = need + [i]
        return dp[(1 << n) - 1]","auto smallestSufficientTeam(auto req_skills, auto people) {
    n, m = len(req_skills), len(people)
    key = {v: i for i, v in enumerate(req_skills)}
    dp = {0: []}
    for i, p in enumerate(people):
    his_skill = 0
    for skill in p:
    if skill in key:
    his_skill |= 1 << key[skill]
    for skill_set, need in list(dp.items()):
    with_him = skill_set | his_skill
    if with_him == skill_set: continue
    if with_him not in dp or len(dp[with_him]) > len(need) + 1:
    dp[with_him] = need + [i]
    return dp[(1 << n) - 1]
}"
1128.py,"def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:
        return sum(v * (v - 1) // 2 for v in collections.Counter(tuple(sorted(d)) for d in dominoes).values())","auto numEquivDominoPairs(auto dominoes) {
    return sum(v * (v - 1) // 2 for v in collections.Counter(tuple(sorted(d)) for d in dominoes).values())
}"
1129.py,"def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:
        
        def dfs(i, mod, cnt):
            res[i][mod] = cnt
            for v in edge[i][mod]:
                if cnt < res[v][1 - mod]:
                    dfs(v, 1 - mod, cnt + 1)
                    
        res = [[float('inf'), float('inf')] for _ in range(n)]
        edge = [[[], []] for _ in range(n)]
        for u, v in red_edges:
            edge[u][0].append(v)
        for u, v in blue_edges:
            edge[u][1].append(v)
        dfs(0, 0, 0)
        dfs(0, 1, 0)
        return [x if x != float('inf') else -1 for x in map(min, res)]","auto shortestAlternatingPaths(auto n, auto red_edges, auto blue_edges) {
    
    def dfs(i, mod, cnt):
    res[i][mod] = cnt
    for v in edge[i][mod]:
    if cnt < res[v][1 - mod]:
    dfs(v, 1 - mod, cnt + 1)
    
    res = [[float('inf'), float('inf')] for _ in range(n)]
    edge = [[[], []] for _ in range(n)]
    for u, v in red_edges:
    edge[u][0].append(v)
    for u, v in blue_edges:
    edge[u][1].append(v)
    dfs(0, 0, 0)
    dfs(0, 1, 0)
    return [x if x != float('inf') else -1 for x in map(min, res)]
}"
1130.py,"def mctFromLeafValues(self, A: List[int]) -> int:
        res, n = 0, len(A)
        stack = [float('inf')]
        for a in A:
            while stack[-1] <= a:
                mid = stack.pop()
                res += mid * min(stack[-1], a)
            stack.append(a)
        while len(stack)  >2:
            res += stack.pop() * stack[-1]
        return res","auto mctFromLeafValues(auto A) {
    res, n = 0, len(A)
    stack = [float('inf')]
    for a in A:
    while stack[-1] <= a:
    mid = stack.pop()
    res += mid * min(stack[-1], a)
    stack.append(a)
    while len(stack)  >2:
    res += stack.pop() * stack[-1]
    return res
}"
1131.py,"def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:
        l1, l2 ,l3, l4 = [], [], [], []
        for i in range(len(arr1)):
            l1 += [arr1[i]+arr2[i]+i]
            l2 += [arr1[i]-arr2[i]+i]
            l3 += [-arr1[i]+arr2[i]+i]
            l4 += [-arr1[i]-arr2[i]+i]
        res = []
        res += [max(l1)-min(l1)]
        res += [max(l2) -min(l2)]
        res += [max(l3)-min(l3)]
        res += [max(l4)-min(l4)]
        return max(res)","auto maxAbsValExpr(auto arr1, auto arr2) {
    l1, l2 ,l3, l4 = [], [], [], []
    for i in range(len(arr1)):
    l1 += [arr1[i]+arr2[i]+i]
    l2 += [arr1[i]-arr2[i]+i]
    l3 += [-arr1[i]+arr2[i]+i]
    l4 += [-arr1[i]-arr2[i]+i]
    res = []
    res += [max(l1)-min(l1)]
    res += [max(l2) -min(l2)]
    res += [max(l3)-min(l3)]
    res += [max(l4)-min(l4)]
    return max(res)
}"
1133.py,"def largestUniqueNumber(self, A: List[int]) -> int:
        cnt = collections.Counter(A)
        a = sorted(k for k, v in cnt.items() if v == 1)
        return a[-1] if a else -1
        ","auto largestUniqueNumber(auto A) {
    cnt = collections.Counter(A)
    a = sorted(k for k, v in cnt.items() if v == 1)
    return a[-1] if a else -1
}"
1134.py,"def isArmstrong(self, N: int) -> bool:
        ns = [(int(c), int(c)) for c in str(N)]
        sm = sum(a for a, b in ns)
        while sm < N:
            ns = [(a * b, b) for a, b in ns]
            sm = sum(a for a, b in ns)
        return sm == N
        ","auto isArmstrong(auto N) {
    ns = [(int(c), int(c)) for c in str(N)]
    sm = sum(a for a, b in ns)
    while sm < N:
    ns = [(a * b, b) for a, b in ns]
    sm = sum(a for a, b in ns)
    return sm == N
}"
1135.py,"def minimumCost(self, N: int, connections: List[List[int]]) -> int:
        heap = [(0, 1)]
        visited = [0] * (N + 1)
        res = 0
        graph = [[] for _ in range(N + 1)]
        for a, b, c in connections:
            graph[a].append([b, c])
            graph[b].append([a, c])
        while heap:
            cost, city = heapq.heappop(heap)
            if visited[city]: continue
            visited[city] = 1
            res += cost
            for nCity, nCost in graph[city]:
                if not visited[nCity]:
                    heapq.heappush(heap, (nCost, nCity))
        return res if all(visited[1:]) else -1
            
            ","auto minimumCost(auto N, auto connections) {
    heap = [(0, 1)]
    visited = [0] * (N + 1)
    res = 0
    graph = [[] for _ in range(N + 1)]
    for a, b, c in connections:
    graph[a].append([b, c])
    graph[b].append([a, c])
    while heap:
    cost, city = heapq.heappop(heap)
    if visited[city]: continue
    visited[city] = 1
    res += cost
    for nCity, nCost in graph[city]:
    if not visited[nCity]:
    heapq.heappush(heap, (nCost, nCity))
    return res if all(visited[1:]) else -1
}"
1136.py,"def minimumSemesters(self, N: int, relations: List[List[int]]) -> int:
        """"""
        :type N: int
        :type relations: List[List[int]]
        :rtype: int
        """"""
        if N == 1:
            return 1
        graph = collections.defaultdict(list)
        for p, q in relations:
            graph[q-1].append(p-1)

        def need_semesters(n):
            if dp[n] > 0:   # node was visited
                return dp[n]
            if dp[n] == -1: # node is being visited, there is a cycle!
                return -1
            dp[n] = -1 # start visiting the node
            res = 0
            for p in graph[n]:
                a = need_semesters(p)
                if a == -1:
                    return -1
                res = max(res, a)
            dp[n] = res + 1
            return dp[n]

        dp = [0]*N
        for n in range(N):
            if need_semesters(n) == -1:
                return -1
        return max(dp)","auto minimumSemesters(auto N, auto relations) {
    """"""
    :type N: int
    :type relations: List[List[int]]
    :rtype: int
    """"""
    if N == 1:
    return 1
    graph = collections.defaultdict(list)
    for p, q in relations:
    graph[q-1].append(p-1)
    
    def need_semesters(n):
    if dp[n] > 0:   # node was visited
    return dp[n]
    if dp[n] == -1: # node is being visited, there is a cycle!
    return -1
    dp[n] = -1 # start visiting the node
    res = 0
    for p in graph[n]:
    a = need_semesters(p)
    if a == -1:
    return -1
    res = max(res, a)
    dp[n] = res + 1
    return dp[n]
    
    dp = [0]*N
    for n in range(N):
    if need_semesters(n) == -1:
    return -1
    return max(dp)
}"
1137.py,"def tribonacci(self, n: int) -> int:
        t0, t1, t2 = 0, 1, 1
        for _ in range(n):
            t0, t1, t2 = t1, t2, t0 + t1 + t2
        return t0
        ","auto tribonacci(auto n) {
    t0, t1, t2 = 0, 1, 1
    for _ in range(n):
    t0, t1, t2 = t1, t2, t0 + t1 + t2
    return t0
}"
1138.py,"def alphabetBoardPath(self, target: str) -> str:
        ind = {s: [i // 5, i % 5] for i, s in enumerate(string.ascii_lowercase)}
        x = y = 0
        res = """"
        for c in target:
            xx, yy = ind[c]
            if yy < y:
                res += 'L' * (y - yy)
            if xx > x:
                res += 'D' * (xx - x)
            if xx < x:
                res += 'U' * (x - xx)
            if yy > y:
                res += 'R' * (yy - y)
            res += '!'
            x, y = xx, yy
        return res","auto alphabetBoardPath(auto target) {
    ind = {s: [i // 5, i % 5] for i, s in enumerate(string.ascii_lowercase)}
    x = y = 0
    res = """"
    for c in target:
    xx, yy = ind[c]
    if yy < y:
    res += 'L' * (y - yy)
    if xx > x:
    res += 'D' * (xx - x)
    if xx < x:
    res += 'U' * (x - xx)
    if yy > y:
    res += 'R' * (yy - y)
    res += '!'
    x, y = xx, yy
    return res
}"
1139.py,"def largest1BorderedSquare(self, A: List[List[int]]) -> int:
        m, n = len(A), len(A[0])
        res = 0
        top, left = [a[:] for a in A], [a[:] for a in A]
        for i in range(m):
            for j in range(n):
                if A[i][j]:
                    if i: top[i][j] = top[i - 1][j] + 1
                    if j: left[i][j] = left[i][j - 1] + 1
        for r in range(min(m, n), 0, -1):
            for i in range(m - r + 1):
                for j in range(n - r + 1):
                    if min(top[i + r - 1][j], top[i + r - 1][j + r - 1], left[i]
                           [j + r - 1], left[i + r - 1][j + r - 1]) >= r:
                        return r * r
        return 0","auto largest1BorderedSquare(auto A) {
    m, n = len(A), len(A[0])
    res = 0
    top, left = [a[:] for a in A], [a[:] for a in A]
    for i in range(m):
    for j in range(n):
    if A[i][j]:
    if i: top[i][j] = top[i - 1][j] + 1
    if j: left[i][j] = left[i][j - 1] + 1
    for r in range(min(m, n), 0, -1):
    for i in range(m - r + 1):
    for j in range(n - r + 1):
    if min(top[i + r - 1][j], top[i + r - 1][j + r - 1], left[i]
    [j + r - 1], left[i + r - 1][j + r - 1]) >= r:
    return r * r
    return 0
}"
1140.py,"def stoneGameII(self, A: List[int]) -> int:
        N = len(A)
        for i in range(N - 2, -1, -1):
            A[i] += A[i + 1]
        from functools import lru_cache
        @lru_cache(None)
        def dp(i, m):
            if i + 2 * m >= N: return A[i]
            return A[i] - min(dp(i + x, max(m, x)) for x in range(1, 2 * m + 1))
        return dp(0, 1)","auto stoneGameII(auto A) {
    N = len(A)
    for i in range(N - 2, -1, -1):
    A[i] += A[i + 1]
    from functools import lru_cache
    @lru_cache(nullptr)
    def dp(i, m):
    if i + 2 * m >= N: return A[i]
    return A[i] - min(dp(i + x, max(m, x)) for x in range(1, 2 * m + 1))
    return dp(0, 1)
}"
1143.py,"def longestCommonSubsequence(self, a: str, b: str) -> int:
        m, n = len(a), len(b)
        dp = [[0 for j in range(n + 1)] for i in range(m + 1)]
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                dp[i][j] = dp[i - 1][j - 1] + 1 if a[i - 1] == b[j - 1] else max(dp[i][j - 1], dp[i - 1][j])
        return dp[-1][-1]","auto longestCommonSubsequence(auto a, auto b) {
    m, n = len(a), len(b)
    dp = [[0 for j in range(n + 1)] for i in range(m + 1)]
    for i in range(1, m + 1):
    for j in range(1, n + 1):
    dp[i][j] = dp[i - 1][j - 1] + 1 if a[i - 1] == b[j - 1] else max(dp[i][j - 1], dp[i - 1][j])
    return dp[-1][-1]
}"
1144.py,"def movesToMakeZigzag(self, N: List[int]) -> int:
        moves = [max(0, N[i] - min(N[i-1:i] + N[i+1:i+2]) + 1) for i in range(len(N))]
        return min(sum(moves[::2]), sum(moves[1::2]))","auto movesToMakeZigzag(auto N) {
    moves = [max(0, N[i] - min(N[i-1:i] + N[i+1:i+2]) + 1) for i in range(len(N))]
    return min(sum(moves[::2]), sum(moves[1::2]))
}"
1147.py,"def longestDecomposition(self, S: str) -> int:
        res, l, r = 0, """", """"
        for i, j in zip(S, S[::-1]):
            l, r = l + i, j + r
            if l == r:
                res, l, r = res + 1, """", """"
        return res","auto longestDecomposition(auto S) {
    res, l, r = 0, """", """"
    for i, j in zip(S, S[::-1]):
    l, r = l + i, j + r
    if l == r:
    res, l, r = res + 1, """", """"
    return res
}"
115.py,"def numDistinct(self, s, t):
        chars, index, dp = set(t), collections.defaultdict(list), [0] * len(t)
        for i, c in enumerate(t): index[c] = [i] + index[c]
        for c in s:
            if c in chars:
                for i in index[c]: dp[i] += dp[i - 1] if i > 0 else 1
        return dp[-1]","auto numDistinct(auto s, auto t) {
    chars, index, dp = set(t), collections.defaultdict(list), [0] * len(t)
    for i, c in enumerate(t): index[c] = [i] + index[c]
    for c in s:
    if c in chars:
    for i in index[c]: dp[i] += dp[i - 1] if i > 0 else 1
    return dp[-1]
}"
1150.py,"def isMajorityElement(self, nums: List[int], target: int) -> bool:
        return nums.count(target) > len(nums) // 2
        ","auto isMajorityElement(auto nums, auto target) {
    return nums.count(target) > len(nums) // 2
}"
1151.py,"def minSwaps(self, data: List[int]) -> int:
        l = data.count(1)
        mn = cur = data[:l].count(0)
        for i in range(l, len(data)):
            cur += not data[i] 
            cur -= not data[i - l]
            mn = min(mn, cur)
        return mn
        ","auto minSwaps(auto data) {
    l = data.count(1)
    mn = cur = data[:l].count(0)
    for i in range(l, len(data)):
    cur += not data[i]
    cur -= not data[i - l]
    mn = min(mn, cur)
    return mn
}"
1152.py,"def mostVisitedPattern(self, username: List[str], timestamp: List[int], website: List[str]) -> List[str]:
        dp = collections.defaultdict(list)
        count = collections.Counter()
        for t, u, w in sorted(zip(timestamp, username, website)):
            dp[u].append(w)
        for u in dp:
            count += collections.Counter(set(seq for seq in itertools.combinations(dp[u], 3)))
        target = max(count.values())
        return min(list(k) for k in count if count[k] == target)","auto mostVisitedPattern(auto username, auto timestamp, auto website) {
    dp = collections.defaultdict(list)
    count = collections.Counter()
    for t, u, w in sorted(zip(timestamp, username, website)):
    dp[u].append(w)
    for u in dp:
    count += collections.Counter(set(seq for seq in itertools.combinations(dp[u], 3)))
    target = max(count.values())
    return min(list(k) for k in count if count[k] == target)
}"
1153.py,"def canConvert(self, s1: str, s2: str) -> bool:
        if s1 == s2: return True
        dp = {}
        for i, j in zip(s1, s2):
            if dp.setdefault(i, j) != j:
                return False
        return len(set(s2)) < 26","auto canConvert(auto s1, auto s2) {
    if s1 == s2: return true
    dp = {}
    for i, j in zip(s1, s2):
    if dp.setdefault(i, j) != j:
    return false
    return len(set(s2)) < 26
}"
1154.py,"def dayOfYear(self, date: str) -> int:
        cnt = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        y, m, d = map(int, date.split('-'))
        days = sum(cnt[:m - 1]) + d
        if m > 2:
            if y % 400 == 0: days += 1
            if y % 100 == 0: return days
            if y % 4 == 0: days += 1
        return days","auto dayOfYear(auto date) {
    cnt = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    y, m, d = map(int, date.split('-'))
    days = sum(cnt[:m - 1]) + d
    if m > 2:
    if y % 400 == 0: days += 1
    if y % 100 == 0: return days
    if y % 4 == 0: days += 1
    return days
}"
1155.py,"def numRollsToTarget(self, d: int, f: int, target: int) -> int:
        mod = 10 ** 9 + 7
        dp = [[0 for j in range(target + 1)] for i in range(d + 1)]
        dp[0][0] = 1
        for i in range(d):
            for ff in range(1, f + 1):
                for sm in range(target):
                    if sm + ff <= target:
                        dp[i + 1][sm + ff] += dp[i][sm]
                        dp[i + 1][sm + ff] %= mod
        return dp[d][target]","auto numRollsToTarget(auto d, auto f, auto target) {
    mod = 10 ** 9 + 7
    dp = [[0 for j in range(target + 1)] for i in range(d + 1)]
    dp[0][0] = 1
    for i in range(d):
    for ff in range(1, f + 1):
    for sm in range(target):
    if sm + ff <= target:
    dp[i + 1][sm + ff] += dp[i][sm]
    dp[i + 1][sm + ff] %= mod
    return dp[d][target]
}"
1156.py,"def maxRepOpt1(self, S: str) -> int:
        A = [[c, len(list(g))] for c, g in itertools.groupby(S)]
        count = collections.Counter(S)
        res = max(min(k + 1, count[c]) for c, k in A)
        for i in range(1, len(A) - 1):
            if A[i - 1][0] == A[i + 1][0] and A[i][1] == 1:
                res = max(res, min(A[i - 1][1] + A[i + 1][1] + 1, count[A[i + 1][0]]))
        return res","auto maxRepOpt1(auto S) {
    A = [[c, len(list(g))] for c, g in itertools.groupby(S)]
    count = collections.Counter(S)
    res = max(min(k + 1, count[c]) for c, k in A)
    for i in range(1, len(A) - 1):
    if A[i - 1][0] == A[i + 1][0] and A[i][1] == 1:
    res = max(res, min(A[i - 1][1] + A[i + 1][1] + 1, count[A[i + 1][0]]))
    return res
}"
1162.py,"def maxDistance(self, grid: List[List[int]]) -> int:
        n = len(grid)
        q = [[i, j] for i in range(n) for j in range(n) if grid[i][j]]
        d = -1
        while q and len(q) != n ** 2:
            Q = []
            for i, j in q:
                for x, y in (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1):
                    if 0 <= x < n > y >= 0 and not grid[x][y]:
                        grid[x][y] = 1
                        Q.append([x, y])
            q = Q
            d += 1
        return d
            
            ","auto maxDistance(auto grid) {
    n = len(grid)
    q = [[i, j] for i in range(n) for j in range(n) if grid[i][j]]
    d = -1
    while q and len(q) != n ** 2:
    Q = []
    for i, j in q:
    for x, y in (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1):
    if 0 <= x < n > y >= 0 and not grid[x][y]:
    grid[x][y] = 1
    Q.append([x, y])
    q = Q
    d += 1
    return d
}"
1163.py,"def lastSubstring(self, s: str) -> str:
        result = """"
        for i in range(len(s)):
            result = max(result, s[i:])
        return result
        ","auto lastSubstring(auto s) {
    result = """"
    for i in range(len(s)):
    result = max(result, s[i:])
    return result
}"
1165.py,"def calculateTime(self, k: str, word: str) -> int:
        return sum(abs(k.index(a) - k.index(b)) for a, b in zip(k[0] + word, word))","auto calculateTime(auto k, auto word) {
    return sum(abs(k.index(a) - k.index(b)) for a, b in zip(k[0] + word, word))
}"
1167.py,"def connectSticks(self, sticks: List[int]) -> int:
        heapq.heapify(sticks)
        res = 0
        while len(sticks) != 1:
            new = heapq.heappop(sticks) + heapq.heappop(sticks)
            res += new
            heapq.heappush(sticks, new)
        return res
        ","auto connectSticks(auto sticks) {
    heapq.heapify(sticks)
    res = 0
    while len(sticks) != 1:
    new = heapq.heappop(sticks) + heapq.heappop(sticks)
    res += new
    heapq.heappush(sticks, new)
    return res
}"
1168.py,"def minCostToSupplyWater(self, n: int, wells, pipes) -> int:
        q = sorted([[w, u, v] for u, v, w in pipes] + [[w, 0, i+1] for i, w in enumerate(wells)])
        uf = [i for i in range(n+1)]
        res = count = 0
        
        def find(x):
            if (x != uf[x]):
                uf[x] = find(uf[x])
            return uf[x]

        def union(x, y):
            uf[x] = y
            
        for w, u, v in q:
            rA, rB = find(u), find(v)
            if rA == rB:
                continue
            union(rA, rB)
            res += w
            count += 1
            if count == n:
                return res
        return res ","auto minCostToSupplyWater(auto n, auto wells, auto pipes) {
    q = sorted([[w, u, v] for u, v, w in pipes] + [[w, 0, i+1] for i, w in enumerate(wells)])
    uf = [i for i in range(n+1)]
    res = count = 0
    
    def find(x):
    if (x != uf[x]):
    uf[x] = find(uf[x])
    return uf[x]
    
    def union(x, y):
    uf[x] = y
    
    for w, u, v in q:
    rA, rB = find(u), find(v)
    if rA == rB:
    continue
    union(rA, rB)
    res += w
    count += 1
    if count == n:
    return res
    return res
}"
1169.py,"def invalidTransactions(self, transactions: List[str]) -> List[str]:
        last = collections.defaultdict(list)
        ret = set()
        for n, t, a, c in sorted([t.split(',') for t in transactions], key = lambda x: int(x[1])):
            if int(a) > 1000:
                ret.add(','.join([n, t, a, c]))
            if n in last:
                for tt, aa, cc in last[n][::-1]:
                    if int(t) - int(tt) > 60:
                        break
                    if cc != c:
                        ret.add(','.join([n, tt, aa, cc]))
                        ret.add(','.join([n, t, a, c]))
            last[n].append([t, a, c])
        return list(ret)
        ","auto invalidTransactions(auto transactions) {
    last = collections.defaultdict(list)
    ret = set()
    for n, t, a, c in sorted([t.split(',') for t in transactions], key = lambda x: int(x[1])):
    if int(a) > 1000:
    ret.add(','.join([n, t, a, c]))
    if n in last:
    for tt, aa, cc in last[n][::-1]:
    if int(t) - int(tt) > 60:
    break
    if cc != c:
    ret.add(','.join([n, tt, aa, cc]))
    ret.add(','.join([n, t, a, c]))
    last[n].append([t, a, c])
    return list(ret)
}"
1170.py,"def numSmallerByFrequency(self, queries: List[str], words: List[str]) -> List[int]:
        f = sorted(w.count(min(w)) for w in words)
        return [len(f) - bisect.bisect(f, q.count(min(q))) for q in queries]
        ","auto numSmallerByFrequency(auto queries, auto words) {
    f = sorted(w.count(min(w)) for w in words)
    return [len(f) - bisect.bisect(f, q.count(min(q))) for q in queries]
}"
1175.py,"def numPrimeArrangements(self, n: int) -> int:
        primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
        cnt = bisect.bisect(primes, n)
        return math.factorial(cnt) * math.factorial(n - cnt) % (10 ** 9 + 7)
    ","auto numPrimeArrangements(auto n) {
    primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
    cnt = bisect.bisect(primes, n)
    return math.factorial(cnt) * math.factorial(n - cnt) % (10 ** 9 + 7)
}"
1176.py,"def dietPlanPerformance(self, calories: List[int], k: int, lower: int, upper: int) -> int:
        sm = sum(calories[:k])
        points = (sm > upper) - (sm < lower)
        for i in range(k, len(calories)):
            sm += calories[i] - calories[i - k]
            points += (sm > upper) - (sm < lower)
        return points
            ","auto dietPlanPerformance(auto calories, auto k, auto lower, auto upper) {
    sm = sum(calories[:k])
    points = (sm > upper) - (sm < lower)
    for i in range(k, len(calories)):
    sm += calories[i] - calories[i - k]
    points += (sm > upper) - (sm < lower)
    return points
}"
1177.py,"def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:
        cnts = [{}]
        for i, c in enumerate(s):
            cnts.append(dict(cnts[-1]))
            cnts[-1][c] = cnts[-1].get(c, 0) + 1
        res = []
        for i, j, k in queries:
            res.append(sum((v - cnts[i].get(k, 0)) % 2 for k, v in cnts[j + 1].items()) - k * 2 <= 1)
        return res
        
        ","auto canMakePaliQueries(auto s, auto queries) {
    cnts = [{}]
    for i, c in enumerate(s):
    cnts.append(dict(cnts[-1]))
    cnts[-1][c] = cnts[-1].get(c, 0) + 1
    res = []
    for i, j, k in queries:
    res.append(sum((v - cnts[i].get(k, 0)) % 2 for k, v in cnts[j + 1].items()) - k * 2 <= 1)
    return res
}"
118.py,"def generate(self, numRows: int) -> List[List[int]]:
        res = numRows and [[1]] or []
        for _ in range(numRows-1):
            res.append([1] + [a + b for a, b in zip(res[-1], res[-1][1:])] + [1])
        return res","auto generate(auto numRows) {
    res = numRows and [[1]] or []
    for _ in range(numRows-1):
    res.append([1] + [a + b for a, b in zip(res[-1], res[-1][1:])] + [1])
    return res
}"
1180.py,"def countLetters(self, S: str) -> int:
        cnt = collections.Counter()
        i = res = 0
        for j, c in enumerate(S):
            cnt[c] += 1
            while len(cnt) > 1:
                cnt[S[i]] -= 1
                if not cnt[S[i]]:
                    cnt.pop(S[i])
                i += 1
            res += j - i + 1
        return res
                
            ","auto countLetters(auto S) {
    cnt = collections.Counter()
    i = res = 0
    for j, c in enumerate(S):
    cnt[c] += 1
    while len(cnt) > 1:
    cnt[S[i]] -= 1
    if not cnt[S[i]]:
    cnt.pop(S[i])
    i += 1
    res += j - i + 1
    return res
}"
1181.py,"def beforeAndAfterPuzzles(self, phrases: List[str]) -> List[str]:
        res = []
        for i in range(len(phrases)):
            for j in range(i + 1, len(phrases)):
                w1 = phrases[i].split()[-1]
                w2 = phrases[j].split()[0]
                if w1 == w2:
                    r = phrases[i] + ' ' + ' '.join(phrases[j].split()[1:])
                    res.append(r.rstrip())
                w1 = phrases[j].split()[-1]
                w2 = phrases[i].split()[0]
                if w1 == w2:
                    r = phrases[j] + ' ' + ' '.join(phrases[i].split()[1:])
                    res.append(r.rstrip())
        return sorted(set(res))        ","auto beforeAndAfterPuzzles(auto phrases) {
    res = []
    for i in range(len(phrases)):
    for j in range(i + 1, len(phrases)):
    w1 = phrases[i].split()[-1]
    w2 = phrases[j].split()[0]
    if w1 == w2:
    r = phrases[i] + ' ' + ' '.join(phrases[j].split()[1:])
    res.append(r.rstrip())
    w1 = phrases[j].split()[-1]
    w2 = phrases[i].split()[0]
    if w1 == w2:
    r = phrases[j] + ' ' + ' '.join(phrases[i].split()[1:])
    res.append(r.rstrip())
    return sorted(set(res))
}"
1182.py,"def shortestDistanceColor(self, colors: List[int], queries: List[List[int]]) -> List[int]:
        l1 = l2 = l3 = -1
        left = [[float('inf') for _ in range(3)] for __ in range(len(colors))]
        res = []
        for i, c in enumerate(colors):
            if c == 1:
                l1 = i
            elif c == 2:
                l2 = i
            else:
                l3 = i
            if l1 != -1:
                left[i][0] = i - l1
            if l2 != -1:
                left[i][1] = i - l2
            if l3 != -1:
                left[i][2] = i - l3
                
        l1 = l2 = l3 = -1
        right = [[float('inf') for _ in range(3)] for __ in range(len(colors))]
        for i in range(len(colors) - 1, -1, -1):
            c = colors[i]
            if c == 1:
                l1 = i
            elif c == 2:
                l2 = i
            else:
                l3 = i
            if l1 != -1:
                right[i][0] = l1  - i
            if l2 != -1:
                right[i][1] = l2 - i
            if l3 != -1:
                right[i][2] = l3 - i
        for i, c in queries:
            res.append(min(left[i][c - 1], right[i][c - 1]))
        return [c if c != float('inf') else -1 for c in res]
            
            
        
            
        ","auto shortestDistanceColor(auto colors, auto queries) {
    l1 = l2 = l3 = -1
    left = [[float('inf') for _ in range(3)] for __ in range(len(colors))]
    res = []
    for i, c in enumerate(colors):
    if c == 1:
    l1 = i
    elif c == 2:
    l2 = i
    else:
    l3 = i
    if l1 != -1:
    left[i][0] = i - l1
    if l2 != -1:
    left[i][1] = i - l2
    if l3 != -1:
    left[i][2] = i - l3
    
    l1 = l2 = l3 = -1
    right = [[float('inf') for _ in range(3)] for __ in range(len(colors))]
    for i in range(len(colors) - 1, -1, -1):
    c = colors[i]
    if c == 1:
    l1 = i
    elif c == 2:
    l2 = i
    else:
    l3 = i
    if l1 != -1:
    right[i][0] = l1  - i
    if l2 != -1:
    right[i][1] = l2 - i
    if l3 != -1:
    right[i][2] = l3 - i
    for i, c in queries:
    res.append(min(left[i][c - 1], right[i][c - 1]))
    return [c if c != float('inf') else -1 for c in res]
}"
1184.py,"def distanceBetweenBusStops(self, d: List[int], i: int, j: int) -> int:
        return min(sum(d[min(i, j):max(i, j)]), sum(d[:min(i, j)] + d[max(i, j):]))","auto distanceBetweenBusStops(auto d, auto i, auto j) {
    return min(sum(d[min(i, j):max(i, j)]), sum(d[:min(i, j)] + d[max(i, j):]))
}"
1186.py,"def maximumSum(self, arr: List[int]) -> int:
        def cumSum(it):
            sm = mn = 0
            sums = [0] * len(arr)
            for i, num in it:
                sm += num
                sums[i] = sm - mn
                mn = min(mn, sm)
            return sums
        
        lSum = cumSum(enumerate(arr))
        rSum = cumSum(reversed(list(enumerate(arr))))
        res = -float('inf')
        for i, num in enumerate(arr):
            if num >= 0:
                cur = lSum[i] + rSum[i] - num
            else:
                cur = lSum[i] + rSum[i] - 2 * num
            res = max(res, cur)
        return res if any(c >= 0 for c in arr) else max(arr)","auto maximumSum(auto arr) {
    def cumSum(it):
    sm = mn = 0
    sums = [0] * len(arr)
    for i, num in it:
    sm += num
    sums[i] = sm - mn
    mn = min(mn, sm)
    return sums
    
    lSum = cumSum(enumerate(arr))
    rSum = cumSum(reversed(list(enumerate(arr))))
    res = -float('inf')
    for i, num in enumerate(arr):
    if num >= 0:
    cur = lSum[i] + rSum[i] - num
    else:
    cur = lSum[i] + rSum[i] - 2 * num
    res = max(res, cur)
    return res if any(c >= 0 for c in arr) else max(arr)
}"
1187.py,"def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:
        dp = {-1:0}
        arr2.sort()
        for i in arr1:
            tmp = collections.defaultdict(lambda: float('inf'))
            for key in dp:
                if i > key:
                    tmp[i] = min(tmp[i],dp[key])
                loc = bisect.bisect_right(arr2,key)
                if loc < len(arr2):
                    tmp[arr2[loc]] = min(tmp[arr2[loc]],dp[key]+1)
            dp = tmp
        if dp:
            return min(dp.values())
        return -1","auto makeArrayIncreasing(auto arr1, auto arr2) {
    dp = {-1:0}
    arr2.sort()
    for i in arr1:
    tmp = collections.defaultdict(lambda: float('inf'))
    for key in dp:
    if i > key:
    tmp[i] = min(tmp[i],dp[key])
    loc = bisect.bisect_right(arr2,key)
    if loc < len(arr2):
    tmp[arr2[loc]] = min(tmp[arr2[loc]],dp[key]+1)
    dp = tmp
    if dp:
    return min(dp.values())
    return -1
}"
1189.py,"def maxNumberOfBalloons(self, t: str) -> int:
          return min(t.count(c) // 'balloon'.count(c) for c in 'balon')","auto maxNumberOfBalloons(auto t) {
    return min(t.count(c) // 'balloon'.count(c) for c in 'balon')
}"
119.py,"def getRow(self, rowIndex: int, row = [1]) -> List[int]:
        return self.getRow(rowIndex - 1, [a + b for a, b in zip([0] + row, row + [0])]) if rowIndex else row","auto getRow(auto rowIndex, auto row = [1]) {
    return self.getRow(rowIndex - 1, [a + b for a, b in zip([0] + row, row + [0])]) if rowIndex else row
}"
1190.py,"def reverseParentheses(self, s: str) -> str:
        stack = ['']
        for c in s:
            if c == '(':
                stack.append('')
            elif c == ')':
                add = stack.pop()[::-1]
                stack[-1] += add
            else:
                stack[-1] += c
        return stack.pop()","auto reverseParentheses(auto s) {
    stack = ['']
    for c in s:
    if c == '(':
    stack.append('')
    elif c == ')':
    add = stack.pop()[::-1]
    stack[-1] += add
    else:
    stack[-1] += c
    return stack.pop()
}"
1191.py,"def kConcatenationMaxSum(self, arr: List[int], k: int, mod = 10 ** 9 + 7) -> int:
        def Kadane(arr, res = 0, cur = 0):
            for num in arr:
                cur = max(num, num + cur)
                res = max(res, cur)
            return res
        return ((k - 2) * max(sum(arr), 0) + Kadane(arr * 2) ) % mod if k > 1 else Kadane(arr) % mod","auto kConcatenationMaxSum(auto arr, auto k, auto mod = 10 ** 9 + 7) {
    def Kadane(arr, res = 0, cur = 0):
    for num in arr:
    cur = max(num, num + cur)
    res = max(res, cur)
    return res
    return ((k - 2) * max(sum(arr), 0) + Kadane(arr * 2) ) % mod if k > 1 else Kadane(arr) % mod
}"
1196.py,"def maxNumberOfApples(self, arr: List[int]) -> int:
        return bisect.bisect(list(itertools.accumulate(sorted(arr))), 5000)","auto maxNumberOfApples(auto arr) {
    return bisect.bisect(list(itertools.accumulate(sorted(arr))), 5000)
}"
1199.py,"def minBuildTime(self, A: List[int], split: int) -> int:
        heapq.heapify(A)
        while len(A) > 1:
            x, y = heapq.heappop(A), heapq.heappop(A)
            heapq.heappush(A, y + split)
        return heapq.heappop(A)","auto minBuildTime(auto A, auto split) {
    heapq.heapify(A)
    while len(A) > 1:
    x, y = heapq.heappop(A), heapq.heappop(A)
    heapq.heappush(A, y + split)
    return heapq.heappop(A)
}"
12.py,"def intToRoman(self, num):
        s = ""M"" * (num // 1000)
        s += ""CM"" if num % 1000 >= 900 else ""D"" *((num % 1000) // 500)
        s += ""CD"" if num % 500 >= 400 and s[-2:] != ""CM"" else ""C"" * ((num % 500) // 100)  if num % 500 < 400 else """"
        s += ""XC"" if num % 100 >= 90 else ""L"" * ((num % 100) // 50)
        s += ""XL"" if num % 50 >= 40 and s[-2:] != ""XC"" else ""X"" * ((num % 50) // 10)  if num % 50 < 40 else """"
        s += ""IX"" if num % 10 >= 9 else ""V"" * ((num % 10) // 5)
        s += ""IV"" if num % 5 >= 4 and s[-2:] != ""IX"" else ""I"" * ((num % 5) // 1) if num % 5 < 4 else """"
        return s","auto intToRoman(auto num) {
    s = ""M"" * (num // 1000)
    s += ""CM"" if num % 1000 >= 900 else ""D"" *((num % 1000) // 500)
    s += ""CD"" if num % 500 >= 400 and s[-2:] != ""CM"" else ""C"" * ((num % 500) // 100)  if num % 500 < 400 else """"
    s += ""XC"" if num % 100 >= 90 else ""L"" * ((num % 100) // 50)
    s += ""XL"" if num % 50 >= 40 and s[-2:] != ""XC"" else ""X"" * ((num % 50) // 10)  if num % 50 < 40 else """"
    s += ""IX"" if num % 10 >= 9 else ""V"" * ((num % 10) // 5)
    s += ""IV"" if num % 5 >= 4 and s[-2:] != ""IX"" else ""I"" * ((num % 5) // 1) if num % 5 < 4 else """"
    return s
}"
120.py,"def minimumTotal(self, triangle):
        """"""
        :type triangle: List[List[int]]
        :rtype: int
        """"""
        prev = None
        for tri in triangle:
            if prev:
                for i, num in enumerate(tri):
                    if i >= len(prev): tri[i] += prev[i - 1]
                    elif i == 0: tri[i] += prev[0]
                    else: tri[i] += min(prev[i - 1], prev[i])
            prev = tri
        return min(triangle[-1])","auto minimumTotal(auto triangle) {
    """"""
    :type triangle: List[List[int]]
    :rtype: int
    """"""
    prev = None
    for tri in triangle:
    if prev:
    for i, num in enumerate(tri):
    if i >= len(prev): tri[i] += prev[i - 1]
    elif i == 0: tri[i] += prev[0]
    else: tri[i] += min(prev[i - 1], prev[i])
    prev = tri
    return min(triangle[-1])
}"
1200.py,"def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:
        arr.sort()
        mn = min(b - a for a, b in zip(arr, arr[1:]))
        return [[a, b] for a, b in zip(arr, arr[1:]) if b - a == mn]        ","auto minimumAbsDifference(auto arr) {
    arr.sort()
    mn = min(b - a for a, b in zip(arr, arr[1:]))
    return [[a, b] for a, b in zip(arr, arr[1:]) if b - a == mn]
}"
1201.py,"def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:
        def gcd(a, b):
            return a if not b else gcd(b, a % b)
        ab, ac, bc = a * b // gcd(a, b), a * c // gcd(a, c), b * c // gcd(b, c)
        abc = ab * c // gcd(ab, c)
        l, r = 1, 2 * 10 ** 9
        while l < r:
            mid = (l + r) // 2
            if mid // a + mid // b + mid // c - mid // ab - mid // ac - mid // bc + mid // abc < n:
                l = mid + 1
            else:
                r = mid
        return l
        ","auto nthUglyNumber(auto n, auto a, auto b, auto c) {
    def gcd(a, b):
    return a if not b else gcd(b, a % b)
    ab, ac, bc = a * b // gcd(a, b), a * c // gcd(a, c), b * c // gcd(b, c)
    abc = ab * c // gcd(ab, c)
    l, r = 1, 2 * 10 ** 9
    while l < r:
    mid = (l + r) // 2
    if mid // a + mid // b + mid // c - mid // ab - mid // ac - mid // bc + mid // abc < n:
    l = mid + 1
    else:
    r = mid
    return l
}"
1202.py,"def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:
        class UF:
            def __init__(self, n): self.p = list(range(n))
            def union(self, x, y): self.p[self.find(x)] = self.find(y)
            def find(self, x):
                if x != self.p[x]: self.p[x] = self.find(self.p[x])
                return self.p[x]
        uf, res, m = UF(len(s)), [], collections.defaultdict(list)
        for x,y in pairs: 
            uf.union(x,y)
        for i in range(len(s)): 
            m[uf.find(i)].append(s[i])
        for comp_id in m.keys(): 
            m[comp_id].sort(reverse=True)
        for i in range(len(s)): 
            res.append(m[uf.find(i)].pop())
        return ''.join(res)
        
            ","auto smallestStringWithSwaps(auto s, auto pairs) {
    class UF:
    def __init__(self, n): self.p = list(range(n))
    def union(self, x, y): self.p[self.find(x)] = self.find(y)
    def find(self, x):
    if x != self.p[x]: self.p[x] = self.find(self.p[x])
    return self.p[x]
    uf, res, m = UF(len(s)), [], collections.defaultdict(list)
    for x,y in pairs:
    uf.union(x,y)
    for i in range(len(s)):
    m[uf.find(i)].append(s[i])
    for comp_id in m.keys():
    m[comp_id].sort(reverse=true)
    for i in range(len(s)):
    res.append(m[uf.find(i)].pop())
    return ''.join(res)
}"
1203.py,"def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:
        def topo_sort(points, pre, suc):
            order = []
            sources = [p for p in points if not pre[p]]
            while sources:
                s = sources.pop()
                order.append(s)
                for u in suc[s]:
                    pre[u].remove(s)
                    if not pre[u]:
                        sources.append(u)
            return order if len(order) == len(points) else []
        
        # find the group of each item
        group2item = collections.defaultdict(set)
        for i in range(n):
            if group[i] == -1:
                group[i] = m
                m += 1
            group2item[group[i]].add(i)
        # find the relationships between the groups and each items in the same group
        t_pre, t_suc = collections.defaultdict(set), collections.defaultdict(set)
        g_pre, g_suc = collections.defaultdict(set), collections.defaultdict(set)
        for i in range(n):
            for j in beforeItems[i]:
                if group[i] == group[j]:
                    t_pre[i].add(j)
                    t_suc[j].add(i)
                else:
                    g_pre[group[i]].add(group[j])
                    g_suc[group[j]].add(group[i])
        # topological sort the groups
        groups_order = topo_sort([i for i in group2item], g_pre, g_suc)
        # topological sort the items in each group
        t_order = []
        for i in groups_order:
            items = group2item[i]
            i_order = topo_sort(items, t_pre, t_suc)
            if len(i_order) != len(items):
                return []
            t_order += i_order
        return t_order if len(t_order) == n else []","auto sortItems(auto n, auto m, auto group, auto beforeItems) {
    def topo_sort(points, pre, suc):
    order = []
    sources = [p for p in points if not pre[p]]
    while sources:
    s = sources.pop()
    order.append(s)
    for u in suc[s]:
    pre[u].remove(s)
    if not pre[u]:
    sources.append(u)
    return order if len(order) == len(points) else []
    
    # find the group of each item
    group2item = collections.defaultdict(set)
    for i in range(n):
    if group[i] == -1:
    group[i] = m
    m += 1
    group2item[group[i]].add(i)
    # find the relationships between the groups and each items in the same group
    t_pre, t_suc = collections.defaultdict(set), collections.defaultdict(set)
    g_pre, g_suc = collections.defaultdict(set), collections.defaultdict(set)
    for i in range(n):
    for j in beforeItems[i]:
    if group[i] == group[j]:
    t_pre[i].add(j)
    t_suc[j].add(i)
    else:
    g_pre[group[i]].add(group[j])
    g_suc[group[j]].add(group[i])
    # topological sort the groups
    groups_order = topo_sort([i for i in group2item], g_pre, g_suc)
    # topological sort the items in each group
    t_order = []
    for i in groups_order:
    items = group2item[i]
    i_order = topo_sort(items, t_pre, t_suc)
    if len(i_order) != len(items):
    return []
    t_order += i_order
    return t_order if len(t_order) == n else []
}"
1208.py,"def equalSubstring(self, s: str, t: str, mx: int) -> int:
        i = 0
        for j in range(len(s)):
            mx -= abs(ord(s[j]) - ord(t[j]))
            if mx < 0:
                mx += abs(ord(s[i]) - ord(t[i]))
                i += 1
        return j - i + 1","auto equalSubstring(auto s, auto t, auto mx) {
    i = 0
    for j in range(len(s)):
    mx -= abs(ord(s[j]) - ord(t[j]))
    if mx < 0:
    mx += abs(ord(s[i]) - ord(t[i]))
    i += 1
    return j - i + 1
}"
1209.py,"def removeDuplicates(self, s: str, k: int) -> str:
        stack = []
        for i, c in enumerate(s):
            if not stack or stack[-1][0] != c:
                stack.append([c, 1])
            else:
                stack[-1][1] += 1
            if stack[-1][1] == k:
                stack.pop()
        return ''.join(k * v for k, v in stack) 
                ","auto removeDuplicates(auto s, auto k) {
    stack = []
    for i, c in enumerate(s):
    if not stack or stack[-1][0] != c:
    stack.append([c, 1])
    else:
    stack[-1][1] += 1
    if stack[-1][1] == k:
    stack.pop()
    return ''.join(k * v for k, v in stack)
}"
121.py,"def maxProfit(self, prices):
        """"""
        :type prices: List[int]
        :rtype: int
        """"""
        diff_list=[0,0]
        for i in range (1, len(prices)):
            if prices[i]-prices[i-1]+diff_list[1]>=0:
                diff_list[1]=prices[i]-prices[i-1]+diff_list[1]
                diff_list[0]=max(diff_list[0],diff_list[1])
            else:
                diff_list[1]=0
        return diff_list[0]","auto maxProfit(auto prices) {
    """"""
    :type prices: List[int]
    :rtype: int
    """"""
    diff_list=[0,0]
    for i in range (1, len(prices)):
    if prices[i]-prices[i-1]+diff_list[1]>=0:
    diff_list[1]=prices[i]-prices[i-1]+diff_list[1]
    diff_list[0]=max(diff_list[0],diff_list[1])
    else:
    diff_list[1]=0
    return diff_list[0]
}"
1210.py,"def minimumMoves(self, grid: List[List[int]]) -> int:
        q, move, n, seen = {(0, 1, 0)}, 0, len(grid), set()
        while q:
            new = set()
            for i, j, hv in q:
                if i == j == n - 1 and not hv:
                    return move
                if hv and i < n - 1 and not grid[i + 1][j]:
                    if (i + 1, j, 1) not in seen:
                        new.add((i + 1, j, 1))
                if hv and j + 1 < n and grid[i][j + 1] == grid[i - 1][j + 1] == 0:
                    if (i, j + 1, 1) not in seen:
                        new.add((i, j + 1, 1))
                    if (i - 1, j + 1, 0) not in seen:
                        new.add((i - 1, j + 1, 0))
                if not hv and j + 1 < n and not grid[i][j + 1]:
                    if (i, j + 1, 0) not in seen:
                        new.add((i, j + 1, 0))
                if not hv and i + 1 < n and grid[i + 1][j] == grid[i + 1][j - 1] == 0:
                    if (i + 1, j, 0) not in seen:
                        new.add((i + 1, j, 0))
                    if (i + 1, j - 1, 1) not in seen:
                        new.add((i + 1, j - 1, 1))
            q = new
            seen |= new
            move += 1
        return -1","auto minimumMoves(auto grid) {
    q, move, n, seen = {(0, 1, 0)}, 0, len(grid), set()
    while q:
    new = set()
    for i, j, hv in q:
    if i == j == n - 1 and not hv:
    return move
    if hv and i < n - 1 and not grid[i + 1][j]:
    if (i + 1, j, 1) not in seen:
    new.add((i + 1, j, 1))
    if hv and j + 1 < n and grid[i][j + 1] == grid[i - 1][j + 1] == 0:
    if (i, j + 1, 1) not in seen:
    new.add((i, j + 1, 1))
    if (i - 1, j + 1, 0) not in seen:
    new.add((i - 1, j + 1, 0))
    if not hv and j + 1 < n and not grid[i][j + 1]:
    if (i, j + 1, 0) not in seen:
    new.add((i, j + 1, 0))
    if not hv and i + 1 < n and grid[i + 1][j] == grid[i + 1][j - 1] == 0:
    if (i + 1, j, 0) not in seen:
    new.add((i + 1, j, 0))
    if (i + 1, j - 1, 1) not in seen:
    new.add((i + 1, j - 1, 1))
    q = new
    seen |= new
    move += 1
    return -1
}"
1213.py,"def arraysIntersection(self, arr1: List[int], arr2: List[int], arr3: List[int]) -> List[int]:
        return sorted(set(arr1) & set(arr2) & set(arr3))","auto arraysIntersection(auto arr1, auto arr2, auto arr3) {
    return sorted(set(arr1) & set(arr2) & set(arr3))
}"
1215.py,"def countSteppingNumbers(self, low: int, high: int) -> List[int]:
        def dfs(n):
            if n > high: 
                return 
            if n >= low:
                q.add(n)
            d = n % 10
            if d == 0:
                dfs(n * 10 + 1)
            elif d == 9:
                dfs(n * 10 + 8)
            else:
                dfs(n * 10 + d + 1) 
                dfs(n * 10 + d - 1)
        q = set()
        for i in range(10):
            dfs(i)
        return sorted(q)","auto countSteppingNumbers(auto low, auto high) {
    def dfs(n):
    if n > high:
    return
    if n >= low:
    q.add(n)
    d = n % 10
    if d == 0:
    dfs(n * 10 + 1)
    elif d == 9:
    dfs(n * 10 + 8)
    else:
    dfs(n * 10 + d + 1)
    dfs(n * 10 + d - 1)
    q = set()
    for i in range(10):
    dfs(i)
    return sorted(q)
}"
1216.py,"def isValidPalindrome(self, s: str, k: int) -> bool:
        n = len(s)
        dp = [[0] * (n + 1) for _ in range(n + 1)] 
        for i in range(n + 1): 
            for j in range(n + 1): 
                if not i or not j: 
                    dp[i][j] = i or j 
                elif s[i - 1] == s[n - j]: 
                    dp[i][j] = dp[i - 1][j - 1] 
                else: 
                    dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1])
        return dp[n][n] <= k * 2","auto isValidPalindrome(auto s, auto k) {
    n = len(s)
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    for i in range(n + 1):
    for j in range(n + 1):
    if not i or not j:
    dp[i][j] = i or j
    elif s[i - 1] == s[n - j]:
    dp[i][j] = dp[i - 1][j - 1]
    else:
    dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1])
    return dp[n][n] <= k * 2
}"
1217.py,"def minCostToMoveChips(self, chips: List[int]) -> int:
        return min(sum((c1 - c2) % 2 for c2 in chips) for c1 in chips)","auto minCostToMoveChips(auto chips) {
    return min(sum((c1 - c2) % 2 for c2 in chips) for c1 in chips)
}"
1218.py,"def longestSubsequence(self, arr: List[int], d: int) -> int:
        dp = collections.Counter()
        for a in arr:
            dp[a] = max(dp[a], dp[a - d] + 1)
        return max(dp.values())","auto longestSubsequence(auto arr, auto d) {
    dp = collections.Counter()
    for a in arr:
    dp[a] = max(dp[a], dp[a - d] + 1)
    return max(dp.values())
}"
1219.py,"def getMaximumGold(self, grid: List[List[int]]) -> int:
        def dfs(i, j, v):
            seen.add((i, j))
            dp[i][j] = max(dp[i][j], v)
            for x, y in (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1):
                if 0 <= x < m and 0 <= y < n and grid[x][y] and (x, y) not in seen:
                    dfs(x, y, v + grid[x][y])
            seen.discard((i, j))
        m, n = len(grid), len(grid[0])
        dp = [[0] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                if grid[i][j]:
                    seen = set()
                    dfs(i, j, grid[i][j])
        return max(c for row in dp for c in row)","auto getMaximumGold(auto grid) {
    def dfs(i, j, v):
    seen.add((i, j))
    dp[i][j] = max(dp[i][j], v)
    for x, y in (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1):
    if 0 <= x < m and 0 <= y < n and grid[x][y] and (x, y) not in seen:
    dfs(x, y, v + grid[x][y])
    seen.discard((i, j))
    m, n = len(grid), len(grid[0])
    dp = [[0] * n for _ in range(m)]
    for i in range(m):
    for j in range(n):
    if grid[i][j]:
    seen = set()
    dfs(i, j, grid[i][j])
    return max(c for row in dp for c in row)
}"
122.py,"def maxProfit(self, prices: List[int]) -> int:
        # stock, no stock
        dp = [-float('inf'), 0]
        for p in prices:
            x = max(dp[1] - p, dp[0])
            y = max(dp[1], dp[0] + p)
            dp = [x, y]
        return dp[-1]","auto maxProfit(auto prices) {
    # stock, no stock
    dp = [-float('inf'), 0]
    for p in prices:
    x = max(dp[1] - p, dp[0])
    y = max(dp[1], dp[0] + p)
    dp = [x, y]
    return dp[-1]
}"
1220.py,"def countVowelPermutation(self, n: int) -> int:
        mod = 10 ** 9 + 7
        dp = [1] * 5
        for _ in range(n - 1):
            add = [0] * 5
            # from a
            add[1] = (add[1] + dp[0]) % mod
            # from e
            add[0] = (add[0] + dp[1]) % mod
            add[2] = (add[2] + dp[1]) % mod
            # from i
            add[0] = (add[0] + dp[2]) % mod
            add[1] = (add[1] + dp[2]) % mod
            add[3] = (add[3] + dp[2]) % mod
            add[4] = (add[4] + dp[2]) % mod
            # from o
            add[2] = (add[2] + dp[3]) % mod
            add[4] = (add[4] + dp[3]) % mod
            # from u
            add[0] = (add[0] + dp[4]) % mod
            for i in range(5):
                dp[i] = add[i] % mod
        return sum(dp) % mod","auto countVowelPermutation(auto n) {
    mod = 10 ** 9 + 7
    dp = [1] * 5
    for _ in range(n - 1):
    add = [0] * 5
    # from a
    add[1] = (add[1] + dp[0]) % mod
    # from e
    add[0] = (add[0] + dp[1]) % mod
    add[2] = (add[2] + dp[1]) % mod
    # from i
    add[0] = (add[0] + dp[2]) % mod
    add[1] = (add[1] + dp[2]) % mod
    add[3] = (add[3] + dp[2]) % mod
    add[4] = (add[4] + dp[2]) % mod
    # from o
    add[2] = (add[2] + dp[3]) % mod
    add[4] = (add[4] + dp[3]) % mod
    # from u
    add[0] = (add[0] + dp[4]) % mod
    for i in range(5):
    dp[i] = add[i] % mod
    return sum(dp) % mod
}"
1221.py,"def balancedStringSplit(self, s: str) -> int:
        res = cnt = 0         
        for c in s:
            cnt += c == 'L'
            cnt -= c == 'R'
            res += cnt == 0
        return res  ","auto balancedStringSplit(auto s) {
    res = cnt = 0
    for c in s:
    cnt += c == 'L'
    cnt -= c == 'R'
    res += cnt == 0
    return res
}"
1222.py,"def queensAttacktheKing(self, queens: List[List[int]], king: List[int]) -> List[List[int]]:
        def dfs(dr, dc, r, c):
            while 0 <= r <= 7 and 0 <= c <= 7:
                if (r, c) in q:
                    res.append([r, c])
                    break
                r += dr
                c += dc
        q = set((r,c) for r, c in queens)
        res = []
        for dr, dc in (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1):
            dfs(dr, dc, *king)
        return res","auto queensAttacktheKing(auto queens, auto king) {
    def dfs(dr, dc, r, c):
    while 0 <= r <= 7 and 0 <= c <= 7:
    if (r, c) in q:
    res.append([r, c])
    break
    r += dr
    c += dc
    q = set((r,c) for r, c in queens)
    res = []
    for dr, dc in (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1):
    dfs(dr, dc, *king)
    return res
}"
1223.py,"def dieSimulator(self, n: int, r: List[int]) -> int:
        K = max(r)
        dp = [[[0 for k in range(K)] for j in range(6)] for i in range(n)] 
        for j in range(6): dp[0][j][0] = 1
        for i in range(1, n):
            for j in range(6):
                dp[i][j][0] += sum(dp[i-1][t][k] for t in range(6) for k in range(r[t]) if t != j)
                for k in range(1, r[j]):
                    dp[i][j][k] = dp[i-1][j][k-1]
        return sum(dp[n-1][j][k] for j in range(6) for k in range(K)) % (10**9+7)","auto dieSimulator(auto n, auto r) {
    K = max(r)
    dp = [[[0 for k in range(K)] for j in range(6)] for i in range(n)]
    for j in range(6): dp[0][j][0] = 1
    for i in range(1, n):
    for j in range(6):
    dp[i][j][0] += sum(dp[i-1][t][k] for t in range(6) for k in range(r[t]) if t != j)
    for k in range(1, r[j]):
    dp[i][j][k] = dp[i-1][j][k-1]
    return sum(dp[n-1][j][k] for j in range(6) for k in range(K)) % (10**9+7)
}"
1224.py,"def maxEqualFreq(self, nums: List[int]) -> int:
        def okay():
            if len(dic) == 1 and (1 in dic or 1 in dic.values()):
                return True 
            if len(dic) == 2:
                c1, c2 = sorted(dic.keys())
                if c2 - c1 == 1 and dic[c2] == 1 or (c1 == 1 and dic[1] == 1):
                    return True
        cnt = collections.Counter(nums)
        dic = collections.Counter(cnt.values())
        l = len(nums)
        for num in nums[::-1]:
            if okay():
                return l
            dic[cnt[num]] -= 1
            if not dic[cnt[num]]:
                dic.pop(cnt[num])
            cnt[num] -= 1
            if cnt[num]:
                dic[cnt[num]] += 1
            l -= 1
            if okay():
                return l","auto maxEqualFreq(auto nums) {
    def okay():
    if len(dic) == 1 and (1 in dic or 1 in dic.values()):
    return true
    if len(dic) == 2:
    c1, c2 = sorted(dic.keys())
    if c2 - c1 == 1 and dic[c2] == 1 or (c1 == 1 and dic[1] == 1):
    return true
    cnt = collections.Counter(nums)
    dic = collections.Counter(cnt.values())
    l = len(nums)
    for num in nums[::-1]:
    if okay():
    return l
    dic[cnt[num]] -= 1
    if not dic[cnt[num]]:
    dic.pop(cnt[num])
    cnt[num] -= 1
    if cnt[num]:
    dic[cnt[num]] += 1
    l -= 1
    if okay():
    return l
}"
1227.py,"def nthPersonGetsNthSeat(self, n: int) -> float:
        return max(0.5, 1 / n)","auto nthPersonGetsNthSeat(auto n) {
    return max(0.5, 1 / n)
}"
1228.py,"def missingNumber(self, arr: List[int]) -> int:
        d = (arr[-1] - arr[0]) // len(arr)
        for a, b in zip(arr, arr[1:]):
            if b != a + d:
                return a + d
        return 0
        ","auto missingNumber(auto arr) {
    d = (arr[-1] - arr[0]) // len(arr)
    for a, b in zip(arr, arr[1:]):
    if b != a + d:
    return a + d
    return 0
}"
1229.py,"def minAvailableDuration(self, s1: List[List[int]], s2: List[List[int]], d: int) -> List[int]:
        s2.sort()
        j = 0
        for s, e in sorted(s1):
            while j < len(s2) - 1 and s2[j][1] < s:
                j += 1
            if s2[j][0] <= e:
                l, r = max(s, s2[j][0]), min(e,s2[j][1])
                if r - l >= d:
                    return [l, l + d]","auto minAvailableDuration(auto s1, auto s2, auto d) {
    s2.sort()
    j = 0
    for s, e in sorted(s1):
    while j < len(s2) - 1 and s2[j][1] < s:
    j += 1
    if s2[j][0] <= e:
    l, r = max(s, s2[j][0]), min(e,s2[j][1])
    if r - l >= d:
    return [l, l + d]
}"
123.py,"def maxProfit(self, prices):
        s1 = s2 = 0
        b1 = b2 = -float(""inf"")
        for p in prices:
            if -p > b1: b1 = -p
            if b1 + p > s1: s1 = b1 + p
            if s1 - p > b2: b2 = s1 - p
            if b2 + p > s2: s2 = b2 + p
        return s2","auto maxProfit(auto prices) {
    s1 = s2 = 0
    b1 = b2 = -float(""inf"")
    for p in prices:
    if -p > b1: b1 = -p
    if b1 + p > s1: s1 = b1 + p
    if s1 - p > b2: b2 = s1 - p
    if b2 + p > s2: s2 = b2 + p
    return s2
}"
1230.py,"def probabilityOfHeads(self, p: List[float], t: int) -> float:
        n = len(p)
        dp = [[0] * (n + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        for i in range(1, n + 1):
            for j in range(i + 1):
                if j == 0:
                    dp[i][j] = dp[i - 1][j] * (1 - p[i - 1])
                else : 
                    dp[i][j] = (dp[i - 1][j] * (1.0 - p[i - 1])) + (dp[i - 1][j - 1] * p[i - 1])
        return dp[-1][t]
        ","auto probabilityOfHeads(auto p, auto t) {
    n = len(p)
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    dp[0][0] = 1
    for i in range(1, n + 1):
    for j in range(i + 1):
    if j == 0:
    dp[i][j] = dp[i - 1][j] * (1 - p[i - 1])
    else :
    dp[i][j] = (dp[i - 1][j] * (1.0 - p[i - 1])) + (dp[i - 1][j - 1] * p[i - 1])
    return dp[-1][t]
}"
1231.py,"def maximizeSweetness(self, sw: List[int], K: int) -> int:
        def ok(m):
            c = sm = 0
            for s in sw:
                sm += s
                if sm >= m:
                    sm = 0 
                    c += 1
            return c >= K + 1
        l, r = 1, sum(sw)
        while l < r:
            m = (l + r) // 2
            if ok(m):
                l = m + 1
            else:
                r = m - 1
        print(l, r)
        return r if ok(r) else l - 1
        ","auto maximizeSweetness(auto sw, auto K) {
    def ok(m):
    c = sm = 0
    for s in sw:
    sm += s
    if sm >= m:
    sm = 0
    c += 1
    return c >= K + 1
    l, r = 1, sum(sw)
    while l < r:
    m = (l + r) // 2
    if ok(m):
    l = m + 1
    else:
    r = m - 1
    print(l, r)
    return r if ok(r) else l - 1
}"
1232.py,"def checkStraightLine(self, c: List[List[int]]) -> bool:
        return len(set(a[0] == b[0] or (b[1] - a[1]) / (b[0] - a[0]) for a, b in zip(c, c[1:]))) == 1","auto checkStraightLine(auto c) {
    return len(set(a[0] == b[0] or (b[1] - a[1]) / (b[0] - a[0]) for a, b in zip(c, c[1:]))) == 1
}"
1233.py,"def removeSubfolders(self, folder: List[str]) -> List[str]:
        st = set(folder)
        for f in folder:
            if any(p in st for p in itertools.accumulate(f.split('/'), lambda x, y: x + '/' + y) if p and p != f):
                st.discard(f)
        return list(st)   ","auto removeSubfolders(auto folder) {
    st = set(folder)
    for f in folder:
    if any(p in st for p in itertools.accumulate(f.split('/'), lambda x, y: x + '/' + y) if p and p != f):
    st.discard(f)
    return list(st)
}"
1234.py,"def balancedString(self, s: str) -> int:
        cnt, i, res = {c: max(s.count(c) - len(s) // 4, 0) for c in 'QWER'}, 0, len(s)
        for j, c in enumerate(s):
            cnt[c] -= 1
            while i < len(s) and cnt[s[i]] < 0:
                cnt[s[i]] += 1
                i += 1
            if not any(cnt[c] > 0 for c in 'QWER'):
                res = min(res, j - i + 1)
        return res","auto balancedString(auto s) {
    cnt, i, res = {c: max(s.count(c) - len(s) // 4, 0) for c in 'QWER'}, 0, len(s)
    for j, c in enumerate(s):
    cnt[c] -= 1
    while i < len(s) and cnt[s[i]] < 0:
    cnt[s[i]] += 1
    i += 1
    if not any(cnt[c] > 0 for c in 'QWER'):
    res = min(res, j - i + 1)
    return res
}"
1235.py,"def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:
        jobs = sorted(zip(startTime, endTime, profit), key=lambda v: v[1])
        dp = [[0, 0]]
        for s, e, p in jobs:
            i = bisect.bisect(dp, [s + 1]) - 1
            if dp[i][1] + p > dp[-1][1]:
                dp.append([e, dp[i][1] + p])
        return dp[-1][1]","auto jobScheduling(auto startTime, auto endTime, auto profit) {
    jobs = sorted(zip(startTime, endTime, profit), key=lambda v: v[1])
    dp = [[0, 0]]
    for s, e, p in jobs:
    i = bisect.bisect(dp, [s + 1]) - 1
    if dp[i][1] + p > dp[-1][1]:
    dp.append([e, dp[i][1] + p])
    return dp[-1][1]
}"
1238.py,"def circularPermutation(self, n: int, start: int) -> List[int]:
        return [start ^ i ^ i >> 1 for i in range(1 << n)]
","auto circularPermutation(auto n, auto start) {
    return [start ^ i ^ i >> 1 for i in range(1 << n)]
}"
1239.py,"def maxLength(self, arr: List[str]) -> int:
        bfs = [""""]
        for b in filter(lambda x: len(x) == len(set(x)), arr):
            bfs += [a + b for a in bfs if not set(a) & set(b)]
        return max(map(len, bfs))
","auto maxLength(auto arr) {
    bfs = [""""]
    for b in filter(lambda x: len(x) == len(set(x)), arr):
    bfs += [a + b for a in bfs if not set(a) & set(b)]
    return max(map(len, bfs))
}"
124.py,"def maxPathSum(self, root):
        res = [-float(""inf"")]
        def dfs(node):
            if not node: return -float(""inf"")
            l, r = dfs(node.left), dfs(node.right)
            mx = max(node.val, l + node.val, r + node.val)
            res[0] = max(res[0], mx, node.val + l + r)
            return mx
        dfs(root)
        return res[0]","auto maxPathSum(auto root) {
    res = [-float(""inf"")]
    def dfs(node):
    if not node: return -float(""inf"")
    l, r = dfs(node.left), dfs(node.right)
    mx = max(node.val, l + node.val, r + node.val)
    res[0] = max(res[0], mx, node.val + l + r)
    return mx
    dfs(root)
    return res[0]
}"
1243.py,"def transformArray(self, arr: List[int], change: bool = True) -> List[int]:
        while change:
            new = (
                arr[:1]
                + [
                    b + (a > b < c) - (a < b > c)
                    for a, b, c in zip(arr, arr[1:], arr[2:])
                ]
                + arr[-1:]
            )
            arr, change = new, arr != new
        return arr
","auto transformArray(auto arr, auto change) {
    while change:
    new = (
    arr[:1]
    + [
    b + (a > b < c) - (a < b > c)
    for a, b, c in zip(arr, arr[1:], arr[2:])
    ]
    + arr[-1:]
    )
    arr, change = new, arr != new
    return arr
}"
1245.py,"def treeDiameter(self, edges: List[List[int]], move: int = 0) -> int:
        graph = collections.defaultdict(set)
        for a, b in edges:
            graph[a].add(b)
            graph[b].add(a)
        bfs = {(u, None) for u, nex in graph.items() if len(nex) == 1}
        while bfs:
            bfs, move = (
                {(v, u) for u, pre in bfs for v in graph[u] if v != pre},
                move + 1,
            )
        return max(move - 1, 0)
","auto treeDiameter(auto edges, auto move) {
    graph = collections.defaultdict(set)
    for a, b in edges:
    graph[a].add(b)
    graph[b].add(a)
    bfs = {(u, nullptr) for u, nex in graph.items() if len(nex) == 1}
    while bfs:
    bfs, move = (
    {(v, u) for u, pre in bfs for v in graph[u] if v != pre},
    move + 1,
    )
    return max(move - 1, 0)
}"
1246.py,"def minimumMoves(self, arr: List[int]) -> int:
        n = len(arr)
        dp = [[0] * (n + 1) for _ in range(n + 1)]
        for l in range(1, n + 1):
            i, j = 0, l - 1
            while j < n:
                if l == 1:
                    dp[i][j] = 1
                else:
                    dp[i][j] = 1 + dp[i + 1][j]
                    if arr[i] == arr[i + 1]:
                        dp[i][j] = min(1 + dp[i + 2][j], dp[i][j])
                    for k in range(i + 2, j + 1):
                        if arr[i] == arr[k]:
                            dp[i][j] = min(dp[i + 1][k - 1] + dp[k + 1][j], dp[i][j])
                i, j = i + 1, j + 1
        return dp[0][n - 1]
","auto minimumMoves(auto arr) {
    n = len(arr)
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    for l in range(1, n + 1):
    i, j = 0, l - 1
    while j < n:
    if l == 1:
    dp[i][j] = 1
    else:
    dp[i][j] = 1 + dp[i + 1][j]
    if arr[i] == arr[i + 1]:
    dp[i][j] = min(1 + dp[i + 2][j], dp[i][j])
    for k in range(i + 2, j + 1):
    if arr[i] == arr[k]:
    dp[i][j] = min(dp[i + 1][k - 1] + dp[k + 1][j], dp[i][j])
    i, j = i + 1, j + 1
    return dp[0][n - 1]
}"
1247.py,"def minimumSwap(self, s1: str, s2: str, xy: int = 0, yx: int = 0) -> int:
        for a, b in zip(s1, s2):
            xy += a == ""x"" and b == ""y""
            yx += a == ""y"" and b == ""x""
        return (xy + yx) // 2 + (xy % 2) * 2 if xy % 2 == yx % 2 else -1
","auto minimumSwap(auto s1, auto s2, auto xy, auto yx) {
    for a, b in zip(s1, s2):
    xy += a == ""x"" and b == ""y""
    yx += a == ""y"" and b == ""x""
    return (xy + yx) // 2 + (xy % 2) * 2 if xy % 2 == yx % 2 else -1
}"
1248.py,"def numberOfSubarrays(self, nums: List[int], k: int, cnt: int = 0) -> int:
        odds = [-1] + [i for i, num in enumerate(nums) if num % 2] + [len(nums)]
        return sum(
            (odds[j - k + 1] - odds[j - k]) * (odds[j + 1] - odds[j])
            for j in range(k, len(odds) - 1)
        )

","auto numberOfSubarrays(auto nums, auto k, auto cnt) {
    odds = [-1] + [i for i, num in enumerate(nums) if num % 2] + [len(nums)]
    return sum(
    (odds[j - k + 1] - odds[j - k]) * (odds[j + 1] - odds[j])
    for j in range(k, len(odds) - 1)
    )
}"
125.py,"def isPalindrome(self, s):
        """"""
        :type s: str
        :rtype: bool
        """"""
        import string
        return True if s=="""" or [i.lower() for i in s if i in string.digits or i in string.ascii_letters]==[i.lower() for i in s if i in string.digits or i in string.ascii_letters][::-1] else False","auto isPalindrome(auto s) {
    """"""
    :type s: str
    :rtype: bool
    """"""
    import string
    return True if s=="""" or [i.lower() for i in s if i in string.digits or i in string.ascii_letters]==[i.lower() for i in s if i in string.digits or i in string.ascii_letters][::-1] else False
}"
1254.py,"def closedIsland(self, grid: List[List[int]]) -> int:
        def dfs(i, j, ret=True):
            grid[i][j] = -1
            for x, y in (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1):
                if 0 <= x < m and 0 <= y < n:
                    if not grid[x][y]:
                        ret &= dfs(x, y)
                else:
                    ret = False
            return ret

        m, n = len(grid), len(grid[0])
        return sum(dfs(i, j) for i in range(m) for j in range(n) if grid[i][j] == 0)

","auto closedIsland(auto grid) {
    def dfs(i, j, ret=true):
    grid[i][j] = -1
    for x, y in (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1):
    if 0 <= x < m and 0 <= y < n:
    if not grid[x][y]:
    ret &= dfs(x, y)
    else:
    ret = false
    return ret
    
    m, n = len(grid), len(grid[0])
    return sum(dfs(i, j) for i in range(m) for j in range(n) if grid[i][j] == 0)
}"
1256.py,"def encode(self, num: int) -> str:
        return bin(num + 1)[3:]
","auto encode(auto num) {
    return bin(num + 1)[3:]
}"
1258.py,"def generateSentences(self, synonyms: List[List[str]], text: str) -> List[str]:
        def root(s):
            return s if parent[s] == s else root(parent[s])

        parent = {s: s for s in [c for sy in synonyms for c in sy] + text.split()}
        for a, b in synonyms:
            parent[root(a)] = root(b)
        bfs = [""""]
        for t in text.split():
            r = root(t)
            bfs = [s + "" "" + w for s in bfs for w in parent if root(w) == r]
        return sorted(s[1:] for s in bfs)
","auto generateSentences(auto synonyms, auto text) {
    def root(s):
    return s if parent[s] == s else root(parent[s])
    
    parent = {s: s for s in [c for sy in synonyms for c in sy] + text.split()}
    for a, b in synonyms:
    parent[root(a)] = root(b)
    bfs = [""""]
    for t in text.split():
    r = root(t)
    bfs = [s + "" "" + w for s in bfs for w in parent if root(w) == r]
    return sorted(s[1:] for s in bfs)
}"
1259.py,"def numberOfWays(self, num_people):
        self.memo = {0: 1}

        def dp(n):
            if n not in self.memo:
                self.memo[n] = sum(
                    [dp(i - 2) * dp(n - i) for i in range(2, n + 1, 2)]
                ) % (10 ** 9 + 7)
            return self.memo[n]

        return dp(num_people)
","auto numberOfWays(auto num_people) {
    self.memo = {0: 1}
    
    def dp(n):
    if n not in self.memo:
    self.memo[n] = sum(
    [dp(i - 2) * dp(n - i) for i in range(2, n + 1, 2)]
    ) % (10 ** 9 + 7)
    return self.memo[n]
    
    return dp(num_people)
}"
126.py,"def findLadders(self, beginWord, endWord, wordList):
        words, res, layer = set(wordList), [], {beginWord: [[beginWord]]}
        while layer:
            newlayer = collections.defaultdict(list)
            for w in layer:
                if w == endWord: 
                    for arr in layer[w]:
                        res.append(arr)
                else:
                    for i in range(len(w)):
                        for c in string.ascii_lowercase:
                            neww = w[:i] + c + w[i + 1:]
                            if neww in words:
                                newlayer[neww] += [j + [neww] for j in layer[w]]
            words -= set(newlayer.keys())
            layer = newlayer
        return res","auto findLadders(auto beginWord, auto endWord, auto wordList) {
    words, res, layer = set(wordList), [], {beginWord: [[beginWord]]}
    while layer:
    newlayer = collections.defaultdict(list)
    for w in layer:
    if w == endWord:
    for arr in layer[w]:
    res.append(arr)
    else:
    for i in range(len(w)):
    for c in string.ascii_lowercase:
    neww = w[:i] + c + w[i + 1:]
    if neww in words:
    newlayer[neww] += [j + [neww] for j in layer[w]]
    words -= set(newlayer.keys())
    layer = newlayer
    return res
}"
1260.py,"def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:
        chain = [r for row in grid for r in row]
        k %= len(chain)
        chain = chain[-k:] + chain[:-k]
        return [chain[i : i + len(grid[0])] for i in range(0, len(chain), len(grid[0]))]

","auto shiftGrid(auto grid, auto k) {
    chain = [r for row in grid for r in row]
    k %= len(chain)
    chain = chain[-k:] + chain[:-k]
    return [chain[i : i + len(grid[0])] for i in range(0, len(chain), len(grid[0]))]
}"
1263.py,"def minPushBox(self, grid: List[List[str]]) -> int:
        m, n = len(grid), len(grid[0])
        for r in range(m):
            for c in range(n):
                if grid[r][c] == ""T"":
                    tX, tY = r, c
                if grid[r][c] == ""B"":
                    bX, bY = r, c
                if grid[r][c] == ""S"":
                    pX, pY = r, c

        def heuristic(bX, bY):
            return abs(tX - bX) + abs(tY - bY)

        heap = [[heuristic(bX, bY), 0, pX, pY, bX, bY]]
        visited = set()
        while heap:
            _, moves, pX, pY, bX, bY = heapq.heappop(heap)
            if bX == tX and bY == tY:
                return moves
            if (pX, pY, bX, bY) not in visited:
                visited.add((pX, pY, bX, bY))
                for dx, dy in (0, 1), (1, 0), (-1, 0), (0, -1):
                    pX += dx
                    pY += dy
                    if 0 <= pX < m and 0 <= pY < n and grid[pX][pY] != ""#"":
                        if pX == bX and pY == bY:
                            bX += dx
                            bY += dy
                            if 0 <= bX < m and 0 <= bY < n and grid[bX][bY] != ""#"":
                                heapq.heappush(
                                    heap,
                                    [
                                        heuristic(bX, bY) + moves + 1,
                                        moves + 1,
                                        pX,
                                        pY,
                                        bX,
                                        bY,
                                    ],
                                )
                            bX -= dx
                            bY -= dy
                        else:
                            heapq.heappush(
                                heap, [heuristic(bX, bY) + moves, moves, pX, pY, bX, bY]
                            )
                    pX -= dx
                    pY -= dy
        return -1
","auto minPushBox(auto grid) {
    m, n = len(grid), len(grid[0])
    for r in range(m):
    for c in range(n):
    if grid[r][c] == ""T"":
    tX, tY = r, c
    if grid[r][c] == ""B"":
    bX, bY = r, c
    if grid[r][c] == ""S"":
    pX, pY = r, c
    
    def heuristic(bX, bY):
    return abs(tX - bX) + abs(tY - bY)
    
    heap = [[heuristic(bX, bY), 0, pX, pY, bX, bY]]
    visited = set()
    while heap:
    _, moves, pX, pY, bX, bY = heapq.heappop(heap)
    if bX == tX and bY == tY:
    return moves
    if (pX, pY, bX, bY) not in visited:
    visited.add((pX, pY, bX, bY))
    for dx, dy in (0, 1), (1, 0), (-1, 0), (0, -1):
    pX += dx
    pY += dy
    if 0 <= pX < m and 0 <= pY < n and grid[pX][pY] != ""#"":
    if pX == bX and pY == bY:
    bX += dx
    bY += dy
    if 0 <= bX < m and 0 <= bY < n and grid[bX][bY] != ""#"":
    heapq.heappush(
    heap,
    [
    heuristic(bX, bY) + moves + 1,
    moves + 1,
    pX,
    pY,
    bX,
    bY,
    ],
    )
    bX -= dx
    bY -= dy
    else:
    heapq.heappush(
    heap, [heuristic(bX, bY) + moves, moves, pX, pY, bX, bY]
    )
    pX -= dx
    pY -= dy
    return -1
}"
127.py,"def ladderLength(self, beginWord, endWord, wordList):
        words, layer = set(wordList), {beginWord: [[beginWord]]}
        while layer:
            newlayer = collections.defaultdict(list)
            for w in layer:
                if w == endWord: 
                    return len(layer[w][0])
                else:
                    for i in range(len(w)):
                        for c in string.ascii_lowercase:
                            neww = w[:i] + c + w[i + 1:]
                            if neww in words:
                                newlayer[neww] += [j + [neww] for j in layer[w]]
            words -= set(newlayer.keys())
            layer = newlayer
        return 0","auto ladderLength(auto beginWord, auto endWord, auto wordList) {
    words, layer = set(wordList), {beginWord: [[beginWord]]}
    while layer:
    newlayer = collections.defaultdict(list)
    for w in layer:
    if w == endWord:
    return len(layer[w][0])
    else:
    for i in range(len(w)):
    for c in string.ascii_lowercase:
    neww = w[:i] + c + w[i + 1:]
    if neww in words:
    newlayer[neww] += [j + [neww] for j in layer[w]]
    words -= set(newlayer.keys())
    layer = newlayer
    return 0
}"
128.py,"def longestConsecutive(self, nums):
        res, items = 0, set(nums)
        for num in items:
            if num - 1 not in items:
                cur = 1
                while num + 1 in items:
                    num, cur = num + 1, cur + 1   
                if cur > res: res = cur
        return res","auto longestConsecutive(auto nums) {
    res, items = 0, set(nums)
    for num in items:
    if num - 1 not in items:
    cur = 1
    while num + 1 in items:
    num, cur = num + 1, cur + 1
    if cur > res: res = cur
    return res
}"
13.py,"def romanToInt(self, s):
        table = {""M"": 1000, ""D"": 500, ""C"": 100, ""L"": 50, ""X"": 10, ""V"": 5, ""I"": 1}
        sm, pre = 0, 'I'
        for c in s[::-1]: 
            if table[c] < table[pre]:
                sm, pre = sm - table[c], c  
            else:
                sm, pre = sm + table[c], c
        return sm","auto romanToInt(auto s) {
    table = {""M"": 1000, ""D"": 500, ""C"": 100, ""L"": 50, ""X"": 10, ""V"": 5, ""I"": 1}
    sm, pre = 0, 'I'
    for c in s[::-1]:
    if table[c] < table[pre]:
    sm, pre = sm - table[c], c
    else:
    sm, pre = sm + table[c], c
    return sm
}"
131.py,"def partition(self, s):
        q, n = [[s[0]]], len(s)
        for i in range(1, n):
            new = []
            for arr in q:
                cur = arr[-1] + s[i]
                if i < n - 1 or cur == cur[::-1]:
                    new.append(arr[:-1] + [cur])
                if arr[-1] == arr[-1][::-1]:
                    new.append(arr + [s[i]])
            q = new
        return q","auto partition(auto s) {
    q, n = [[s[0]]], len(s)
    for i in range(1, n):
    new = []
    for arr in q:
    cur = arr[-1] + s[i]
    if i < n - 1 or cur == cur[::-1]:
    new.append(arr[:-1] + [cur])
    if arr[-1] == arr[-1][::-1]:
    new.append(arr + [s[i]])
    q = new
    return q
}"
132.py,"def minCut(self, s):
        q, pal, used = [(0, 0)], collections.defaultdict(list), {(0, 0)}
        for i in range(len(s)):
            for j in range(i, len(s)):
                if s[i:j + 1] == s[i:j + 1][::-1]: pal[i].append(j + 1)
        while q:
            cuts, i = heapq.heappop(q)
            i *= -1
            if i == len(s): return cuts - 1
            for j in pal[i]:
                if (cuts + 1, -j) not in used:
                    used.add((cuts + 1, -j))
                    heapq.heappush(q, (cuts + 1, -j))","auto minCut(auto s) {
    q, pal, used = [(0, 0)], collections.defaultdict(list), {(0, 0)}
    for i in range(len(s)):
    for j in range(i, len(s)):
    if s[i:j + 1] == s[i:j + 1][::-1]: pal[i].append(j + 1)
    while q:
    cuts, i = heapq.heappop(q)
    i *= -1
    if i == len(s): return cuts - 1
    for j in pal[i]:
    if (cuts + 1, -j) not in used:
    used.add((cuts + 1, -j))
    heapq.heappush(q, (cuts + 1, -j))
}"
134.py,"def canCompleteCircuit(self, gas, cost, cur = 0, index = 0):
        for i in range(len(gas)):
            cur += gas[i] - cost[i]
            if cur < 0: cur, index = 0, i + 1
        return index if index < len(gas) and sum(gas) >= sum(cost) else -1","auto canCompleteCircuit(auto gas, auto cost, auto cur = 0, auto index = 0) {
    for i in range(len(gas)):
    cur += gas[i] - cost[i]
    if cur < 0: cur, index = 0, i + 1
    return index if index < len(gas) and sum(gas) >= sum(cost) else -1
}"
135.py,"def candy(self, ratings):
        dp = [1] * len(ratings)
        for i in range(1, len(ratings)):
            if ratings[i] > ratings[i - 1]:
                dp[i] = dp[i - 1] + 1
        for i in range(len(ratings) - 2, -1, -1):
            if ratings[i] > ratings[i + 1] and dp[i] <= dp[i + 1]:
                dp[i] = dp[i + 1] + 1
        return sum(dp)","auto candy(auto ratings) {
    dp = [1] * len(ratings)
    for i in range(1, len(ratings)):
    if ratings[i] > ratings[i - 1]:
    dp[i] = dp[i - 1] + 1
    for i in range(len(ratings) - 2, -1, -1):
    if ratings[i] > ratings[i + 1] and dp[i] <= dp[i + 1]:
    dp[i] = dp[i + 1] + 1
    return sum(dp)
}"
136.py,"def singleNumber(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        dic={}
        for num in nums:
            if not num in dic: dic[num]=1
            else: dic.pop(num)
        return list(dic.keys())[0]","auto singleNumber(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: int
    """"""
    dic={}
    for num in nums:
    if not num in dic: dic[num]=1
    else: dic.pop(num)
    return list(dic.keys())[0]
}"
137.py,"def singleNumber(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        return ((sum(set(nums)) * 3) - sum(nums)) // 2","auto singleNumber(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: int
    """"""
    return ((sum(set(nums)) * 3) - sum(nums)) // 2
}"
139.py,"def wordBreak(self, s, wordDict):
        rightmosts, words = [0], set(wordDict)
        for i in range(1, len(s) + 1):
            for last_index in rightmosts:
                if s[last_index:i] in words:
                    rightmosts.append(i)
                    if i == len(s): 
                        return True
                    break
        return False","auto wordBreak(auto s, auto wordDict) {
    rightmosts, words = [0], set(wordDict)
    for i in range(1, len(s) + 1):
    for last_index in rightmosts:
    if s[last_index:i] in words:
    rightmosts.append(i)
    if i == len(s):
    return True
    break
    return False
}"
14.py,"def longestCommonPrefix(self, s: List[str]) -> str:
        j = 0
        while s and all(j < len(s[i]) and j < len(s[i - 1]) and s[i][j] == s[i - 1][j] for i in range(len(s))):
            j += 1
        return s[0][:j] if j else ''","auto longestCommonPrefix(auto s) {
    j = 0
    while s and all(j < len(s[i]) and j < len(s[i - 1]) and s[i][j] == s[i - 1][j] for i in range(len(s))):
    j += 1
    return s[0][:j] if j else ''
}"
140.py,"def wordBreak(self, s, wordDict):
        def breakable():
            rightmosts = [0]
            for i in range(1, len(s) + 1):
                for last_index in rightmosts:
                    if s[last_index:i] in words:
                        rightmosts.append(i)
                        if i == len(s): 
                            return True
                        break
            return False
        q, res, words = [("""", 0)], [], set(wordDict)
        if breakable():
            for j in range(1, len(s) + 1):
                new = q[:]
                for seq, i in q:
                    if s[i:j] in words:
                        if j == len(s):
                            res.append(seq and seq + "" "" + s[i:j] or s[i:j])
                        else:
                            new.append((seq and seq + "" "" + s[i:j] or s[i:j], j))
                q = new
        return res","auto wordBreak(auto s, auto wordDict) {
    def breakable():
    rightmosts = [0]
    for i in range(1, len(s) + 1):
    for last_index in rightmosts:
    if s[last_index:i] in words:
    rightmosts.append(i)
    if i == len(s):
    return True
    break
    return False
    q, res, words = [("""", 0)], [], set(wordDict)
    if breakable():
    for j in range(1, len(s) + 1):
    new = q[:]
    for seq, i in q:
    if s[i:j] in words:
    if j == len(s):
    res.append(seq and seq + "" "" + s[i:j] or s[i:j])
    else:
    new.append((seq and seq + "" "" + s[i:j] or s[i:j], j))
    q = new
    return res
}"
141.py,"def hasCycle(self, head: ListNode) -> bool:
        slow, fast = head, head.next if head else None
        while slow != None and fast != None:
            if slow == fast:
                return True
            slow, fast = slow.next, fast.next.next if fast.next else None
        return False
","auto hasCycle(auto head) {
    slow, fast = head, head.next if head else nullptr
    while slow != nullptr and fast != nullptr:
    if slow == fast:
    return true
    slow, fast = slow.next, fast.next.next if fast.next else nullptr
    return false
}"
142.py,"def detectCycle(self, head: ListNode) -> ListNode:
        fast = slow = root = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                while root != slow:
                    root = root.next
                    slow = slow.next
                return root
","auto detectCycle(auto head) {
    fast = slow = root = head
    while fast and fast.next:
    slow = slow.next
    fast = fast.next.next
    if slow == fast:
    while root != slow:
    root = root.next
    slow = slow.next
    return root
}"
145.py,"def postorderTraversal(self, root):
        ret, stack = [], root and [root]
        while stack:
            node = stack.pop()
            ret.append(node.val)
            stack += [child for child in (node.left, node.right) if child]
        return ret[::-1]","auto postorderTraversal(auto root) {
    ret, stack = [], root and [root]
    while stack:
    node = stack.pop()
    ret.append(node.val)
    stack += [child for child in (node.left, node.right) if child]
    return ret[::-1]
}"
15.py,"def threeSum(self, nums):
        res, res_set = [], set()
        nums.sort()
        for i in range(len(nums) - 2):
            l, r = i + 1, len(nums) - 1
            while l < r:
                sm = nums[i] + nums[l] + nums[r] 
                if sm < 0: l += 1
                elif sm > 0: r -= 1
                elif (nums[i], nums[l], nums[r]) not in res_set: 
                    res.append([nums[i], nums[l], nums[r]])
                    res_set.add((nums[i], nums[l], nums[r])) 
                else: l, r = l + 1, r - 1
        return res","auto threeSum(auto nums) {
    res, res_set = [], set()
    nums.sort()
    for i in range(len(nums) - 2):
    l, r = i + 1, len(nums) - 1
    while l < r:
    sm = nums[i] + nums[l] + nums[r]
    if sm < 0: l += 1
    elif sm > 0: r -= 1
    elif (nums[i], nums[l], nums[r]) not in res_set:
    res.append([nums[i], nums[l], nums[r]])
    res_set.add((nums[i], nums[l], nums[r]))
    else: l, r = l + 1, r - 1
    return res
}"
150.py,"def evalRPN(self, tokens):
        """"""
        :type tokens: List[str]
        :rtype: int
        """"""
        stack = []
        for token in tokens:
            if token not in (""+"", ""-"", ""*"", ""/""): stack.append(int(token))
            else:
                num2, num1 = stack.pop(), stack.pop()
                if token == ""+"": last = num1 + num2
                elif token == ""-"": last = num1 - num2
                elif token == ""*"": last = num1 * num2
                elif token == ""/"": last = int(num1 / num2)
                stack.append(last)
        return stack[0]","auto evalRPN(auto tokens) {
    """"""
    :type tokens: List[str]
    :rtype: int
    """"""
    stack = []
    for token in tokens:
    if token not in (""+"", ""-"", ""*"", ""/""): stack.append(int(token))
    else:
    num2, num1 = stack.pop(), stack.pop()
    if token == ""+"": last = num1 + num2
    elif token == ""-"": last = num1 - num2
    elif token == ""*"": last = num1 * num2
    elif token == ""/"": last = int(num1 / num2)
    stack.append(last)
    return stack[0]
}"
151.py,"def reverseWords(self, s: str) -> str:
        return "" "".join(s.split()[::-1])
","auto reverseWords(auto s) {
    return "" "".join(s.split()[::-1])
}"
152.py,"def maxProduct(self, nums):
        res, min_pos, max_neg, cur = -float(""inf""), float(""inf""), -float(""inf""), 1
        for num in nums:
            cur *= num
            if cur > res: res = cur
            elif 0 < cur // min_pos > res: res = cur // min_pos
            elif 0 < cur // max_neg > res: res = cur // max_neg
            if cur == 0: min_pos, max_neg, cur = float(""inf""), -float(""inf""), 1
            elif max_neg < cur < 0: max_neg = cur
            elif 0 < cur < min_pos: min_pos = cur
        return res","auto maxProduct(auto nums) {
    res, min_pos, max_neg, cur = -float(""inf""), float(""inf""), -float(""inf""), 1
    for num in nums:
    cur *= num
    if cur > res: res = cur
    elif 0 < cur // min_pos > res: res = cur // min_pos
    elif 0 < cur // max_neg > res: res = cur // max_neg
    if cur == 0: min_pos, max_neg, cur = float(""inf""), -float(""inf""), 1
    elif max_neg < cur < 0: max_neg = cur
    elif 0 < cur < min_pos: min_pos = cur
    return res
}"
154.py,"def findMin(self, nums):
        l, r, res = 0, len(nums) - 1, nums and nums[0]
        while l <= r:
            while l < r and nums[l] == nums[l + 1]: l += 1
            while l < r and nums[r] == nums[r - 1]: r -= 1
            mid = (l + r) // 2
            if nums[mid] >= nums[0]: l = mid + 1
            else: r, res = mid - 1, min(res, nums[mid])
        return res","auto findMin(auto nums) {
    l, r, res = 0, len(nums) - 1, nums and nums[0]
    while l <= r:
    while l < r and nums[l] == nums[l + 1]: l += 1
    while l < r and nums[r] == nums[r - 1]: r -= 1
    mid = (l + r) // 2
    if nums[mid] >= nums[0]: l = mid + 1
    else: r, res = mid - 1, min(res, nums[mid])
    return res
}"
157.py,"def read(self, buf, n):
        idx = 0
        while True:
            buf4 = [""""] * 4
            curr = min(read4(buf4), n - idx)
            for i in range(curr):
                buf[idx] = buf4[i]
                idx += 1
            if curr != 4 or idx == n:
                return idx
","auto read(auto buf, auto n) {
    idx = 0
    while True:
    buf4 = [""""] * 4
    curr = min(read4(buf4), n - idx)
    for i in range(curr):
    buf[idx] = buf4[i]
    idx += 1
    if curr != 4 or idx == n:
    return idx
}"
159.py,"def lengthOfLongestSubstringTwoDistinct(self, s):
        start = distinct = 0
        cnt = collections.defaultdict(int)
        for c in s:
            cnt[c] += 1
            if cnt[c] == 1:
                distinct += 1
            if distinct > 2:
                cnt[s[start]] -= 1
                if not cnt[s[start]]:
                    distinct -= 1
                start += 1
        return len(s) - start","auto lengthOfLongestSubstringTwoDistinct(auto s) {
    start = distinct = 0
    cnt = collections.defaultdict(int)
    for c in s:
    cnt[c] += 1
    if cnt[c] == 1:
    distinct += 1
    if distinct > 2:
    cnt[s[start]] -= 1
    if not cnt[s[start]]:
    distinct -= 1
    start += 1
    return len(s) - start
}"
16.py,"def threeSumClosest(self, nums, target):
        res = diff = float(""inf"")
        nums.sort()
        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i - 1]: continue
            l, r = i + 1, len(nums) - 1
            while l < r:
                sm = nums[i] + nums[l] + nums[r]
                if abs(sm - target) < diff: diff, res = abs(sm - target), sm 
                if sm < target: l += 1
                elif sm > target: r -= 1
                else: return res
        return res","auto threeSumClosest(auto nums, auto target) {
    res = diff = float(""inf"")
    nums.sort()
    for i in range(len(nums)):
    if i > 0 and nums[i] == nums[i - 1]: continue
    l, r = i + 1, len(nums) - 1
    while l < r:
    sm = nums[i] + nums[l] + nums[r]
    if abs(sm - target) < diff: diff, res = abs(sm - target), sm
    if sm < target: l += 1
    elif sm > target: r -= 1
    else: return res
    return res
}"
161.py,"def isOneEditDistance(self, s, t):
        l1, l2, cnt, i, j = len(s), len(t), 0, 0, 0
        while i < l1 and j < l2:
            if s[i] != t[j]:
                cnt += 1
                if l1 < l2:
                    i -= 1
                elif l1 > l2:
                    j -= 1
            i += 1
            j += 1
        l = abs(l1 - l2)
        return (cnt == 1 and l <= 1)  or (cnt == 0 and l == 1)","auto isOneEditDistance(auto s, auto t) {
    l1, l2, cnt, i, j = len(s), len(t), 0, 0, 0
    while i < l1 and j < l2:
    if s[i] != t[j]:
    cnt += 1
    if l1 < l2:
    i -= 1
    elif l1 > l2:
    j -= 1
    i += 1
    j += 1
    l = abs(l1 - l2)
    return (cnt == 1 and l <= 1)  or (cnt == 0 and l == 1)
}"
162.py,"def findPeakElement(self, nums):
        l, r, n = 0, len(nums) - 1, len(nums)
        while l <= r:
            mid = (l + r) // 2
            pre, after = mid == 0 and -float(""inf"") or nums[mid - 1], mid == n - 1 and -float(""inf"") or nums[mid + 1]
            if pre < nums[mid] > after: return mid
            elif pre > nums[mid]: r = mid - 1
            else: l = mid + 1","auto findPeakElement(auto nums) {
    l, r, n = 0, len(nums) - 1, len(nums)
    while l <= r:
    mid = (l + r) // 2
    pre, after = mid == 0 and -float(""inf"") or nums[mid - 1], mid == n - 1 and -float(""inf"") or nums[mid + 1]
    if pre < nums[mid] > after: return mid
    elif pre > nums[mid]: r = mid - 1
    else: l = mid + 1
}"
163.py,"def findMissingRanges(self, nums, lower, upper):
        if not nums:
            return [str(lower) + ""->"" + str(upper)] if lower != upper else [str(lower)]
        res, n = [], len(nums)
        if lower + 1 < nums[0]:
            res.append(str(lower) + ""->"" + str(nums[0] - 1))
        elif lower + 1 == nums[0]:
            res.append(str(lower))
        for i in range(1, n):
            if nums[i] == nums[i - 1] + 2:
                res.append(str(nums[i] - 1))
            elif nums[i] > nums[i - 1] + 2:
                res.append(str(nums[i - 1] + 1) + ""->"" + str(nums[i] - 1))
        if nums[-1] + 1 < upper: 
            res.append(str(nums[-1] + 1) + ""->"" + str(upper))
        elif nums[-1] + 1 == upper:
            res.append(str(upper))
        return res","auto findMissingRanges(auto nums, auto lower, auto upper) {
    if not nums:
    return [str(lower) + ""->"" + str(upper)] if lower != upper else [str(lower)]
    res, n = [], len(nums)
    if lower + 1 < nums[0]:
    res.append(str(lower) + ""->"" + str(nums[0] - 1))
    elif lower + 1 == nums[0]:
    res.append(str(lower))
    for i in range(1, n):
    if nums[i] == nums[i - 1] + 2:
    res.append(str(nums[i] - 1))
    elif nums[i] > nums[i - 1] + 2:
    res.append(str(nums[i - 1] + 1) + ""->"" + str(nums[i] - 1))
    if nums[-1] + 1 < upper:
    res.append(str(nums[-1] + 1) + ""->"" + str(upper))
    elif nums[-1] + 1 == upper:
    res.append(str(upper))
    return res
}"
164.py,"def maximumGap(self, nums):
        if len(nums) < 2:
            return 0
        n, mn, mx= len(nums), min(nums), max(nums)
        bSize = max(1, (mx - mn) // n + 1)
        bNum = (mx - mn) // bSize + 1
        buckets = [[float(""inf""), -float(""inf"")] for _ in range(bNum)]
        for num in nums:
            ind = (num - mn) // bSize
            if num < buckets[ind][0]:
                buckets[ind][0] = num
            if num > buckets[ind][1]:
                buckets[ind][1] = num
        gap = 0
        for i in range(1, bNum):
            if buckets[i] == [float(""inf""), -float(""inf"")]:
                buckets[i] = buckets[i - 1]
            gap = max(gap , buckets[i][0] - buckets[i - 1][1])
        return gap","auto maximumGap(auto nums) {
    if len(nums) < 2:
    return 0
    n, mn, mx= len(nums), min(nums), max(nums)
    bSize = max(1, (mx - mn) // n + 1)
    bNum = (mx - mn) // bSize + 1
    buckets = [[float(""inf""), -float(""inf"")] for _ in range(bNum)]
    for num in nums:
    ind = (num - mn) // bSize
    if num < buckets[ind][0]:
    buckets[ind][0] = num
    if num > buckets[ind][1]:
    buckets[ind][1] = num
    gap = 0
    for i in range(1, bNum):
    if buckets[i] == [float(""inf""), -float(""inf"")]:
    buckets[i] = buckets[i - 1]
    gap = max(gap , buckets[i][0] - buckets[i - 1][1])
    return gap
}"
165.py,"def compareVersion(self, version1, version2):
        def getNum(s):
            if not s: return (None, None)
            for i in range(len(s)):
                if s[i] == ""."": return (s[i + 1:], int(s[:i]))
            return (None, int(s))
        while True:
            version1, n1 = getNum(version1)
            version2, n2 = getNum(version2)
            if version1 == version2 == n1 == n2 == None: return 0
            if n1 != None and n1 > 0 and (n2 == None or n1 > n2): return 1
            if n2 != None and n2 > 0 and (n1 == None or n2 > n1): return -1","auto compareVersion(auto version1, auto version2) {
    def getNum(s):
    if not s: return (None, None)
    for i in range(len(s)):
    if s[i] == ""."": return (s[i + 1:], int(s[:i]))
    return (None, int(s))
    while True:
    version1, n1 = getNum(version1)
    version2, n2 = getNum(version2)
    if version1 == version2 == n1 == n2 == None: return 0
    if n1 != None and n1 > 0 and (n2 == None or n1 > n2): return 1
    if n2 != None and n2 > 0 and (n1 == None or n2 > n1): return -1
}"
166.py,"def fractionToDecimal(self, n, d):
        res = [""-""] if n * d < 0 else [""""]
        n, d = abs(n), abs(d)
        res.append(str(n // d))
        n %= d
        if not n: return """".join(res)
        res.append(""."")
        mp = {n: len(res)}
        while n:
            n *= 10
            res.append(str(n // d))
            n %= d
            if n in mp:
                res.insert(mp[n], ""("")
                res.append("")"")
                break
            mp[n] = len(res)
        return """".join(res)","auto fractionToDecimal(auto n, auto d) {
    res = [""-""] if n * d < 0 else [""""]
    n, d = abs(n), abs(d)
    res.append(str(n // d))
    n %= d
    if not n: return """".join(res)
    res.append(""."")
    mp = {n: len(res)}
    while n:
    n *= 10
    res.append(str(n // d))
    n %= d
    if n in mp:
    res.insert(mp[n], ""("")
    res.append("")"")
    break
    mp[n] = len(res)
    return """".join(res)
}"
167.py,"def twoSum(self, numbers, target):
        """"""
        :type numbers: List[int]
        :type target: int
        :rtype: List[int]
        """"""
        left=numbers[0]
        right=numbers[-1]
        i,j=0,0
        while True:
            sum=left+right
            if sum>target:
                j+=1
                right=numbers[-1-j]
            if sum<target:
                i+=1
                left=numbers[0+i]
            if sum==target:
                return [i+1,len(numbers)-j]
            
                
        ","auto twoSum(auto numbers, auto target) {
    """"""
    :type numbers: List[int]
    :type target: int
    :rtype: List[int]
    """"""
    left=numbers[0]
    right=numbers[-1]
    i,j=0,0
    while True:
    sum=left+right
    if sum>target:
    j+=1
    right=numbers[-1-j]
    if sum<target:
    i+=1
    left=numbers[0+i]
    if sum==target:
    return [i+1,len(numbers)-j]
}"
168.py,"def convertToTitle(self, n: int) -> str:
        char = str()
        while n > 0:
            if n % 26 == 0:
                char += ""Z""
                n = n // 26 - 1
            else:
                char += chr(n % 26 + ord(""@""))
                n = n // 26
        return char[::-1]
","auto convertToTitle(auto n) {
    char = str()
    while n > 0:
    if n % 26 == 0:
    char += ""Z""
    n = n // 26 - 1
    else:
    char += chr(n % 26 + ord(""@""))
    n = n // 26
    return char[::-1]
}"
169.py,"def majorityElement(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        num_list=dict()
        for num in nums:
            if not num in num_list:
                num_list[num]=1
            else:
                num_list[num]+=1
        return max(num_list, key=num_list.get)","auto majorityElement(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: int
    """"""
    num_list=dict()
    for num in nums:
    if not num in num_list:
    num_list[num]=1
    else:
    num_list[num]+=1
    return max(num_list, key=num_list.get)
}"
17.py,"def letterCombinations(self, digits):
        dic, res = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}, [""""]
        for dig in digits:
            tmp = []
            for y in res: 
                for x in dic[dig]: tmp.append(y + x)
            res = tmp 
        return res if any(res) else []","auto letterCombinations(auto digits) {
    dic, res = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}, [""""]
    for dig in digits:
    tmp = []
    for y in res:
    for x in dic[dig]: tmp.append(y + x)
    res = tmp
    return res if any(res) else []
}"
171.py,"def titleToNumber(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        return sum([(ord(char)-64)*(26**i) for i,char in enumerate(s[::-1])])","auto titleToNumber(auto s) {
    """"""
    :type s: str
    :rtype: int
    """"""
    return sum([(ord(char)-64)*(26**i) for i,char in enumerate(s[::-1])])
}"
172.py,"def trailingZeroes(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        return 0 if n == 0 else n // 5 + self.trailingZeroes(n // 5)","auto trailingZeroes(auto n) {
    """"""
    :type n: int
    :rtype: int
    """"""
    return 0 if n == 0 else n // 5 + self.trailingZeroes(n // 5)
}"
174.py,"def calculateMinimumHP(self, dungeon):
        m, n = len(dungeon), len(dungeon[0])
        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                if i == m - 1 and j == n - 1:
                    dungeon[i][j] = max(1, 1 - dungeon[i][j])
                elif j == n - 1:
                    dungeon[i][j] = max(1, dungeon[i + 1][j] - dungeon[i][j])
                elif i == m - 1:
                    dungeon[i][j] = max(1, dungeon[i][j + 1] - dungeon[i][j])
                else:
                    dungeon[i][j] = max(1, min(dungeon[i + 1][j], dungeon[i][j + 1]) - dungeon[i][j])
        return dungeon[0][0]","auto calculateMinimumHP(auto dungeon) {
    m, n = len(dungeon), len(dungeon[0])
    for i in range(m - 1, -1, -1):
    for j in range(n - 1, -1, -1):
    if i == m - 1 and j == n - 1:
    dungeon[i][j] = max(1, 1 - dungeon[i][j])
    elif j == n - 1:
    dungeon[i][j] = max(1, dungeon[i + 1][j] - dungeon[i][j])
    elif i == m - 1:
    dungeon[i][j] = max(1, dungeon[i][j + 1] - dungeon[i][j])
    else:
    dungeon[i][j] = max(1, min(dungeon[i + 1][j], dungeon[i][j + 1]) - dungeon[i][j])
    return dungeon[0][0]
}"
179.py,"def largestNumber(self, nums):
        def partition(l, r):
            j = l
            for i in range(l + 1, r + 1):
                if nums[i] + nums[l] >= nums[l] + nums[i]:
                    j += 1
                    nums[j], nums[i] = nums[i], nums[j]
            nums[l], nums[j] = nums[j], nums[l]
            return j
        def quickSort(l, r):
            if l < r:
                m = partition(l, r)
                quickSort(l, m - 1)
                quickSort(m + 1, r)
        nums = [str(num) for num in nums]
        quickSort(0, len(nums) - 1)  
        return str(int("""".join(nums)))","auto largestNumber(auto nums) {
    def partition(l, r):
    j = l
    for i in range(l + 1, r + 1):
    if nums[i] + nums[l] >= nums[l] + nums[i]:
    j += 1
    nums[j], nums[i] = nums[i], nums[j]
    nums[l], nums[j] = nums[j], nums[l]
    return j
    def quickSort(l, r):
    if l < r:
    m = partition(l, r)
    quickSort(l, m - 1)
    quickSort(m + 1, r)
    nums = [str(num) for num in nums]
    quickSort(0, len(nums) - 1)
    return str(int("""".join(nums)))
}"
18.py,"def fourSum(self, nums, target):
        res, res_set = [], set()
        nums.sort()
        for i in range(len(nums) - 1):
            if i > 0 and nums[i] == nums[i - 1]: continue
            for j in range(i + 1, len(nums)):
                l, r = j + 1, len(nums) - 1
                while l < r:
                    sm = nums[i] + nums[j] + nums[l] + nums[r] 
                    if sm < target: l += 1
                    elif sm > target: r -= 1
                    elif (nums[i], nums[j], nums[l], nums[r]) not in res_set:
                        res.append([nums[i], nums[j], nums[l], nums[r]]); res_set.add((nums[i], nums[j], nums[l], nums[r])) 
                    else: l, r = l + 1, r - 1
        return res","auto fourSum(auto nums, auto target) {
    res, res_set = [], set()
    nums.sort()
    for i in range(len(nums) - 1):
    if i > 0 and nums[i] == nums[i - 1]: continue
    for j in range(i + 1, len(nums)):
    l, r = j + 1, len(nums) - 1
    while l < r:
    sm = nums[i] + nums[j] + nums[l] + nums[r]
    if sm < target: l += 1
    elif sm > target: r -= 1
    elif (nums[i], nums[j], nums[l], nums[r]) not in res_set:
    res.append([nums[i], nums[j], nums[l], nums[r]]); res_set.add((nums[i], nums[j], nums[l], nums[r]))
    else: l, r = l + 1, r - 1
    return res
}"
187.py,"def findRepeatedDnaSequences(self, s):
        """"""
        :type s: str
        :rtype: List[str]
        """"""
        dic, str = {}, ""x"" + s[:9]
        for i in range(9, len(s)):
            str = str[1:] + s[i]
            dic[str] = 1 if str not in dic else dic[str] + 1
        return [k for k, v in dic.items() if v > 1]","auto findRepeatedDnaSequences(auto s) {
    """"""
    :type s: str
    :rtype: List[str]
    """"""
    dic, str = {}, ""x"" + s[:9]
    for i in range(9, len(s)):
    str = str[1:] + s[i]
    dic[str] = 1 if str not in dic else dic[str] + 1
    return [k for k, v in dic.items() if v > 1]
}"
188.py,"def maxProfit(self, k, prices):
        if k >= len(prices) // 2: return sum(sell - buy for sell, buy in zip(prices[1:], prices[:-1]) if sell - buy > 0)
        dp = [[0, -float(""inf"")] for _ in range(k + 1)]
        for p in prices:
            for i in range(k + 1):
                if i and dp[i - 1][1] + p > dp[i][0]: dp[i][0] = dp[i - 1][1] + p 
                if dp[i][0] - p > dp[i][1]: dp[i][1] = dp[i][0] - p
        return dp[-1][0]","auto maxProfit(auto k, auto prices) {
    if k >= len(prices) // 2: return sum(sell - buy for sell, buy in zip(prices[1:], prices[:-1]) if sell - buy > 0)
    dp = [[0, -float(""inf"")] for _ in range(k + 1)]
    for p in prices:
    for i in range(k + 1):
    if i and dp[i - 1][1] + p > dp[i][0]: dp[i][0] = dp[i - 1][1] + p
    if dp[i][0] - p > dp[i][1]: dp[i][1] = dp[i][0] - p
    return dp[-1][0]
}"
189.py,"def rotate(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: void Do not return anything, modify nums in-place instead.
        """"""
        n=k%len(nums)
        nums[:] = nums[-n:] + nums[:-n]
        ","auto rotate(auto nums, auto k) {
    """"""
    :type nums: List[int]
    :type k: int
    :rtype: void Do not return anything, modify nums in-place instead.
    """"""
    n=k%len(nums)
    nums[:] = nums[-n:] + nums[:-n]
}"
19.py,"def removeNthFromEnd(self, head, n):
        dummy = ListNode(0)
        dummy.next = head
        arr = [dummy]
        while head:
            arr.append(head)
            head = head.next
        for _ in range(n + 1):
            pre = arr.pop()
        pre.next = pre.next.next
        return dummy.next","auto removeNthFromEnd(auto head, auto n) {
    dummy = ListNode(0)
    dummy.next = head
    arr = [dummy]
    while head:
    arr.append(head)
    head = head.next
    for _ in range(n + 1):
    pre = arr.pop()
    pre.next = pre.next.next
    return dummy.next
}"
198.py,"def rob(self, nums):
        if len(nums) <= 2: return max(nums or [0])
        nums[2] += nums[0]
        for i in range(3, len(nums)): nums[i] += max(nums[i - 2], nums[i - 3])
        return max(nums[-1], nums[-2])","auto rob(auto nums) {
    if len(nums) <= 2: return max(nums or [0])
    nums[2] += nums[0]
    for i in range(3, len(nums)): nums[i] += max(nums[i - 2], nums[i - 3])
    return max(nums[-1], nums[-2])
}"
20.py,"def isValid(self, s):
        brackets_stack, lefts, rights = [], (""("", ""["", ""{""), ("")"", ""]"", ""}"") 
        for char in s:
            if char in lefts: 
                brackets_stack.append(char)
            elif not brackets_stack or lefts.index(brackets_stack.pop()) != rights.index(char): 
                return False
        return not brackets_stack ","auto isValid(auto s) {
    brackets_stack, lefts, rights = [], (""("", ""["", ""{""), ("")"", ""]"", ""}"")
    for char in s:
    if char in lefts:
    brackets_stack.append(char)
    elif not brackets_stack or lefts.index(brackets_stack.pop()) != rights.index(char):
    return False
    return not brackets_stack
}"
200.py,"def numIslands(self, grid):
        res, n, m = 0, len(grid), len(grid[0]) if grid else 0
        def explore(i, j):
            grid[i][j] = ""-1""
            if i > 0 and grid[i - 1][j] == ""1"": explore(i - 1, j)
            if j > 0 and grid[i][j - 1] == ""1"": explore(i, j - 1)
            if i + 1 < n and grid[i + 1][j] == ""1"": explore(i + 1, j)
            if j + 1 < m and grid[i][j + 1] == ""1"": explore(i, j + 1)
        for i in range(n): 
            for j in range(m):
                if grid[i][j] == ""1"": explore(i, j); res += 1
        return res","auto numIslands(auto grid) {
    res, n, m = 0, len(grid), len(grid[0]) if grid else 0
    def explore(i, j):
    grid[i][j] = ""-1""
    if i > 0 and grid[i - 1][j] == ""1"": explore(i - 1, j)
    if j > 0 and grid[i][j - 1] == ""1"": explore(i, j - 1)
    if i + 1 < n and grid[i + 1][j] == ""1"": explore(i + 1, j)
    if j + 1 < m and grid[i][j + 1] == ""1"": explore(i, j + 1)
    for i in range(n):
    for j in range(m):
    if grid[i][j] == ""1"": explore(i, j); res += 1
    return res
}"
201.py,"def rangeBitwiseAnd(self, m, n):
        i = 0
        while m != n:
            m >>= 1
            n >>= 1
            i += 1
        return m << i","auto rangeBitwiseAnd(auto m, auto n) {
    i = 0
    while m != n:
    m >>= 1
    n >>= 1
    i += 1
    return m << i
}"
202.py,"def isHappy(self, n):
        """"""
        :type n: int
        :rtype: bool
        """"""
        mem = set()
        while n != 1:
            n = sum([int(i) ** 2 for i in str(n)])
            if n in mem: return False
            else: mem.add(n)
        else: return True","auto isHappy(auto n) {
    """"""
    :type n: int
    :rtype: bool
    """"""
    mem = set()
    while n != 1:
    n = sum([int(i) ** 2 for i in str(n)])
    if n in mem: return False
    else: mem.add(n)
    else: return True
}"
204.py,"def countPrimes(self, n):
        primes = [i for i in range(2, n)]
        for i in range(2, n):
            for prime in primes:
                if i ** (prime - 1) % prime != 1 and prime > i:
                    primes.remove(prime)
        return len(primes)
","auto countPrimes(auto n) {
    primes = [i for i in range(2, n)]
    for i in range(2, n):
    for prime in primes:
    if i ** (prime - 1) % prime != 1 and prime > i:
    primes.remove(prime)
    return len(primes)
}"
205.py,"def isIsomorphic(self, s, t):
        """"""
        :type s: str
        :type t: str
        :rtype: bool
        """"""
        if len(s) != len(t): return False
        dic={}
        for i in range(len(s)):
            if not t[i] in dic.values() and not s[i] in dic: dic[s[i]] = t[i]
            elif not s[i] in dic or dic[s[i]] != t[i]: return False
        return True","auto isIsomorphic(auto s, auto t) {
    """"""
    :type s: str
    :type t: str
    :rtype: bool
    """"""
    if len(s) != len(t): return False
    dic={}
    for i in range(len(s)):
    if not t[i] in dic.values() and not s[i] in dic: dic[s[i]] = t[i]
    elif not s[i] in dic or dic[s[i]] != t[i]: return False
    return True
}"
207.py,"def canFinish(self, numCourses, prerequisites):
        def cycle(course):
            visited[course] = 0
            for Next in route[course]:
                if visited[Next] == 0 or (visited[Next] == -1 and cycle(Next)): return True
            visited[course] = 1
            return False
        route, visited = {i: [] for i in range(numCourses)}, [-1] * numCourses 
        for req in prerequisites: route[req[1]].append(req[0])
        for course in range(numCourses):
            if visited[course] == -1 and cycle(course): return False
        return True","auto canFinish(auto numCourses, auto prerequisites) {
    def cycle(course):
    visited[course] = 0
    for Next in route[course]:
    if visited[Next] == 0 or (visited[Next] == -1 and cycle(Next)): return True
    visited[course] = 1
    return False
    route, visited = {i: [] for i in range(numCourses)}, [-1] * numCourses
    for req in prerequisites: route[req[1]].append(req[0])
    for course in range(numCourses):
    if visited[course] == -1 and cycle(course): return False
    return True
}"
209.py,"def minSubArrayLen(self, s, nums):
        l, res, curr = 0, len(nums) + 1, 0
        for r, num in enumerate(nums):
            curr += num
            while curr >= s: res, l, curr = min(res, r - l + 1), l + 1, curr - nums[l]
        return res < len(nums) + 1 and res or 0","auto minSubArrayLen(auto s, auto nums) {
    l, res, curr = 0, len(nums) + 1, 0
    for r, num in enumerate(nums):
    curr += num
    while curr >= s: res, l, curr = min(res, r - l + 1), l + 1, curr - nums[l]
    return res < len(nums) + 1 and res or 0
}"
210.py,"def findOrder(self, numCourses, prerequisites):
        children, parent = collections.defaultdict(set), collections.defaultdict(set)
        for i, j in prerequisites: children[i].add(j); parent[j].add(i)
        stack = [i for i in range(numCourses) if not children[i]]
        for i in stack:
            for j in parent[i]:
                children[j].remove(i)
                if not children[j]: stack += j,
        return stack if len(stack) == numCourses else []","auto findOrder(auto numCourses, auto prerequisites) {
    children, parent = collections.defaultdict(set), collections.defaultdict(set)
    for i, j in prerequisites: children[i].add(j); parent[j].add(i)
    stack = [i for i in range(numCourses) if not children[i]]
    for i in stack:
    for j in parent[i]:
    children[j].remove(i)
    if not children[j]: stack += j,
    return stack if len(stack) == numCourses else []
}"
212.py,"def findWords(self, board, words):
        def explore(i, j, cur):
            visited[i][j] = 0
            if ""#"" in cur and cur[""#""] not in res_set: res.append(cur[""#""]); res_set.add(cur[""#""])
            for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
                if 0 <= x < m and 0 <= y < n and board[x][y] in cur and visited[x][y] == -1: explore(x, y, trie[cur[board[x][y]]])
            visited[i][j] = -1
        trie, cnt, m, n, res, res_set = {}, 1, len(board), len(board and board[0]), [], set()
        visited, trie[0] = [[-1] * n for _ in range(m)], {}
        for w in words:
            cur = trie[0]
            for c in w:
                if c not in cur: trie[cnt], cur[c], cnt = {}, cnt, cnt + 1
                cur = trie[cur[c]]
            cur[""#""] = w
        for i in range(m):
            for j in range(n):
                if board[i][j] in trie[0]: explore(i, j, trie[trie[0][board[i][j]]])
        return res","auto findWords(auto board, auto words) {
    def explore(i, j, cur):
    visited[i][j] = 0
    if ""#"" in cur and cur[""#""] not in res_set: res.append(cur[""#""]); res_set.add(cur[""#""])
    for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
    if 0 <= x < m and 0 <= y < n and board[x][y] in cur and visited[x][y] == -1: explore(x, y, trie[cur[board[x][y]]])
    visited[i][j] = -1
    trie, cnt, m, n, res, res_set = {}, 1, len(board), len(board and board[0]), [], set()
    visited, trie[0] = [[-1] * n for _ in range(m)], {}
    for w in words:
    cur = trie[0]
    for c in w:
    if c not in cur: trie[cnt], cur[c], cnt = {}, cnt, cnt + 1
    cur = trie[cur[c]]
    cur[""#""] = w
    for i in range(m):
    for j in range(n):
    if board[i][j] in trie[0]: explore(i, j, trie[trie[0][board[i][j]]])
    return res
}"
213.py,"def dp(self, nums):
        if len(nums) <= 2: return max(nums or [0])
        nums[2] += nums[0]
        for i in range(3, len(nums)): nums[i] += max(nums[i - 2], nums[i - 3])
        return max(nums[-1], nums[-2])
    
    def rob(self, nums):
        return max(self.dp(nums[:-1]), self.dp(nums[1:])) if len(nums) != 1 else nums[0]","auto dp(auto nums) {
    if len(nums) <= 2: return max(nums or [0])
    nums[2] += nums[0]
    for i in range(3, len(nums)): nums[i] += max(nums[i - 2], nums[i - 3])
    return max(nums[-1], nums[-2])
    
    def rob(self, nums):
    return max(self.dp(nums[:-1]), self.dp(nums[1:])) if len(nums) != 1 else nums[0]
}"
214.py,"def shortestPalindrome(self, s, pre = """"):
        for i in range(1, len(s) // 2 + 2):
            if s[i - 1:].startswith(s[:i][::-1]): pre = s[2* i - 1:][::-1]
            if s[i:].startswith(s[:i][::-1]): pre = s[2* i:][::-1]
        return pre + s","auto shortestPalindrome(auto s, auto pre = """") {
    for i in range(1, len(s) // 2 + 2):
    if s[i - 1:].startswith(s[:i][::-1]): pre = s[2* i - 1:][::-1]
    if s[i:].startswith(s[:i][::-1]): pre = s[2* i:][::-1]
    return pre + s
}"
215.py,"def findKthLargest(self, nums, k):
        return heapq.nlargest(k, nums)[-1]","auto findKthLargest(auto nums, auto k) {
    return heapq.nlargest(k, nums)[-1]
}"
216.py,"def combinationSum3(self, k, n):
        """"""
        :type k: int
        :type n: int
        :rtype: List[List[int]]
        """"""
        stack, nums, res = [(0, [], 0, k)], range(1, 10), []
        while stack:
            sm, tmp, index, k_val = stack.pop(0)
            for i in range(index, len(nums)):
                if sm + nums[i] < n and k_val > 0: stack.append((sm + nums[i], tmp + [nums[i]], i + 1, k_val - 1))
                elif sm + nums[i] == n and k_val == 1: res.append(tmp + [nums[i]])
        return res","auto combinationSum3(auto k, auto n) {
    """"""
    :type k: int
    :type n: int
    :rtype: List[List[int]]
    """"""
    stack, nums, res = [(0, [], 0, k)], range(1, 10), []
    while stack:
    sm, tmp, index, k_val = stack.pop(0)
    for i in range(index, len(nums)):
    if sm + nums[i] < n and k_val > 0: stack.append((sm + nums[i], tmp + [nums[i]], i + 1, k_val - 1))
    elif sm + nums[i] == n and k_val == 1: res.append(tmp + [nums[i]])
    return res
}"
217.py,"def containsDuplicate(self, nums):
        """"""
        :type nums: List[int]
        :rtype: bool
        """"""
        dic=dict()
        for num in nums:
            if not num in dic:
                dic[num]=1
            else:
                return True
        return False","auto containsDuplicate(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: bool
    """"""
    dic=dict()
    for num in nums:
    if not num in dic:
    dic[num]=1
    else:
    return True
    return False
}"
218.py,"def getSkyline(self, buildings):
        events = sorted([(L, -H, R) for L, R, H in buildings] + list({(R, 0, None) for _, R, _ in buildings}))
        res, hp = [[0, 0]], [(0, float(""inf""))]
        for x, negH, R in events:
            while x >= hp[0][1]: 
                heapq.heappop(hp)
            if negH: 
                heapq.heappush(hp, (negH, R))
            if res[-1][1] + hp[0][0]: 
                res += [x, -hp[0][0]],
        return res[1:]","auto getSkyline(auto buildings) {
    events = sorted([(L, -H, R) for L, R, H in buildings] + list({(R, 0, None) for _, R, _ in buildings}))
    res, hp = [[0, 0]], [(0, float(""inf""))]
    for x, negH, R in events:
    while x >= hp[0][1]:
    heapq.heappop(hp)
    if negH:
    heapq.heappush(hp, (negH, R))
    if res[-1][1] + hp[0][0]:
    res += [x, -hp[0][0]],
    return res[1:]
}"
219.py,"def containsNearbyDuplicate(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: bool
        """"""
        dic={}
        for i,num in enumerate(nums):
                if num in dic and i-dic[num]<=k:
                    return True
                dic[num]=i
        return False","auto containsNearbyDuplicate(auto nums, auto k) {
    """"""
    :type nums: List[int]
    :type k: int
    :rtype: bool
    """"""
    dic={}
    for i,num in enumerate(nums):
    if num in dic and i-dic[num]<=k:
    return True
    dic[num]=i
    return False
}"
22.py,"def generateParenthesis(self, n: int) -> List[str]:
        bfs = [(0, 0, '')]
        for c in range(n * 2):
            bfs = [(l + 1, r, s + '(') for l, r, s in bfs if l + 1 <= n] + [(l, r + 1, s + ')') for l, r, s in bfs if l - r] 
        return [s for l, r, s in bfs]","auto generateParenthesis(auto n) {
    bfs = [(0, 0, '')]
    for c in range(n * 2):
    bfs = [(l + 1, r, s + '(') for l, r, s in bfs if l + 1 <= n] + [(l, r + 1, s + ')') for l, r, s in bfs if l - r]
    return [s for l, r, s in bfs]
}"
220.py,"def containsNearbyAlmostDuplicate(self, nums, k, t):
        if t < 0: return False
        d = {}
        for i in range(len(nums)):
            m = nums[i] // (t + 1)
            if m in d or (m - 1 in d and nums[i] - d[m - 1] <= t) or (m + 1 in d and d[m + 1] - nums[i] <= t):
                return True
            d[m] = nums[i]
            if i >= k: del d[nums[i - k] // (t + 1)]
        return False","auto containsNearbyAlmostDuplicate(auto nums, auto k, auto t) {
    if t < 0: return False
    d = {}
    for i in range(len(nums)):
    m = nums[i] // (t + 1)
    if m in d or (m - 1 in d and nums[i] - d[m - 1] <= t) or (m + 1 in d and d[m + 1] - nums[i] <= t):
    return True
    d[m] = nums[i]
    if i >= k: del d[nums[i - k] // (t + 1)]
    return False
}"
221.py,"def maximalSquare(self, matrix):
        """"""
        :type matrix: List[List[str]]
        :rtype: int
        """"""
        res, count = 0, 0
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                matrix[i][j] = int(matrix[i][j])
                if matrix[i][j] != 0:
                    count = 1
                    if j>0 and int(matrix[i][j-1]) != 0: matrix[i][j] += int(matrix[i][j-1])
                    if i-1>=0 and int(matrix[i-1][j]) != 0:
                        k, curr = i-1, []
                        while k>=0 and k>=i-matrix[i][j]+1 and int(matrix[k][j]) != 0:
                            if matrix[k][j]>= count+1:
                                curr.append(matrix[k][j])
                                if min(curr)>= count+1: count += 1
                            else: break
                            k -= 1
                res = max(res, count**2)
        return res","auto maximalSquare(auto matrix) {
    """"""
    :type matrix: List[List[str]]
    :rtype: int
    """"""
    res, count = 0, 0
    for i in range(len(matrix)):
    for j in range(len(matrix[0])):
    matrix[i][j] = int(matrix[i][j])
    if matrix[i][j] != 0:
    count = 1
    if j>0 and int(matrix[i][j-1]) != 0: matrix[i][j] += int(matrix[i][j-1])
    if i-1>=0 and int(matrix[i-1][j]) != 0:
    k, curr = i-1, []
    while k>=0 and k>=i-matrix[i][j]+1 and int(matrix[k][j]) != 0:
    if matrix[k][j]>= count+1:
    curr.append(matrix[k][j])
    if min(curr)>= count+1: count += 1
    else: break
    k -= 1
    res = max(res, count**2)
    return res
}"
222.py,"def countNodes(self, root):
        if not root: return 0
        l = self.getDepth(root.left)
        r = self.getDepth(root.right)
        if l == r:
            return (1 << l) + self.countNodes(root.right)
        return (1 << r) + self.countNodes(root.left)
    
    def getDepth(self, root):
        if not root: return 0
        return 1 + self.getDepth(root.left)","auto countNodes(auto root) {
    if not root: return 0
    l = self.getDepth(root.left)
    r = self.getDepth(root.right)
    if l == r:
    return (1 << l) + self.countNodes(root.right)
    return (1 << r) + self.countNodes(root.left)
    
    def getDepth(self, root):
    if not root: return 0
    return 1 + self.getDepth(root.left)
}"
223.py,"def computeArea(self, a, b, c, d, e, f, g, h):
        x1, x2, x3 = abs(a - c), abs(e - g), max(a, c, e, g) - min(a, c, e, g) 
        y1, y2, y3 = abs(b - d), abs(f - h), max(b, d, f, h) - min(b, d, f, h)
        if x3 < x1 + x2 and y3 < y1 + y2: intrs = (x1 + x2 - x3) * (y1 + y2 - y3) 
        else: intrs = 0
        return x1 * y1 + x2 * y2 - intrs","auto computeArea(auto a, auto b, auto c, auto d, auto e, auto f, auto g, auto h) {
    x1, x2, x3 = abs(a - c), abs(e - g), max(a, c, e, g) - min(a, c, e, g)
    y1, y2, y3 = abs(b - d), abs(f - h), max(b, d, f, h) - min(b, d, f, h)
    if x3 < x1 + x2 and y3 < y1 + y2: intrs = (x1 + x2 - x3) * (y1 + y2 - y3)
    else: intrs = 0
    return x1 * y1 + x2 * y2 - intrs
}"
224.py,"def calculate(self, s):
        def calc(n2, op, n1): 
            return n1 + n2 if op == ""+"" else n1 - n2
        stack, i, num = [], 0, 0
        while i < len(s):
            j = i
            while j < len(s) and s[j].isdigit():
                num, j = num * 10 + int(s[j]), j + 1
            if i != j:
                stack.append(calc(num, stack.pop(), stack.pop()) if stack and s[i - 1] != ""("" else num)
                num, j = 0, j - 1
            elif s[i] in ""+-"":
                stack.append(s[i])
            elif s[i] == "")"" and len(stack) > 1:
                stack.append(calc(stack.pop(), stack.pop(), stack.pop()))
            i = j + 1
        return stack.pop()","auto calculate(auto s) {
    def calc(n2, op, n1):
    return n1 + n2 if op == ""+"" else n1 - n2
    stack, i, num = [], 0, 0
    while i < len(s):
    j = i
    while j < len(s) and s[j].isdigit():
    num, j = num * 10 + int(s[j]), j + 1
    if i != j:
    stack.append(calc(num, stack.pop(), stack.pop()) if stack and s[i - 1] != ""("" else num)
    num, j = 0, j - 1
    elif s[i] in ""+-"":
    stack.append(s[i])
    elif s[i] == "")"" and len(stack) > 1:
    stack.append(calc(stack.pop(), stack.pop(), stack.pop()))
    i = j + 1
    return stack.pop()
}"
227.py,"def calculate(self, s):
        mod = 0
        while mod < 2:
            stack, i, n, num = [], 0, len(s), """"
            while i < n:
                if s[i] == "" "":
                    i += 1
                    continue
                while mod == 0 and i < n and s[i].isnumeric():
                    num += s[i]
                    i += 1
                if stack and stack[-1] in [(""*"", ""/""), (""+"", ""-"")][mod]:
                    op, num1 = stack.pop(), stack.pop()
                    if op == ""*"":
                        stack.append(num1 * int(num))
                    elif op == ""/"":
                        stack.append(num1 // int(num))
                    elif op == ""+"":
                        stack.append(num1 + s[i])
                        i += 1
                    else:
                        stack.append(num1 - s[i])
                        i += 1
                    num = """"
                elif num:
                    stack.append(int(num))
                    num = """"
                else:
                    stack.append(s[i])
                    i += 1
            mod += 1
            s = stack
        return stack.pop()","auto calculate(auto s) {
    mod = 0
    while mod < 2:
    stack, i, n, num = [], 0, len(s), """"
    while i < n:
    if s[i] == "" "":
    i += 1
    continue
    while mod == 0 and i < n and s[i].isnumeric():
    num += s[i]
    i += 1
    if stack and stack[-1] in [(""*"", ""/""), (""+"", ""-"")][mod]:
    op, num1 = stack.pop(), stack.pop()
    if op == ""*"":
    stack.append(num1 * int(num))
    elif op == ""/"":
    stack.append(num1 // int(num))
    elif op == ""+"":
    stack.append(num1 + s[i])
    i += 1
    else:
    stack.append(num1 - s[i])
    i += 1
    num = """"
    elif num:
    stack.append(int(num))
    num = """"
    else:
    stack.append(s[i])
    i += 1
    mod += 1
    s = stack
    return stack.pop()
}"
228.py,"def summaryRanges(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[str]
        """"""
        res, stack = [], [nums[0] if nums else None, None]
        for i, num in enumerate(nums):
            if i > 0 and nums[i - 1] == num - 1: stack[1] = num
            if i > 0 and nums[i-1] != num - 1: res, stack[0], stack[1] = res + [""->"".join(str(q) for q in stack if q != None)], num, None
            if i == len(nums) - 1: res.append(""->"".join(str(q) for q in stack if q != None))
        return res","auto summaryRanges(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: List[str]
    """"""
    res, stack = [], [nums[0] if nums else None, None]
    for i, num in enumerate(nums):
    if i > 0 and nums[i - 1] == num - 1: stack[1] = num
    if i > 0 and nums[i-1] != num - 1: res, stack[0], stack[1] = res + [""->"".join(str(q) for q in stack if q != None)], num, None
    if i == len(nums) - 1: res.append(""->"".join(str(q) for q in stack if q != None))
    return res
}"
229.py,"def majorityElement(self, nums):
        c1, c2, cnt1, cnt2 = 0, 1, 0, 0
        for num in nums:
            if num == c1:
                cnt1 += 1
            elif num == c2:
                cnt2 += 1
            elif not cnt1:
                c1, cnt1 = num, 1
            elif not cnt2:
                c2, cnt2 = num, 1
            else:
                cnt1 -= 1
                cnt2 -= 1
        return [c for c in (c1, c2) if nums.count(c) > len(nums) // 3]","auto majorityElement(auto nums) {
    c1, c2, cnt1, cnt2 = 0, 1, 0, 0
    for num in nums:
    if num == c1:
    cnt1 += 1
    elif num == c2:
    cnt2 += 1
    elif not cnt1:
    c1, cnt1 = num, 1
    elif not cnt2:
    c2, cnt2 = num, 1
    else:
    cnt1 -= 1
    cnt2 -= 1
    return [c for c in (c1, c2) if nums.count(c) > len(nums) // 3]
}"
231.py,"def isPowerOfTwo(self, n):
        """"""
        :type n: int
        :rtype: bool
        """"""
        i=0
        while 2**i<=n:
            if 2**i==n: return True
            i+=1
        return False","auto isPowerOfTwo(auto n) {
    """"""
    :type n: int
    :rtype: bool
    """"""
    i=0
    while 2**i<=n:
    if 2**i==n: return True
    i+=1
    return False
}"
233.py,"def countDigitOne(self, n):
        if n <= 0:
            return 0
        q, x, ans = n, 1, 0
        while q > 0:
            digit = q % 10
            q //= 10
            ans += q * x
            if digit == 1:
                ans += n % x + 1
            elif digit > 1:
                ans += x
            x *= 10
        return ans","auto countDigitOne(auto n) {
    if n <= 0:
    return 0
    q, x, ans = n, 1, 0
    while q > 0:
    digit = q % 10
    q //= 10
    ans += q * x
    if digit == 1:
    ans += n % x + 1
    elif digit > 1:
    ans += x
    x *= 10
    return ans
}"
234.py,"def isPalindrome(self, head):
        r = fast = head
        l = None
        while fast and fast.next:
            fast = fast.next.next
            r.next, l, r = l, r, r.next
        if fast: r = r.next
        while l and r and l.val == r.val:
            l, r = l.next, r.next
        return not l","auto isPalindrome(auto head) {
    r = fast = head
    l = None
    while fast and fast.next:
    fast = fast.next.next
    r.next, l, r = l, r, r.next
    if fast: r = r.next
    while l and r and l.val == r.val:
    l, r = l.next, r.next
    return not l
}"
238.py,"def productExceptSelf(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        m, res = 1, []
        for i in range(len(nums)):
            res.append(m)
            m *= nums[i]
        m = 1
        for i in range(len(nums)-1,-1,-1):
            res[i] *= m
            m *= nums[i]
        return res","auto productExceptSelf(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: List[int]
    """"""
    m, res = 1, []
    for i in range(len(nums)):
    res.append(m)
    m *= nums[i]
    m = 1
    for i in range(len(nums)-1,-1,-1):
    res[i] *= m
    m *= nums[i]
    return res
}"
239.py,"def maxSlidingWindow(self, nums, k):
        cnt, heap, res = collections.Counter(), [], []
        for i, num in enumerate(nums):
            heapq.heappush(heap, -num)
            cnt[num] += 1
            while not cnt[-heap[0]]:
                heapq.heappop(heap)
            if i >= k - 1:
                res.append(-heap[0])
                cnt[nums[i - k + 1]] -= 1
        return res","auto maxSlidingWindow(auto nums, auto k) {
    cnt, heap, res = collections.Counter(), [], []
    for i, num in enumerate(nums):
    heapq.heappush(heap, -num)
    cnt[num] += 1
    while not cnt[-heap[0]]:
    heapq.heappop(heap)
    if i >= k - 1:
    res.append(-heap[0])
    cnt[nums[i - k + 1]] -= 1
    return res
}"
240.py,"def searchMatrix(self, matrix, target):
        return any(target in row for row in matrix)","auto searchMatrix(auto matrix, auto target) {
    return any(target in row for row in matrix)
}"
241.py,"def diffWaysToCompute(self, input):
        if input.isdigit():
            return [int(input)]
        res = []
        for i in range(len(input)):
            if input[i] in ""-+*"":
                l = self.diffWaysToCompute(input[:i])
                r = self.diffWaysToCompute(input[i + 1:])
                for j in l:
                    for k in r:
                        res.append(self.calc(j, input[i], k))
        return res
    def calc(self, l, op, r):
        return l + r if op == ""+"" else l - r if op == ""-"" else l * r","auto diffWaysToCompute(auto input) {
    if input.isdigit():
    return [int(input)]
    res = []
    for i in range(len(input)):
    if input[i] in ""-+*"":
    l = self.diffWaysToCompute(input[:i])
    r = self.diffWaysToCompute(input[i + 1:])
    for j in l:
    for k in r:
    res.append(self.calc(j, input[i], k))
    return res
    def calc(self, l, op, r):
    return l + r if op == ""+"" else l - r if op == ""-"" else l * r
}"
242.py,"def isAnagram(self, s, t):
        """"""
        :type s: str
        :type t: str
        :rtype: bool
        """"""
        #return sum([ord(i) for i in s])==sum([ord(j) for j in t]) and set(s)==set(t)
        return sorted(s)==sorted(t)","auto isAnagram(auto s, auto t) {
    """"""
    :type s: str
    :type t: str
    :rtype: bool
    """"""
    #return sum([ord(i) for i in s])==sum([ord(j) for j in t]) and set(s)==set(t)
    return sorted(s)==sorted(t)
}"
243.py,"def shortestDistance(self, words, word1, word2):
        i1, i2, mn = -1, -1, float(""inf"")
        for i, w in enumerate(words):
            if w == word1:
                i1 = i
                if i2 >= 0:
                    mn = min(mn, i - i2)
            elif w == word2:
                i2 = i
                if i1 >= 0:
                    mn = min(mn, i - i1)
        return mn","auto shortestDistance(auto words, auto word1, auto word2) {
    i1, i2, mn = -1, -1, float(""inf"")
    for i, w in enumerate(words):
    if w == word1:
    i1 = i
    if i2 >= 0:
    mn = min(mn, i - i2)
    elif w == word2:
    i2 = i
    if i1 >= 0:
    mn = min(mn, i - i1)
    return mn
}"
245.py,"def shortestWordDistance(self, words, word1, word2):
        i1 = i2 = -1
        res, same = float(""inf""), word1 == word2
        for i, w in enumerate(words):
            if w == word1:
                if same: i2 = i1
                i1 = i
                if i2 >= 0: res = min(res, i1 - i2)
            elif w == word2:
                i2 = i
                if i1 >= 0: res = min(res, i2 - i1)
        return res ","auto shortestWordDistance(auto words, auto word1, auto word2) {
    i1 = i2 = -1
    res, same = float(""inf""), word1 == word2
    for i, w in enumerate(words):
    if w == word1:
    if same: i2 = i1
    i1 = i
    if i2 >= 0: res = min(res, i1 - i2)
    elif w == word2:
    i2 = i
    if i1 >= 0: res = min(res, i2 - i1)
    return res
}"
246.py,"def isStrobogrammatic(self, num):
        return not any(num[i] + num[-1-i] not in (""88"", ""69"", ""96"", ""11"", ""00"") for i in range((len(num) + 1) // 2))","auto isStrobogrammatic(auto num) {
    return not any(num[i] + num[-1-i] not in (""88"", ""69"", ""96"", ""11"", ""00"") for i in range((len(num) + 1) // 2))
}"
247.py,"def findStrobogrammatic(self, n, q = [""""]):
        for i in range(n // 2): q = [s + c for s in q  for c in ""01689"" if i != 0 or c != ""0""]
        if n % 2: q = [s + c for s in q for c in ""018""]
        for i in range(n // 2 - 1, -1, -1):  q = [s + ""9"" if s[i] == ""6"" else s + ""6"" if s[i] == ""9"" else s + s[i] for s in q]
        return q","auto findStrobogrammatic(auto n, auto q = [""""]) {
    for i in range(n // 2): q = [s + c for s in q  for c in ""01689"" if i != 0 or c != ""0""]
    if n % 2: q = [s + c for s in q for c in ""018""]
    for i in range(n // 2 - 1, -1, -1):  q = [s + ""9"" if s[i] == ""6"" else s + ""6"" if s[i] == ""9"" else s + s[i] for s in q]
    return q
}"
248.py,"def strobogrammaticInRange(self, low, high):
        q, cnt, low, high, ln = ["""", ""0"", ""1"", ""8""], 0, int(low), int(high), len(high)
        while q:
            s = q.pop()
            if s and s[0] != ""0"" and low <= int(s) <= high: cnt += 1
            q += [l + s + r for l, r in ((""8"", ""8""), (""6"", ""9""), (""9"", ""6""), (""1"", ""1""), (""0"", ""0"")) if len(s) <= ln - 2] 
        return cnt if low != 0 else cnt + 1","auto strobogrammaticInRange(auto low, auto high) {
    q, cnt, low, high, ln = ["""", ""0"", ""1"", ""8""], 0, int(low), int(high), len(high)
    while q:
    s = q.pop()
    if s and s[0] != ""0"" and low <= int(s) <= high: cnt += 1
    q += [l + s + r for l, r in ((""8"", ""8""), (""6"", ""9""), (""9"", ""6""), (""1"", ""1""), (""0"", ""0"")) if len(s) <= ln - 2]
    return cnt if low != 0 else cnt + 1
}"
249.py,"def groupStrings(self, strings):
        """"""
        :type strings: List[str]
        :rtype: List[List[str]]
        """"""
        table = collections.defaultdict(list)
        for w in strings:
            pattern = """"
            for i in range(1, len(w)):
                if ord(w[i]) - ord(w[i - 1]) >= 0:
                    pattern += str(ord(w[i]) - ord(w[i - 1]))
                else:
                    pattern += str(ord(w[i]) - ord(w[i - 1]) + 26)
            table[pattern].append(w)
        return [table[pattern] for pattern in table]","auto groupStrings(auto strings) {
    """"""
    :type strings: List[str]
    :rtype: List[List[str]]
    """"""
    table = collections.defaultdict(list)
    for w in strings:
    pattern = """"
    for i in range(1, len(w)):
    if ord(w[i]) - ord(w[i - 1]) >= 0:
    pattern += str(ord(w[i]) - ord(w[i - 1]))
    else:
    pattern += str(ord(w[i]) - ord(w[i - 1]) + 26)
    table[pattern].append(w)
    return [table[pattern] for pattern in table]
}"
254.py,"def getFactors(self, n):
        factors = set()
        for i in range(2, int(n ** 0.5) + 1):
            if n % i == 0:
                factors |= {i, n // i}
        q, res = [[f, [f]] for f in factors], []
        while q:
            new = []
            for sm, arr in q:
                for f in factors:
                    if f >= arr[-1]:
                        if sm * f < n:
                            new.append([sm * f, arr + [f]])
                        elif sm * f == n:
                            res.append(arr + [f])
            q = new
        return res","auto getFactors(auto n) {
    factors = set()
    for i in range(2, int(n ** 0.5) + 1):
    if n % i == 0:
    factors |= {i, n // i}
    q, res = [[f, [f]] for f in factors], []
    while q:
    new = []
    for sm, arr in q:
    for f in factors:
    if f >= arr[-1]:
    if sm * f < n:
    new.append([sm * f, arr + [f]])
    elif sm * f == n:
    res.append(arr + [f])
    q = new
    return res
}"
255.py,"def verifyPreorder(self, preorder):
        stack, lower = [], -float(""inf"")
        for x in preorder:
            if x < lower: return False
            while stack and x > stack[-1]: lower = stack.pop()
            stack.append(x)
        return True","auto verifyPreorder(auto preorder) {
    stack, lower = [], -float(""inf"")
    for x in preorder:
    if x < lower: return False
    while stack and x > stack[-1]: lower = stack.pop()
    stack.append(x)
    return True
}"
256.py,"def minCost(self, costs: List[List[int]]) -> int:
        dp = [0] * 3
        for a, b, c in costs:
            c1 = min(dp[1], dp[2]) + a
            c2 = min(dp[0], dp[2]) + b
            c3 = min(dp[0], dp[1]) + c
            dp = [c1, c2, c3]
        return min(dp)","auto minCost(auto costs) {
    dp = [0] * 3
    for a, b, c in costs:
    c1 = min(dp[1], dp[2]) + a
    c2 = min(dp[0], dp[2]) + b
    c3 = min(dp[0], dp[1]) + c
    dp = [c1, c2, c3]
    return min(dp)
}"
258.py,"def addDigits(self, num):
        """"""
        :type num: int
        :rtype: int
        """"""
        num=str(num)
        while len(num)>1:
            num=str(sum([int(i) for i in num]))
        return int(num)","auto addDigits(auto num) {
    """"""
    :type num: int
    :rtype: int
    """"""
    num=str(num)
    while len(num)>1:
    num=str(sum([int(i) for i in num]))
    return int(num)
}"
259.py,"def threeSumSmaller(self, nums, target):
        nums.sort()
        res = 0
        for i in range(len(nums) - 2):
            r = len(nums) - 1
            for j in range(i + 1, len(nums) - 1):
                while r > j + 1 and nums[i] + nums[j] + nums[r] >= target:
                    r -= 1
                if nums[i] + nums[j] + nums[r] < target:
                    res += r - j
        return res","auto threeSumSmaller(auto nums, auto target) {
    nums.sort()
    res = 0
    for i in range(len(nums) - 2):
    r = len(nums) - 1
    for j in range(i + 1, len(nums) - 1):
    while r > j + 1 and nums[i] + nums[j] + nums[r] >= target:
    r -= 1
    if nums[i] + nums[j] + nums[r] < target:
    res += r - j
    return res
}"
26.py,"def removeDuplicates(self, nums):
        n = len(nums)
        return n - len([nums.pop(i) for i in range(n -1, 0, -1) if nums[i] == nums[i - 1]])","auto removeDuplicates(auto nums) {
    n = len(nums)
    return n - len([nums.pop(i) for i in range(n -1, 0, -1) if nums[i] == nums[i - 1]])
}"
260.py,"def singleNumber(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        return [n[0] for n in collections.Counter(nums).most_common()[-2:]]","auto singleNumber(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: List[int]
    """"""
    return [n[0] for n in collections.Counter(nums).most_common()[-2:]]
}"
261.py,"def validTree(self, n, edges):
        visited, adj = [0] * n, collections.defaultdict(set)
        for a, b in edges:
            adj[a].add(b)
            adj[b].add(a)
        def dfs(i, pre):
            visited[i] = 1
            for v in adj[i]:
                if v != pre and (visited[v] or not dfs(v, i)):
                    return False
            return True
        return dfs(0, -1) and sum(visited) == n","auto validTree(auto n, auto edges) {
    visited, adj = [0] * n, collections.defaultdict(set)
    for a, b in edges:
    adj[a].add(b)
    adj[b].add(a)
    def dfs(i, pre):
    visited[i] = 1
    for v in adj[i]:
    if v != pre and (visited[v] or not dfs(v, i)):
    return False
    return True
    return dfs(0, -1) and sum(visited) == n
}"
263.py,"def isUgly(self, num):
        """"""
        :type num: int
        :rtype: bool
        """"""
        while num>1:
            if num%2!=0 and num%3!=0 and num%5!=0: return False
            else: num/=[i for i in (2,3,5) if num%i==0][-1]
        return num==1","auto isUgly(auto num) {
    """"""
    :type num: int
    :rtype: bool
    """"""
    while num>1:
    if num%2!=0 and num%3!=0 and num%5!=0: return False
    else: num/=[i for i in (2,3,5) if num%i==0][-1]
    return num==1
}"
264.py,"def nthUglyNumber(self, n):
        arr, heap, used = [], [1], set()
        for i in range(n):
            num = heapq.heappop(heap)
            arr.append(num)
            for p in (2, 3, 5):
                if p * num not in used:
                    heapq.heappush(heap, p * num)
                    used.add(p * num)
        return arr[-1]","auto nthUglyNumber(auto n) {
    arr, heap, used = [], [1], set()
    for i in range(n):
    num = heapq.heappop(heap)
    arr.append(num)
    for p in (2, 3, 5):
    if p * num not in used:
    heapq.heappush(heap, p * num)
    used.add(p * num)
    return arr[-1]
}"
265.py,"def minCostII(self, costs):
        for i in range(1, len(costs)):
            for j in range(len(costs[0])): costs[i][j] += min(costs[i - 1][:j] + costs[i - 1][j + 1:])
        return costs and min(costs[-1]) or 0","auto minCostII(auto costs) {
    for i in range(1, len(costs)):
    for j in range(len(costs[0])): costs[i][j] += min(costs[i - 1][:j] + costs[i - 1][j + 1:])
    return costs and min(costs[-1]) or 0
}"
266.py,"def canPermutePalindrome(self, s):
        cnt = collections.Counter(s)
        return len([c for c in cnt if cnt[c] % 2]) <= 1","auto canPermutePalindrome(auto s) {
    cnt = collections.Counter(s)
    return len([c for c in cnt if cnt[c] % 2]) <= 1
}"
267.py,"def generatePalindromes(self, s):
        cnt, n = collections.Counter(s), len(s) // 2
        odd, s, q = [c for c in cnt if cnt[c] % 2], """".join(k * (cnt[k] // 2) for k in cnt), {""#"" * n}
        if len(odd) > 1: return []
        for c in s:
            new = set()
            for w in q:
                for i in range(n):
                    if w[i] == ""#"":
                        new.add(w[:i] + c + w[i + 1:])
            q = new
        return [w + odd[0] + w[::-1] for w in q] if odd else [w + w[::-1] for w in q]","auto generatePalindromes(auto s) {
    cnt, n = collections.Counter(s), len(s) // 2
    odd, s, q = [c for c in cnt if cnt[c] % 2], """".join(k * (cnt[k] // 2) for k in cnt), {""#"" * n}
    if len(odd) > 1: return []
    for c in s:
    new = set()
    for w in q:
    for i in range(n):
    if w[i] == ""#"":
    new.add(w[:i] + c + w[i + 1:])
    q = new
    return [w + odd[0] + w[::-1] for w in q] if odd else [w + w[::-1] for w in q]
}"
268.py,"def missingNumber(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        return len(nums)*(len(nums)+1)//2-sum(nums)","auto missingNumber(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: int
    """"""
    return len(nums)*(len(nums)+1)//2-sum(nums)
}"
27.py,"def removeElement(self, nums: List[int], val: int) -> int:
        i = 0
        for num in nums:
            if num != val:
                nums[i] = num
                i += 1
        return i","auto removeElement(auto nums, auto val) {
    i = 0
    for num in nums:
    if num != val:
    nums[i] = num
    i += 1
    return i
}"
273.py,"def __init__(self):
        self.lessThan20 = ["""",""One"",""Two"",""Three"",""Four"",""Five"",""Six"",""Seven"",""Eight"",""Nine"",""Ten"",""Eleven"",""Twelve"",""Thirteen"",""Fourteen"",""Fifteen"",""Sixteen"",""Seventeen"",""Eighteen"",""Nineteen""]
        self.tens = ["""",""Ten"",""Twenty"",""Thirty"",""Forty"",""Fifty"",""Sixty"",""Seventy"",""Eighty"",""Ninety""]
        self.thousands = ["""",""Thousand"",""Million"",""Billion""]

    def numberToWords(self, num):
        if not num:
            return ""Zero""
        res = """"
        for thousand in self.thousands:
            if num % 1000:
                res = self.helper(num%1000) + thousand + "" "" + res
            num //= 1000
        return res.strip()

    def helper(self, num):
        if not num:
            return """"
        elif num < 20:
            return self.lessThan20[num] + "" ""
        elif num < 100:
            return self.tens[num//10] + "" "" + self.helper(num%10)
        else:
            return self.lessThan20[num//100] + "" Hundred "" + self.helper(num%100)","auto __init__() {
    self.lessThan20 = ["""",""One"",""Two"",""Three"",""Four"",""Five"",""Six"",""Seven"",""Eight"",""Nine"",""Ten"",""Eleven"",""Twelve"",""Thirteen"",""Fourteen"",""Fifteen"",""Sixteen"",""Seventeen"",""Eighteen"",""Nineteen""]
    self.tens = ["""",""Ten"",""Twenty"",""Thirty"",""Forty"",""Fifty"",""Sixty"",""Seventy"",""Eighty"",""Ninety""]
    self.thousands = ["""",""Thousand"",""Million"",""Billion""]
    
    def numberToWords(self, num):
    if not num:
    return ""Zero""
    res = """"
    for thousand in self.thousands:
    if num % 1000:
    res = self.helper(num%1000) + thousand + "" "" + res
    num //= 1000
    return res.strip()
    
    def helper(self, num):
    if not num:
    return """"
    elif num < 20:
    return self.lessThan20[num] + "" ""
    elif num < 100:
    return self.tens[num//10] + "" "" + self.helper(num%10)
    else:
    return self.lessThan20[num//100] + "" Hundred "" + self.helper(num%100)
}"
274.py,"def hIndex(self, citations):
        citations.sort()
        for i in range(len(citations)):
            if len(citations) - i <= citations[i]: return len(citations) - i
        return 0","auto hIndex(auto citations) {
    citations.sort()
    for i in range(len(citations)):
    if len(citations) - i <= citations[i]: return len(citations) - i
    return 0
}"
275.py,"def hIndex(self, citations):
        l, r, res = 0, len(citations) - 1, 0
        while l <= r:
            mid = (l + r) // 2
            if len(citations) - mid <= citations[mid]: res, r = len(citations) - mid, r - 1
            else: l = mid + 1
        return res","auto hIndex(auto citations) {
    l, r, res = 0, len(citations) - 1, 0
    while l <= r:
    mid = (l + r) // 2
    if len(citations) - mid <= citations[mid]: res, r = len(citations) - mid, r - 1
    else: l = mid + 1
    return res
}"
276.py,"def numWays(self, n, k):
        same, dif = 0, k
        for _ in range(1, n): same, dif = dif, (same + dif) * (k - 1)
        return n and same + dif or 0","auto numWays(auto n, auto k) {
    same, dif = 0, k
    for _ in range(1, n): same, dif = dif, (same + dif) * (k - 1)
    return n and same + dif or 0
}"
279.py,"def numSquares(self, n):
        q, move = {i ** 2 for i in range(1, int(n ** 0.5) + 1)}, 1
        coins = set(q)
        while q:
            if n in q: return move
            q = {sm + c for sm in q for c in coins} - q
            move += 1","auto numSquares(auto n) {
    q, move = {i ** 2 for i in range(1, int(n ** 0.5) + 1)}, 1
    coins = set(q)
    while q:
    if n in q: return move
    q = {sm + c for sm in q for c in coins} - q
    move += 1
}"
28.py,"def strStr(self, haystack, needle):
        return haystack.find(needle)","auto strStr(auto haystack, auto needle) {
    return haystack.find(needle)
}"
282.py,"def addOperators(self, num, target):
        """"""
        :type num: str
        :type target: int
        :rtype: List[str]
        """"""
        # s, val, cur, coeff
        q = {("""", 0, 0, 1)}
        for i, c in enumerate(num):
            new = set()
            for s, val, cur, coeff in q:
                if i:
                    new.add((s + ""+"" + c, val + int(c), int(c), 1))
                    new.add((s + ""-"" + c, val - int(c), int(c), -1))
                    new.add((s + ""*"" + c, val + cur * coeff * (int(c) - 1), int(c), cur * coeff))
                if s and s[-1] == ""0"" and cur == 0: continue
                pre = cur
                cur = cur * 10 + int(c)
                new.add((s + c, val + coeff * (cur - pre), cur, coeff))
            q = new
        return [s for s, val, cur, coeff in q if val == target]","auto addOperators(auto num, auto target) {
    """"""
    :type num: str
    :type target: int
    :rtype: List[str]
    """"""
    # s, val, cur, coeff
    q = {("""", 0, 0, 1)}
    for i, c in enumerate(num):
    new = set()
    for s, val, cur, coeff in q:
    if i:
    new.add((s + ""+"" + c, val + int(c), int(c), 1))
    new.add((s + ""-"" + c, val - int(c), int(c), -1))
    new.add((s + ""*"" + c, val + cur * coeff * (int(c) - 1), int(c), cur * coeff))
    if s and s[-1] == ""0"" and cur == 0: continue
    pre = cur
    cur = cur * 10 + int(c)
    new.add((s + c, val + coeff * (cur - pre), cur, coeff))
    q = new
    return [s for s, val, cur, coeff in q if val == target]
}"
283.py,"def moveZeroes(self, nums):
        """"""
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """"""
        i, items=0, 0
        while i<len(nums) and items<=len(nums):
            if nums[i]==0: nums.append(0); nums.pop(i); i-=1
            i+=1; items+=1","auto moveZeroes(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: void Do not return anything, modify nums in-place instead.
    """"""
    i, items=0, 0
    while i<len(nums) and items<=len(nums):
    if nums[i]==0: nums.append(0); nums.pop(i); i-=1
    i+=1; items+=1
}"
287.py,"def findDuplicate(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        low, high, mid = 0, len(nums)-1, len(nums)-1 // 2
        while high - low > 1:
            count, mid = 0, (high + low) // 2
            for k in nums:
                if mid < k <= high: count += 1
            if count > high - mid: low = mid
            else: high = mid
        return high","auto findDuplicate(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: int
    """"""
    low, high, mid = 0, len(nums)-1, len(nums)-1 // 2
    while high - low > 1:
    count, mid = 0, (high + low) // 2
    for k in nums:
    if mid < k <= high: count += 1
    if count > high - mid: low = mid
    else: high = mid
    return high
}"
29.py,"def divide(self, dividend, divisor):
        """"""
        :type dividend: int
        :type divisor: int
        :rtype: int
        """"""
        positive = (dividend < 0) is (divisor < 0)
        dividend, divisor, res = abs(dividend), abs(divisor), 0
        while dividend >= divisor:
            temp, i = divisor, 1
            while dividend >= temp:
                dividend -= temp
                res += i
                i <<= 1
                temp <<= 1
        if not positive: res = -res
        return min(max(-2 ** 31, res), 2 ** 31 - 1)","auto divide(auto dividend, auto divisor) {
    """"""
    :type dividend: int
    :type divisor: int
    :rtype: int
    """"""
    positive = (dividend < 0) is (divisor < 0)
    dividend, divisor, res = abs(dividend), abs(divisor), 0
    while dividend >= divisor:
    temp, i = divisor, 1
    while dividend >= temp:
    dividend -= temp
    res += i
    i <<= 1
    temp <<= 1
    if not positive: res = -res
    return min(max(-2 ** 31, res), 2 ** 31 - 1)
}"
290.py,"def wordPattern(self, pattern, str):
        """"""
        :type pattern: str
        :type str: str
        :rtype: bool
        """"""
        if len(str.split())!=len(pattern): return False
        dic={}
        for word in str.split():
            if not pattern[0] in dic.values() and not word in dic: dic[word]=pattern[0]
            else:
                if not word in dic or dic[word]!=pattern[0]: return False
            pattern=pattern[1:]
        return True
        ","auto wordPattern(auto pattern, auto str) {
    """"""
    :type pattern: str
    :type str: str
    :rtype: bool
    """"""
    if len(str.split())!=len(pattern): return False
    dic={}
    for word in str.split():
    if not pattern[0] in dic.values() and not word in dic: dic[word]=pattern[0]
    else:
    if not word in dic or dic[word]!=pattern[0]: return False
    pattern=pattern[1:]
    return True
}"
291.py,"def wordPatternMatch(self, pattern, s):
        m, n = len(pattern), len(s)
        def dfs(i, j, dic, used):
            if i >= m or j >= n:
                return i == m and j == n
            elif pattern[i] in dic:
                return s[j:j + len(dic[pattern[i]])] == dic[pattern[i]] and dfs(i + 1, j + len(dic[pattern[i]]), dic, used)
            else:
                for k in range(j + 1, n + 1):
                    if s[j:k] not in used:
                        dic[pattern[i]] = s[j:k]
                        if dfs(i + 1, j + len(dic[pattern[i]]), dic, used | {s[j:k]}):
                            return True
                        dic.pop(pattern[i])
                return False
        return dfs(0, 0, {}, set())","auto wordPatternMatch(auto pattern, auto s) {
    m, n = len(pattern), len(s)
    def dfs(i, j, dic, used):
    if i >= m or j >= n:
    return i == m and j == n
    elif pattern[i] in dic:
    return s[j:j + len(dic[pattern[i]])] == dic[pattern[i]] and dfs(i + 1, j + len(dic[pattern[i]]), dic, used)
    else:
    for k in range(j + 1, n + 1):
    if s[j:k] not in used:
    dic[pattern[i]] = s[j:k]
    if dfs(i + 1, j + len(dic[pattern[i]]), dic, used | {s[j:k]}):
    return True
    dic.pop(pattern[i])
    return False
    return dfs(0, 0, {}, set())
}"
292.py,"def canWinNim(self, n):
        """"""
        :type n: int
        :rtype: bool
        """"""
        return False if n%4==0 else True","auto canWinNim(auto n) {
    """"""
    :type n: int
    :rtype: bool
    """"""
    return False if n%4==0 else True
}"
293.py,"def generatePossibleNextMoves(self, s):
        return [s[:i] + ""--"" + s[i + 2:] for i in range(len(s) - 1) if s[i] == s[i + 1] == ""+""]","auto generatePossibleNextMoves(auto s) {
    return [s[:i] + ""--"" + s[i + 2:] for i in range(len(s) - 1) if s[i] == s[i + 1] == ""+""]
}"
294.py,"def canWin(self, s):
        choices = {i for i in range(1, len(s)) if s[i] == s[i - 1] == ""+""} 
        def dfs(arr, moves, turn):
            if not moves:
                return turn == 1
            elif turn:
                return all(dfs(arr + [m], moves - {m - 1, m, m + 1}, 1 - turn) for m in moves) 
            else:
                return any(dfs(arr + [m], moves - {m - 1, m, m + 1}, 1 - turn) for m in moves) 
        return not dfs([], choices, 1)     ","auto canWin(auto s) {
    choices = {i for i in range(1, len(s)) if s[i] == s[i - 1] == ""+""}
    def dfs(arr, moves, turn):
    if not moves:
    return turn == 1
    elif turn:
    return all(dfs(arr + [m], moves - {m - 1, m, m + 1}, 1 - turn) for m in moves)
    else:
    return any(dfs(arr + [m], moves - {m - 1, m, m + 1}, 1 - turn) for m in moves)
    return not dfs([], choices, 1)
}"
296.py,"def minTotalDistance(self, grid):
        m, n = len(grid), len(grid[0])
        x, y = sorted(i for i in range(m) for j in range(n) if grid[i][j]), sorted(j for i in range(m) for j in range(n) if grid[i][j])
        avg_x = len(x) % 2 and x[len(x) // 2] or (x[len(x) // 2 - 1] + x[len(x) // 2]) / 2
        avg_y = len(y) % 2 and y[len(y) // 2] or (y[len(y) // 2 - 1] + y[len(y) // 2]) / 2
        return int(sum(abs(avg_x - i) + abs(avg_y - j) for i, j in zip(x, y)))","auto minTotalDistance(auto grid) {
    m, n = len(grid), len(grid[0])
    x, y = sorted(i for i in range(m) for j in range(n) if grid[i][j]), sorted(j for i in range(m) for j in range(n) if grid[i][j])
    avg_x = len(x) % 2 and x[len(x) // 2] or (x[len(x) // 2 - 1] + x[len(x) // 2]) / 2
    avg_y = len(y) % 2 and y[len(y) // 2] or (y[len(y) // 2 - 1] + y[len(y) // 2]) / 2
    return int(sum(abs(avg_x - i) + abs(avg_y - j) for i, j in zip(x, y)))
}"
299.py,"def getHint(self, secret, guess):
        s, g, a, b = collections.defaultdict(int), collections.defaultdict(int), 0, 0
        for i in range(len(secret)):
            if secret[i] == guess[i]: a += 1; continue
            if s[guess[i]] > 0: b, s[guess[i]] = b + 1, s[guess[i]] - 1
            else: g[guess[i]] += 1
            if g[secret[i]] > 0: b, g[secret[i]] = b + 1, g[secret[i]] - 1
            else: s[secret[i]] += 1
        return ""%dA%dB"" % (a, b)","auto getHint(auto secret, auto guess) {
    s, g, a, b = collections.defaultdict(int), collections.defaultdict(int), 0, 0
    for i in range(len(secret)):
    if secret[i] == guess[i]: a += 1; continue
    if s[guess[i]] > 0: b, s[guess[i]] = b + 1, s[guess[i]] - 1
    else: g[guess[i]] += 1
    if g[secret[i]] > 0: b, g[secret[i]] = b + 1, g[secret[i]] - 1
    else: s[secret[i]] += 1
    return ""%dA%dB"" % (a, b)
}"
3.py,"def lengthOfLongestSubstring(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        mx, start, chars = 0, 0, {}
        for i in range(len(s)):
            if s[i] in chars and start <= chars[s[i]]: start = chars[s[i]] + 1
            else: mx = max(mx, i - start + 1)
            chars[s[i]] = i
        return mx","auto lengthOfLongestSubstring(auto s) {
    """"""
    :type s: str
    :rtype: int
    """"""
    mx, start, chars = 0, 0, {}
    for i in range(len(s)):
    if s[i] in chars and start <= chars[s[i]]: start = chars[s[i]] + 1
    else: mx = max(mx, i - start + 1)
    chars[s[i]] = i
    return mx
}"
30.py,"def findSubstring(self, s, words):
        if not s or not words: return []
        cnt, l_words, l_word, cnt_words, res = collections.Counter(words), len(words[0]) * len(words), len(words[0]), len(words), []
        for i in range(len(s) - l_words + 1):
            cur, j = dict(cnt), i
            for _ in range(cnt_words):
                w = s[j:j + l_word]
                if w in cur:
                    if cur[w] == 1: cur.pop(w)
                    else: cur[w] -= 1
                else: break
                j += l_word
            if not cur: res += i,
        return res","auto findSubstring(auto s, auto words) {
    if not s or not words: return []
    cnt, l_words, l_word, cnt_words, res = collections.Counter(words), len(words[0]) * len(words), len(words[0]), len(words), []
    for i in range(len(s) - l_words + 1):
    cur, j = dict(cnt), i
    for _ in range(cnt_words):
    w = s[j:j + l_word]
    if w in cur:
    if cur[w] == 1: cur.pop(w)
    else: cur[w] -= 1
    else: break
    j += l_word
    if not cur: res += i,
    return res
}"
300.py,"def lengthOfLIS(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        tails = [0] * len(nums)
        size = 0
        for x in nums:
            i, j = 0, size
            while i != j:
                m = (i + j) // 2
                if tails[m] < x:
                    i = m + 1
                else:
                    j = m
            tails[i] = x
            size = max(i + 1, size)
        return size       ","auto lengthOfLIS(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: int
    """"""
    tails = [0] * len(nums)
    size = 0
    for x in nums:
    i, j = 0, size
    while i != j:
    m = (i + j) // 2
    if tails[m] < x:
    i = m + 1
    else:
    j = m
    tails[i] = x
    size = max(i + 1, size)
    return size
}"
301.py,"def removeInvalidParentheses(self, s):
        l = r = 0
        for c in s:
            if c.isalpha(): continue
            if c == ""("": l += 1 
            elif l: l -= 1
            else: r += 1
        q = {("""", l, r, 0, 0)}
        for c in s:
            new = set()
            for st, l, r, lCur, rCur in q:
                if c == ""("":
                    new.add((st + c, l, r, lCur + 1, rCur))
                    if l:
                        new.add((st, l - 1, r, lCur, rCur))
                elif c == "")"":
                    if lCur:
                        new.add((st + c, l, r, lCur - 1, rCur))
                    else:
                        new.add((st + c, l, r, lCur, rCur + 1))
                    if r:
                        new.add((st, l, r - 1, lCur, rCur))
                else:
                    new.add((st + c, l, r, lCur, rCur))
            q = new
        return list({st for st, l, r, lCur, rCur in q if l == r == lCur == rCur == 0})","auto removeInvalidParentheses(auto s) {
    l = r = 0
    for c in s:
    if c.isalpha(): continue
    if c == ""("": l += 1
    elif l: l -= 1
    else: r += 1
    q = {("""", l, r, 0, 0)}
    for c in s:
    new = set()
    for st, l, r, lCur, rCur in q:
    if c == ""("":
    new.add((st + c, l, r, lCur + 1, rCur))
    if l:
    new.add((st, l - 1, r, lCur, rCur))
    elif c == "")"":
    if lCur:
    new.add((st + c, l, r, lCur - 1, rCur))
    else:
    new.add((st + c, l, r, lCur, rCur + 1))
    if r:
    new.add((st, l, r - 1, lCur, rCur))
    else:
    new.add((st + c, l, r, lCur, rCur))
    q = new
    return list({st for st, l, r, lCur, rCur in q if l == r == lCur == rCur == 0})
}"
302.py,"def minArea(self, image, x, y):
        l, r, u, d, m, n = [y], [y], [x], [x], len(image), len(image[0])
        def dfs(i, j):
            if i < u[0]: u[0] = i
            elif i > d[0]: d[0] = i
            if j < l[0]: l[0] = j
            elif j > r[0]: r[0] = j
            for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
                if 0 <= x < m and 0 <= y < n and image[x][y] == ""1"":
                    image[x][y] = ""0""
                    dfs(x, y)
        dfs(x, y)
        return (r[0] - l[0] + 1) * (d[0] - u[0] + 1)","auto minArea(auto image, auto x, auto y) {
    l, r, u, d, m, n = [y], [y], [x], [x], len(image), len(image[0])
    def dfs(i, j):
    if i < u[0]: u[0] = i
    elif i > d[0]: d[0] = i
    if j < l[0]: l[0] = j
    elif j > r[0]: r[0] = j
    for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
    if 0 <= x < m and 0 <= y < n and image[x][y] == ""1"":
    image[x][y] = ""0""
    dfs(x, y)
    dfs(x, y)
    return (r[0] - l[0] + 1) * (d[0] - u[0] + 1)
}"
305.py,"def numIslands2(self, m, n, positions):
        def getParent(i):
            if i != parent[i]:
                parent[i] = getParent(parent[i])
            return parent[i]
        islands, res, parent, Id = set(), [], {}, 1
        for i, j in positions:
            parent[(i, j)] = parent[Id] = Id
            for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
                if (x, y) in parent:
                    p = getParent(parent[(x, y)])
                    islands.discard(p)
                    parent[p] = Id
            islands.add(Id)
            Id += 1
            res.append(len(islands))
        return res","auto numIslands2(auto m, auto n, auto positions) {
    def getParent(i):
    if i != parent[i]:
    parent[i] = getParent(parent[i])
    return parent[i]
    islands, res, parent, Id = set(), [], {}, 1
    for i, j in positions:
    parent[(i, j)] = parent[Id] = Id
    for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
    if (x, y) in parent:
    p = getParent(parent[(x, y)])
    islands.discard(p)
    parent[p] = Id
    islands.add(Id)
    Id += 1
    res.append(len(islands))
    return res
}"
306.py,"def isAdditiveNumber(self, num):
        def getStarter():
            arr = []
            for i in range(1, len(num) - 1):
                for j in range(i + 1, len(num)):
                    s1, s2 = num[:i], num[i:j]
                    if (s1[0] == ""0"" and len(s1) > 1) or (s2[0] == ""0"" and len(s2) > 1): 
                        continue
                    arr.append((int(s1), int(s2), j))
            return arr                 
        def dfs(pre1, pre2, i):
            if i == len(num):
                return True
            sm = pre1 + pre2
            l = len(str(sm))
            new = int(num[i:i + l])
            return new == sm and dfs(pre2, new, i + l)
        q = getStarter()
        return any(dfs(p1, p2, i) for p1, p2, i in q)","auto isAdditiveNumber(auto num) {
    def getStarter():
    arr = []
    for i in range(1, len(num) - 1):
    for j in range(i + 1, len(num)):
    s1, s2 = num[:i], num[i:j]
    if (s1[0] == ""0"" and len(s1) > 1) or (s2[0] == ""0"" and len(s2) > 1):
    continue
    arr.append((int(s1), int(s2), j))
    return arr
    def dfs(pre1, pre2, i):
    if i == len(num):
    return True
    sm = pre1 + pre2
    l = len(str(sm))
    new = int(num[i:i + l])
    return new == sm and dfs(pre2, new, i + l)
    q = getStarter()
    return any(dfs(p1, p2, i) for p1, p2, i in q)
}"
309.py,"def maxProfit(self, prices):
        dp1, dp2, dp3 = 0, 0, -float(""inf"")
        for p in prices:
            dp1, dp2, dp3 = dp3 + p, max(dp1, dp2), max(dp2 - p, dp3)
        return max(dp1, dp2)","auto maxProfit(auto prices) {
    dp1, dp2, dp3 = 0, 0, -float(""inf"")
    for p in prices:
    dp1, dp2, dp3 = dp3 + p, max(dp1, dp2), max(dp2 - p, dp3)
    return max(dp1, dp2)
}"
310.py,"def findMinHeightTrees(self, n, edges):
        if n == 1: return [0]
        adj = [set() for i in range(n)]
        for i, j in edges:
            adj[i].add(j)
            adj[j].add(i)
        leaves = [i for i in range(n) if len(adj[i]) == 1]
        while n > 2:
            n -= len(leaves)
            newleaves = []
            for i in leaves:
                j = adj[i].pop()
                adj[j].remove(i)
                if len(adj[j]) == 1: 
                    newleaves.append(j)
            leaves = newleaves
        return leaves ","auto findMinHeightTrees(auto n, auto edges) {
    if n == 1: return [0]
    adj = [set() for i in range(n)]
    for i, j in edges:
    adj[i].add(j)
    adj[j].add(i)
    leaves = [i for i in range(n) if len(adj[i]) == 1]
    while n > 2:
    n -= len(leaves)
    newleaves = []
    for i in leaves:
    j = adj[i].pop()
    adj[j].remove(i)
    if len(adj[j]) == 1:
    newleaves.append(j)
    leaves = newleaves
    return leaves
}"
311.py,"def multiply(self, A, B):
        return [[sum(a * b for a, b in zip(A[i], [B[k][j] for k in range(len(B))])) for j in range(len(B[0]))] for i in range(len(A))]","auto multiply(auto A, auto B) {
    return [[sum(a * b for a, b in zip(A[i], [B[k][j] for k in range(len(B))])) for j in range(len(B[0]))] for i in range(len(A))]
}"
312.py,"def maxCoins(self, nums):
        memo, nums = {}, [1] + [num for num in nums if num] + [1]
        def dfs(l, r):
            if r - l == 1: return 0
            if (l, r) not in memo: memo[(l, r)] = max(nums[l] * nums[i] * nums[r] + dfs(l, i) + dfs(i, r) for i in range(l + 1, r))
            return memo[(l, r)]
        return dfs(0, len(nums) - 1)","auto maxCoins(auto nums) {
    memo, nums = {}, [1] + [num for num in nums if num] + [1]
    def dfs(l, r):
    if r - l == 1: return 0
    if (l, r) not in memo: memo[(l, r)] = max(nums[l] * nums[i] * nums[r] + dfs(l, i) + dfs(i, r) for i in range(l + 1, r))
    return memo[(l, r)]
    return dfs(0, len(nums) - 1)
}"
313.py,"def nthSuperUglyNumber(self, n, primes):
        arr, heap, used = [1], primes[:], set()
        for i in range(1, n):
            num = heapq.heappop(heap)
            arr.append(num)
            for p in primes:
                if p * num not in used:
                    heapq.heappush(heap, p * num)
                    used.add(p * num)
        return arr[-1]","auto nthSuperUglyNumber(auto n, auto primes) {
    arr, heap, used = [1], primes[:], set()
    for i in range(1, n):
    num = heapq.heappop(heap)
    arr.append(num)
    for p in primes:
    if p * num not in used:
    heapq.heappush(heap, p * num)
    used.add(p * num)
    return arr[-1]
}"
315.py,"def countSmaller(self, nums):
        r = []
        for i in range(len(nums) - 1, -1, -1):
            bisect.insort(r, nums[i])
            nums[i] = bisect.bisect_left(r, nums[i])
        return nums","auto countSmaller(auto nums) {
    r = []
    for i in range(len(nums) - 1, -1, -1):
    bisect.insort(r, nums[i])
    nums[i] = bisect.bisect_left(r, nums[i])
    return nums
}"
316.py,"def removeDuplicateLetters(self, s):
        rindex = {c: i for i, c in enumerate(s)}
        result = ''
        for i, c in enumerate(s):
            if c not in result:
                while c < result[-1:] and i < rindex[result[-1]]:
                    result = result[:-1]
                result += c
        return result","auto removeDuplicateLetters(auto s) {
    rindex = {c: i for i, c in enumerate(s)}
    result = ''
    for i, c in enumerate(s):
    if c not in result:
    while c < result[-1:] and i < rindex[result[-1]]:
    result = result[:-1]
    result += c
    return result
}"
317.py,"def shortestDistance(self, grid: List[List[int]]) -> int:
        m, n, d = len(grid), len(grid[0]), 1
        piled = collections.defaultdict(set)
        dist = collections.defaultdict(int)
        bfs = [(i, j, i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]
        total, res = len(bfs), []
        while bfs:
            new = []
            for x, y, i, j in bfs:
                for ii, jj in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):
                    if 0 <= ii < m and 0 <= jj < n and not grid[ii][jj] and (x, y) not in piled[(ii, jj)]:
                        piled[(ii, jj)].add((x, y))
                        dist[(ii, jj)] += d
                        if len(piled[(ii, jj)]) == total:
                            res.append(dist[(ii, jj)])
                        new.append((x, y, ii, jj))
            bfs = new
            d += 1
        return min(res) if res else -1","auto shortestDistance(auto grid) {
    m, n, d = len(grid), len(grid[0]), 1
    piled = collections.defaultdict(set)
    dist = collections.defaultdict(int)
    bfs = [(i, j, i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]
    total, res = len(bfs), []
    while bfs:
    new = []
    for x, y, i, j in bfs:
    for ii, jj in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):
    if 0 <= ii < m and 0 <= jj < n and not grid[ii][jj] and (x, y) not in piled[(ii, jj)]:
    piled[(ii, jj)].add((x, y))
    dist[(ii, jj)] += d
    if len(piled[(ii, jj)]) == total:
    res.append(dist[(ii, jj)])
    new.append((x, y, ii, jj))
    bfs = new
    d += 1
    return min(res) if res else -1
}"
318.py,"def maxProduct(self, words):
        sets, mx = {w: set(w) for w in words}, 0
        words.sort(key = len, reverse = True)
        for i in range(len(words) - 1):
            for j in range(i + 1, len(words)):
                if len(words[i]) * len(words[j]) <= mx:
                    break
                elif not sets[words[i]] & sets[words[j]]:
                    mx = len(words[i]) * len(words[j])
        return mx","auto maxProduct(auto words) {
    sets, mx = {w: set(w) for w in words}, 0
    words.sort(key = len, reverse = True)
    for i in range(len(words) - 1):
    for j in range(i + 1, len(words)):
    if len(words[i]) * len(words[j]) <= mx:
    break
    elif not sets[words[i]] & sets[words[j]]:
    mx = len(words[i]) * len(words[j])
    return mx
}"
319.py,"def bulbSwitch(self, n):
        return int(n ** 0.5)","auto bulbSwitch(auto n) {
    return int(n ** 0.5)
}"
32.py,"def longestValidParentheses(self, s):
        stack, mx = [], 0
        for i, c in enumerate(s):
            if c == "")"" and stack and s[stack[-1]] == ""("": stack.pop()
            else: stack.append(i)
        stack = [-1] + stack + [len(s)]
        for i1, i2 in zip(stack, stack[1:]): mx = max(mx, i2 - i1 - 1)
        return mx if len(stack) > 2 else len(s)","auto longestValidParentheses(auto s) {
    stack, mx = [], 0
    for i, c in enumerate(s):
    if c == "")"" and stack and s[stack[-1]] == ""("": stack.pop()
    else: stack.append(i)
    stack = [-1] + stack + [len(s)]
    for i1, i2 in zip(stack, stack[1:]): mx = max(mx, i2 - i1 - 1)
    return mx if len(stack) > 2 else len(s)
}"
320.py,"def generateAbbreviations(self, word):
        l, res = len(word), []
        def dfs(s, i):
            if i == l:
                res.append(s)
            else:
                dfs(s + word[i], i + 1)
                if not s or s[-1] > ""9"":
                    for j in range(i + 1, l + 1):
                        dfs(s + str(j - i), j)
        dfs("""", 0)
        return res","auto generateAbbreviations(auto word) {
    l, res = len(word), []
    def dfs(s, i):
    if i == l:
    res.append(s)
    else:
    dfs(s + word[i], i + 1)
    if not s or s[-1] > ""9"":
    for j in range(i + 1, l + 1):
    dfs(s + str(j - i), j)
    dfs("""", 0)
    return res
}"
321.py,"def maxNumber(self, nums1, nums2, k):
        def merge(arr1, arr2):
            res, i, j = [], 0, 0
            while i < len(arr1) and j < len(arr2):
                if arr1[i:] >= arr2[j:]:
                    res.append(arr1[i])
                    i += 1
                else: 
                    res.append(arr2[j])
                    j += 1
            if i < len(arr1): res += arr1[i:]
            elif j < len(arr2): res += arr2[j:]
            return res     
        
        def makeArr(arr, l):
            i, res = 0, []
            for r in range(l - 1, -1, -1):
                num, i = max(arr[i:-r] or arr[i:])
                i = -i + 1
                res.append(num)
            return res
        
        nums1, nums2, choices = [(num, -i) for i, num in enumerate(nums1)], [(num, -i) for i, num in enumerate(nums2)], []
        for m in range(k + 1):
            if m > len(nums1) or k - m > len(nums2): continue
            arr1, arr2 = makeArr(nums1, m), makeArr(nums2, k - m)  
            choices.append(merge(arr1, arr2))
        return max(choices)
            ","auto maxNumber(auto nums1, auto nums2, auto k) {
    def merge(arr1, arr2):
    res, i, j = [], 0, 0
    while i < len(arr1) and j < len(arr2):
    if arr1[i:] >= arr2[j:]:
    res.append(arr1[i])
    i += 1
    else:
    res.append(arr2[j])
    j += 1
    if i < len(arr1): res += arr1[i:]
    elif j < len(arr2): res += arr2[j:]
    return res
    
    def makeArr(arr, l):
    i, res = 0, []
    for r in range(l - 1, -1, -1):
    num, i = max(arr[i:-r] or arr[i:])
    i = -i + 1
    res.append(num)
    return res
    
    nums1, nums2, choices = [(num, -i) for i, num in enumerate(nums1)], [(num, -i) for i, num in enumerate(nums2)], []
    for m in range(k + 1):
    if m > len(nums1) or k - m > len(nums2): continue
    arr1, arr2 = makeArr(nums1, m), makeArr(nums2, k - m)
    choices.append(merge(arr1, arr2))
    return max(choices)
}"
322.py,"def coinChange(self, coins, amount):
        """"""
        :type coins: List[int]
        :type amount: int
        :rtype: int
        """"""
        dp = [0] + [float('inf')] * amount
        for i in range(1, amount + 1): dp[i] = min([dp[i - c] if i - c >= 0 else float('inf') for c in coins]) + 1
        return dp[amount] if dp[amount] != float('inf') else -1","auto coinChange(auto coins, auto amount) {
    """"""
    :type coins: List[int]
    :type amount: int
    :rtype: int
    """"""
    dp = [0] + [float('inf')] * amount
    for i in range(1, amount + 1): dp[i] = min([dp[i - c] if i - c >= 0 else float('inf') for c in coins]) + 1
    return dp[amount] if dp[amount] != float('inf') else -1
}"
323.py,"def countComponents(self, n, edges):
        visited, res, adj = set(), 0, collections.defaultdict(set)
        for a, b in edges:
            adj[a].add(b)
            adj[b].add(a)
        def dfs(i):
            visited.add(i)
            for v in adj[i]:
                if v not in visited:
                    dfs(v)
        for i in range(n):
            if i not in visited:
                res += 1
                dfs(i)
        return res","auto countComponents(auto n, auto edges) {
    visited, res, adj = set(), 0, collections.defaultdict(set)
    for a, b in edges:
    adj[a].add(b)
    adj[b].add(a)
    def dfs(i):
    visited.add(i)
    for v in adj[i]:
    if v not in visited:
    dfs(v)
    for i in range(n):
    if i not in visited:
    res += 1
    dfs(i)
    return res
}"
324.py,"def wiggleSort(self, nums: List[int]) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        heap = [-num for num in nums]
        heapq.heapify(heap)
        for i in range(1, len(nums), 2):
            nums[i] = -heapq.heappop(heap)
        for i in range(0, len(nums), 2):
            nums[i] = -heapq.heappop(heap)","auto wiggleSort(auto nums) {
    """"""
    Do not return anything, modify nums in-place instead.
    """"""
    heap = [-num for num in nums]
    heapq.heapify(heap)
    for i in range(1, len(nums), 2):
    nums[i] = -heapq.heappop(heap)
    for i in range(0, len(nums), 2):
    nums[i] = -heapq.heappop(heap)
}"
325.py,"def maxSubArrayLen(self, nums, k):
        index, l, sm = {}, 0, 0
        index[0] = -1
        for i, num in enumerate(nums):
            sm += num
            if sm - k in index:
                l = max(l, i - index[sm - k])
            if sm not in index:
                index[sm] = i
        return l","auto maxSubArrayLen(auto nums, auto k) {
    index, l, sm = {}, 0, 0
    index[0] = -1
    for i, num in enumerate(nums):
    sm += num
    if sm - k in index:
    l = max(l, i - index[sm - k])
    if sm not in index:
    index[sm] = i
    return l
}"
326.py,"def isPowerOfThree(self, n: int) -> bool:
        i = 1
        while i < n:
            i *=3
        return i == n","auto isPowerOfThree(auto n) {
    i = 1
    while i < n:
    i *=3
    return i == n
}"
327.py,"def countRangeSum(self, nums, lower, upper):
        sums, sm, res = [0], 0, 0
        for num in nums:
            sm += num
            res += bisect.bisect_right(sums, sm - lower) - bisect.bisect_left(sums, sm - upper)
            bisect.insort(sums, sm)
        return res","auto countRangeSum(auto nums, auto lower, auto upper) {
    sums, sm, res = [0], 0, 0
    for num in nums:
    sm += num
    res += bisect.bisect_right(sums, sm - lower) - bisect.bisect_left(sums, sm - upper)
    bisect.insort(sums, sm)
    return res
}"
329.py,"def longestIncreasingPath(self, matrix):
        def dfs(i, j):
            if not dp[i][j]:
                dp[i][j] = 1+max((dfs(x,y) for x,y in ((i-1,j),(i+1,j),(i,j-1),(i,j+1)) if 0 <=x<m and 0<=y<n and matrix[x][y] > matrix[i][j]),default=0)
            return dp[i][j]
        m, n, = len(matrix), len(matrix and matrix[0])
        dp = [[0] * n for _ in range(m)]
        return max((dfs(i,j) for i in range(m) for j in range(n)),default=0)","auto longestIncreasingPath(auto matrix) {
    def dfs(i, j):
    if not dp[i][j]:
    dp[i][j] = 1+max((dfs(x,y) for x,y in ((i-1,j),(i+1,j),(i,j-1),(i,j+1)) if 0 <=x<m and 0<=y<n and matrix[x][y] > matrix[i][j]),default=0)
    return dp[i][j]
    m, n, = len(matrix), len(matrix and matrix[0])
    dp = [[0] * n for _ in range(m)]
    return max((dfs(i,j) for i in range(m) for j in range(n)),default=0)
}"
33.py,"def search(self, nums, target):
        l, r = 0, len(nums) - 1
        while l <= r:
            mid = (l + r) // 2
            if nums[mid] == target: 
                return mid
            elif sum((target < nums[l], nums[l] <= nums[mid], nums[mid] < target)) == 2: 
                l = mid + 1
            else: 
                r = mid - 1
        return -1","auto search(auto nums, auto target) {
    l, r = 0, len(nums) - 1
    while l <= r:
    mid = (l + r) // 2
    if nums[mid] == target:
    return mid
    elif sum((target < nums[l], nums[l] <= nums[mid], nums[mid] < target)) == 2:
    l = mid + 1
    else:
    r = mid - 1
    return -1
}"
330.py,"def minPatches(self, nums, n):
        miss, added, i = 1, 0, 0
        while miss <= n:
            if i < len(nums) and nums[i] <= miss:
                miss += nums[i]
                i += 1
            else:
                miss *= 2
                added += 1
        return added","auto minPatches(auto nums, auto n) {
    miss, added, i = 1, 0, 0
    while miss <= n:
    if i < len(nums) and nums[i] <= miss:
    miss += nums[i]
    i += 1
    else:
    miss *= 2
    added += 1
    return added
}"
331.py,"def isValidSerialization(self, preorder: str) -> bool:
        stack = []
        for c in preorder.split(','):
            stack.append(c)
            while stack[-2:] == ['#', '#']:
                stack.pop()
                stack.pop()
                if not stack: return False
                stack.pop()
                stack.append('#')
        return stack == ['#']","auto isValidSerialization(auto preorder) {
    stack = []
    for c in preorder.split(','):
    stack.append(c)
    while stack[-2:] == ['#', '#']:
    stack.pop()
    stack.pop()
    if not stack: return false
    stack.pop()
    stack.append('#')
    return stack == ['#']
}"
332.py,"def findItinerary(self, tickets):
        graph, stack, reached = collections.defaultdict(list), [""JFK""], []
        for a, b in tickets: heapq.heappush(graph[a], b)  
        while stack:
            if graph[stack[-1]]: stack.append(heapq.heappop(graph[stack[-1]]))
            else: reached.append(stack.pop())
        return reached[::-1]","auto findItinerary(auto tickets) {
    graph, stack, reached = collections.defaultdict(list), [""JFK""], []
    for a, b in tickets: heapq.heappush(graph[a], b)
    while stack:
    if graph[stack[-1]]: stack.append(heapq.heappop(graph[stack[-1]]))
    else: reached.append(stack.pop())
    return reached[::-1]
}"
333.py,"def largestBSTSubtree(self, root):
        def dfs(node):
            if not node:
                return True, 0, None, None, 0
            lBool, lSize, lMx, lMn, lTree = dfs(node.left)
            rBool, rSize, rMx, rMn, rTree = dfs(node.right)
            lVal = lMx if lMx != None else -float(""inf"")
            rVal = rMn if rMn != None else float(""inf"")
            curMx = max(val for val in (lMx, rMx, node.val) if val != None)
            curMn = min(val for val in (lMn, rMn, node.val) if val != None)
            curBool = lBool and rBool and lVal < node.val < rVal 
            return curBool, lSize + rSize + 1, curMx, curMn, curBool and lSize + rSize + 1 or max(lTree, rTree)
        return dfs(root)[4]","auto largestBSTSubtree(auto root) {
    def dfs(node):
    if not node:
    return True, 0, None, None, 0
    lBool, lSize, lMx, lMn, lTree = dfs(node.left)
    rBool, rSize, rMx, rMn, rTree = dfs(node.right)
    lVal = lMx if lMx != None else -float(""inf"")
    rVal = rMn if rMn != None else float(""inf"")
    curMx = max(val for val in (lMx, rMx, node.val) if val != None)
    curMn = min(val for val in (lMn, rMn, node.val) if val != None)
    curBool = lBool and rBool and lVal < node.val < rVal
    return curBool, lSize + rSize + 1, curMx, curMn, curBool and lSize + rSize + 1 or max(lTree, rTree)
    return dfs(root)[4]
}"
334.py,"def increasingTriplet(self, nums):
        mn = None
        for i in range(len(nums)):
            if mn == None or nums[i] < mn: 
                mn = nums[i]
            if mn < nums[i]:
                nums[i] = [True, nums[i]]
            else:
                nums[i] = [False, nums[i]]
        mn = None
        for i in range(len(nums)):
            if nums[i][0] and (mn == None or nums[i][1] < mn):
                mn = nums[i][1]
            elif mn != None and mn < nums[i][1]:
                return True
        return False ","auto increasingTriplet(auto nums) {
    mn = None
    for i in range(len(nums)):
    if mn == None or nums[i] < mn:
    mn = nums[i]
    if mn < nums[i]:
    nums[i] = [True, nums[i]]
    else:
    nums[i] = [False, nums[i]]
    mn = None
    for i in range(len(nums)):
    if nums[i][0] and (mn == None or nums[i][1] < mn):
    mn = nums[i][1]
    elif mn != None and mn < nums[i][1]:
    return True
    return False
}"
335.py,"def isSelfCrossing(self, x: List[int]) -> bool:
        b = c = d = e = 0
        for a in x:
            if d >= b > 0 and (a >= c or a >= c-e >= 0 and f >= d-b):
                return True
            b, c, d, e, f = a, b, c, d, e
        return False","auto isSelfCrossing(auto x) {
    b = c = d = e = 0
    for a in x:
    if d >= b > 0 and (a >= c or a >= c-e >= 0 and f >= d-b):
    return true
    b, c, d, e, f = a, b, c, d, e
    return false
}"
336.py,"def palindromePairs(self, words):
        index, res = {w:i for i, w in enumerate(words)}, []
        for i, w in enumerate(words):
            for j in range(len(w) + 1):
                pre, suf = w[:j], w[j:]
                if pre == pre[::-1]:
                    suf = suf[::-1]
                    if suf != w and suf in index:
                        res.append([index[suf], i])
                if j != len(w) and suf == suf[::-1]:
                    pre = pre[::-1]
                    if pre != w and pre in index:
                        res.append([i, index[pre]])
        return res","auto palindromePairs(auto words) {
    index, res = {w:i for i, w in enumerate(words)}, []
    for i, w in enumerate(words):
    for j in range(len(w) + 1):
    pre, suf = w[:j], w[j:]
    if pre == pre[::-1]:
    suf = suf[::-1]
    if suf != w and suf in index:
    res.append([index[suf], i])
    if j != len(w) and suf == suf[::-1]:
    pre = pre[::-1]
    if pre != w and pre in index:
    res.append([i, index[pre]])
    return res
}"
337.py,"def rob(self, root):
        def dfs(node):
            if not node: return 0, 0
            l, r = dfs(node.left), dfs(node.right)
            return max(l) + max(r), node.val + l[0] + r[0]
        return max(dfs(root))","auto rob(auto root) {
    def dfs(node):
    if not node: return 0, 0
    l, r = dfs(node.left), dfs(node.right)
    return max(l) + max(r), node.val + l[0] + r[0]
    return max(dfs(root))
}"
338.py,"def countBits(self, num: int) -> List[int]:
        return [bin(i)[2:].count('1') for i in range(num + 1)]","auto countBits(auto num) {
    return [bin(i)[2:].count('1') for i in range(num + 1)]
}"
340.py,"def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:
        if not k:
            return 0
        cnt = collections.Counter()
        i = res = 0
        for j, c in enumerate(s):
            while len(cnt) == k and c not in cnt:
                cnt[s[i]] -= 1
                if cnt[s[i]] == 0:
                    cnt.pop(s[i])
                i += 1
            cnt[c] += 1
            res = max(res, j - i + 1)
        return res","auto lengthOfLongestSubstringKDistinct(auto s, auto k) {
    if not k:
    return 0
    cnt = collections.Counter()
    i = res = 0
    for j, c in enumerate(s):
    while len(cnt) == k and c not in cnt:
    cnt[s[i]] -= 1
    if cnt[s[i]] == 0:
    cnt.pop(s[i])
    i += 1
    cnt[c] += 1
    res = max(res, j - i + 1)
    return res
}"
342.py,"def isPowerOfFour(self, num: int) -> bool:
        if num < 0:
            return False
        i = 1
        while i < num:
            i = i * 4
        return i == num
        ","auto isPowerOfFour(auto num) {
    if num < 0:
    return false
    i = 1
    while i < num:
    i = i * 4
    return i == num
}"
343.py,"def integerBreak(self, n):
        pre = [0, 1, 1, 2, 4, 6, 9]
        if n < 7:
            return pre[n]
        for i in range(7, n + 1):
            pre.append(max(pre[i - 2] * 2, pre[i - 3] * 3))
        return pre[-1]","auto integerBreak(auto n) {
    pre = [0, 1, 1, 2, 4, 6, 9]
    if n < 7:
    return pre[n]
    for i in range(7, n + 1):
    pre.append(max(pre[i - 2] * 2, pre[i - 3] * 3))
    return pre[-1]
}"
344.py,"def reverseString(self, s: List[str]) -> None:
        """"""
        Do not return anything, modify s in-place instead.
        """"""
        for i in range(len(s) // 2):
            s[i], s[-i-1] = s[-i-1], s[i]","auto reverseString(auto s) {
    """"""
    Do not return anything, modify s in-place instead.
    """"""
    for i in range(len(s) // 2):
    s[i], s[-i-1] = s[-i-1], s[i]
}"
345.py,"def reverseVowels(self, s):
        r = [c for c in s if c in ""aeiouAEIOU""]
        return """".join(c in ""aeiouAEIOU"" and r.pop() or c for c in s) ","auto reverseVowels(auto s) {
    r = [c for c in s if c in ""aeiouAEIOU""]
    return """".join(c in ""aeiouAEIOU"" and r.pop() or c for c in s)
}"
347.py,"def topKFrequent(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """"""
        from collections import Counter as ct
        return [k for (k,v) in ct(nums).most_common(k)] ","auto topKFrequent(auto nums, auto k) {
    """"""
    :type nums: List[int]
    :type k: int
    :rtype: List[int]
    """"""
    from collections import Counter as ct
    return [k for (k,v) in ct(nums).most_common(k)]
}"
349.py,"def intersection(self, nums1, nums2):
        """"""
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """"""
        return list(set(nums1)&set(nums2))","auto intersection(auto nums1, auto nums2) {
    """"""
    :type nums1: List[int]
    :type nums2: List[int]
    :rtype: List[int]
    """"""
    return list(set(nums1)&set(nums2))
}"
35.py,"def searchInsert(self, nums: List[int], target: int) -> int:
        return bisect.bisect_left(nums, target)","auto searchInsert(auto nums, auto target) {
    return bisect.bisect_left(nums, target)
}"
351.py,"def numberOfPatterns(self, m, n):
        q, pattern = [[c] for c in range(1, 10)], 0
        while q:
            new = []
            for arr in q:
                if m <= len(arr) <= n:
                    pattern += 1
                if len(arr) < n:
                    last = arr[-1]
                    for c in range(1, 10):
                        if c not in arr:
                            if last in (1, 4, 7) and c == last + 2:
                                if last + 1 in arr:
                                    new.append(arr + [c])
                            elif last in (3, 6, 9) and c == last - 2:
                                if last - 1 in arr:
                                    new.append(arr + [c])
                            elif last in (1, 2, 3) and c == last + 6:
                                if last + 3 in arr:
                                    new.append(arr + [c])
                            elif last in (7, 8, 9) and c == last - 6:
                                if last - 3 in arr:
                                    new.append(arr + [c])
                            elif last == 1 and c == 9:
                                if 5 in arr:
                                    new.append(arr + [9])
                            elif last == 9 and c == 1:
                                if 5 in arr:
                                    new.append(arr + [1])
                            elif last == 3 and c == 7:
                                if 5 in arr:
                                    new.append(arr + [7])
                            elif last == 7 and c == 3:
                                if 5 in arr:
                                    new.append(arr + [3])
                            else:
                                new.append(arr + [c])
            q = new
        return pattern","auto numberOfPatterns(auto m, auto n) {
    q, pattern = [[c] for c in range(1, 10)], 0
    while q:
    new = []
    for arr in q:
    if m <= len(arr) <= n:
    pattern += 1
    if len(arr) < n:
    last = arr[-1]
    for c in range(1, 10):
    if c not in arr:
    if last in (1, 4, 7) and c == last + 2:
    if last + 1 in arr:
    new.append(arr + [c])
    elif last in (3, 6, 9) and c == last - 2:
    if last - 1 in arr:
    new.append(arr + [c])
    elif last in (1, 2, 3) and c == last + 6:
    if last + 3 in arr:
    new.append(arr + [c])
    elif last in (7, 8, 9) and c == last - 6:
    if last - 3 in arr:
    new.append(arr + [c])
    elif last == 1 and c == 9:
    if 5 in arr:
    new.append(arr + [9])
    elif last == 9 and c == 1:
    if 5 in arr:
    new.append(arr + [1])
    elif last == 3 and c == 7:
    if 5 in arr:
    new.append(arr + [7])
    elif last == 7 and c == 3:
    if 5 in arr:
    new.append(arr + [3])
    else:
    new.append(arr + [c])
    q = new
    return pattern
}"
354.py,"def maxEnvelopes(self, envelopes):
        tails = []
        for w, h in sorted(envelopes, key = lambda x: (x[0], -x[1])):
            i = bisect.bisect_left(tails, h)
            if i == len(tails): tails.append(h)
            else: tails[i] = h
        return len(tails)","auto maxEnvelopes(auto envelopes) {
    tails = []
    for w, h in sorted(envelopes, key = lambda x: (x[0], -x[1])):
    i = bisect.bisect_left(tails, h)
    if i == len(tails): tails.append(h)
    else: tails[i] = h
    return len(tails)
}"
356.py,"def isReflected(self, points):
        if len(points) < 2:
            return True
        x = (min(x for x, y in points) + max(x for x, y in points)) / 2 
        left, right, on = set(), set(), set()
        for i, j in points:
            if i < x:
                left.add((i, j))
            elif i > x:
                right.add((i, j))
            else:
                on.add((i, j))
        for i, j in points:
            if i < x and (2 * x - i, j) in right:
                continue
            elif i > x and (2 * x - i, j) in left:
                continue
            elif i == x and (2 * x - i, j) in on:
                continue
            else:
                return False
        return True","auto isReflected(auto points) {
    if len(points) < 2:
    return True
    x = (min(x for x, y in points) + max(x for x, y in points)) / 2
    left, right, on = set(), set(), set()
    for i, j in points:
    if i < x:
    left.add((i, j))
    elif i > x:
    right.add((i, j))
    else:
    on.add((i, j))
    for i, j in points:
    if i < x and (2 * x - i, j) in right:
    continue
    elif i > x and (2 * x - i, j) in left:
    continue
    elif i == x and (2 * x - i, j) in on:
    continue
    else:
    return False
    return True
}"
357.py,"def countNumbersWithUniqueDigits(self, n):
        return [1, 10, 91, 739, 5275, 32491, 168571, 712891, 2345851, 5611771, 8877691][n % 11]","auto countNumbersWithUniqueDigits(auto n) {
    return [1, 10, 91, 739, 5275, 32491, 168571, 712891, 2345851, 5611771, 8877691][n % 11]
}"
358.py,"def rearrangeString(self, s, k):
        q, last, res, wq = [(-v, k) for k, v in collections.Counter(s).items()], {}, """", []
        heapq.heapify(q)
        for i in range(len(s)):
            if wq and (wq[0][1] not in last or last[wq[0][1]] + k <= i): cnt, char = heapq.heappop(wq)
            else:
                while q and not (q[0][1] not in last or last[q[0][1]] + k <= i): heapq.heappush(wq, heapq.heappop(q))
                if not q: return """"
                cnt, char = heapq.heappop(q)
            res, cnt, last[char] = res + char, cnt + 1, i
            if cnt: heapq.heappush(q, (cnt, char))
        return res","auto rearrangeString(auto s, auto k) {
    q, last, res, wq = [(-v, k) for k, v in collections.Counter(s).items()], {}, """", []
    heapq.heapify(q)
    for i in range(len(s)):
    if wq and (wq[0][1] not in last or last[wq[0][1]] + k <= i): cnt, char = heapq.heappop(wq)
    else:
    while q and not (q[0][1] not in last or last[q[0][1]] + k <= i): heapq.heappush(wq, heapq.heappop(q))
    if not q: return """"
    cnt, char = heapq.heappop(q)
    res, cnt, last[char] = res + char, cnt + 1, i
    if cnt: heapq.heappush(q, (cnt, char))
    return res
}"
36.py,"def isValidSudoku(self, board):
        rows, cols, triples = collections.defaultdict(set), collections.defaultdict(set), collections.defaultdict(set)
        for i, row in enumerate(board):
            for j, c in enumerate(row):
                if c != ""."" and c in rows[i] or c in cols[j] or c in triples[(i //3, j // 3)]: 
                    return False
                elif c != ""."": 
                    rows[i].add(c); cols[j].add(c); triples[(i // 3, j // 3)].add(c)
        return True","auto isValidSudoku(auto board) {
    rows, cols, triples = collections.defaultdict(set), collections.defaultdict(set), collections.defaultdict(set)
    for i, row in enumerate(board):
    for j, c in enumerate(row):
    if c != ""."" and c in rows[i] or c in cols[j] or c in triples[(i //3, j // 3)]:
    return False
    elif c != ""."":
    rows[i].add(c); cols[j].add(c); triples[(i // 3, j // 3)].add(c)
    return True
}"
360.py,"def sortTransformedArray(self, nums, a, b, c):
        arr, l, r, ind = [0] * len(nums), 0, len(nums) - 1, a >= 0 and len(nums) - 1 or 0
        while l <= r:
            n1, n2 = a * nums[l] * nums[l] + b * nums[l] + c, a * nums[r] * nums[r] + b * nums[r] + c
            if a >= 0:
                if n1 >= n2: l += 1
                else: r -= 1
                arr[ind] = n1 >= n2 and n1 or n2
                ind -= 1
            else:
                if n1 < n2: l += 1
                else: r -= 1
                arr[ind] = n1 < n2 and n1 or n2
                ind += 1
        return arr","auto sortTransformedArray(auto nums, auto a, auto b, auto c) {
    arr, l, r, ind = [0] * len(nums), 0, len(nums) - 1, a >= 0 and len(nums) - 1 or 0
    while l <= r:
    n1, n2 = a * nums[l] * nums[l] + b * nums[l] + c, a * nums[r] * nums[r] + b * nums[r] + c
    if a >= 0:
    if n1 >= n2: l += 1
    else: r -= 1
    arr[ind] = n1 >= n2 and n1 or n2
    ind -= 1
    else:
    if n1 < n2: l += 1
    else: r -= 1
    arr[ind] = n1 < n2 and n1 or n2
    ind += 1
    return arr
}"
361.py,"def maxKilledEnemies(self, grid):
        m, n, res = len(grid), len(grid and grid[0]), 0
        dp = [[[0, 0, 0, 0] for j in range(n + 1)] for i in range(m + 1)]
        for i in range(m):
            for j in range(n):
                if grid[i][j] == ""0"":
                    dp[i][j][0] = dp[i][j - 1][0]
                    dp[i][j][1] = dp[i - 1][j][1]
                elif grid[i][j] == ""E"":
                    dp[i][j][0] = dp[i][j - 1][0] + 1
                    dp[i][j][1] = dp[i - 1][j][1] + 1 
        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                if grid[i][j] == ""0"":
                    dp[i][j][2] = dp[i][j + 1][2]
                    dp[i][j][3] = dp[i + 1][j][3]
                elif grid[i][j] == ""E"":
                    dp[i][j][2] = dp[i][j + 1][2] + 1
                    dp[i][j][3] = dp[i + 1][j][3] + 1
                if grid[i][j] == ""0"":
                    res = max(res, sum(dp[i][j]))
        return res        ","auto maxKilledEnemies(auto grid) {
    m, n, res = len(grid), len(grid and grid[0]), 0
    dp = [[[0, 0, 0, 0] for j in range(n + 1)] for i in range(m + 1)]
    for i in range(m):
    for j in range(n):
    if grid[i][j] == ""0"":
    dp[i][j][0] = dp[i][j - 1][0]
    dp[i][j][1] = dp[i - 1][j][1]
    elif grid[i][j] == ""E"":
    dp[i][j][0] = dp[i][j - 1][0] + 1
    dp[i][j][1] = dp[i - 1][j][1] + 1
    for i in range(m - 1, -1, -1):
    for j in range(n - 1, -1, -1):
    if grid[i][j] == ""0"":
    dp[i][j][2] = dp[i][j + 1][2]
    dp[i][j][3] = dp[i + 1][j][3]
    elif grid[i][j] == ""E"":
    dp[i][j][2] = dp[i][j + 1][2] + 1
    dp[i][j][3] = dp[i + 1][j][3] + 1
    if grid[i][j] == ""0"":
    res = max(res, sum(dp[i][j]))
    return res
}"
363.py,"def maxSumSubmatrix(self, matrix, k, mxTotal = -float(""inf"")):
        for l in range(len(matrix[0])):
            dp = [0] * len(matrix)
            for r in range(l, len(matrix[0])):
                for i in range(len(matrix)):
                    dp[i] += matrix[i][r]
                sums, cur, mx = [float(""inf"")], 0, -float(""inf"")
                for sm in dp:
                    bisect.insort(sums, cur)
                    cur += sm
                    mx = max(mx, cur - sums[bisect.bisect_left(sums, cur - k)])
                mxTotal = max(mxTotal, mx)
        return mxTotal","auto maxSumSubmatrix(auto matrix, auto k, auto mxTotal = -float(""inf"")) {
    for l in range(len(matrix[0])):
    dp = [0] * len(matrix)
    for r in range(l, len(matrix[0])):
    for i in range(len(matrix)):
    dp[i] += matrix[i][r]
    sums, cur, mx = [float(""inf"")], 0, -float(""inf"")
    for sm in dp:
    bisect.insort(sums, cur)
    cur += sm
    mx = max(mx, cur - sums[bisect.bisect_left(sums, cur - k)])
    mxTotal = max(mxTotal, mx)
    return mxTotal
}"
365.py,"def canMeasureWater(self, x, y, z):
        def gcd(x, y):
            for i in range(min(x, y), -1, -1):
                if not x % i and not y % i: return i      
        div = gcd(x, y) if x * y else 0
        return not z % div and z <= x + y if div else not z","auto canMeasureWater(auto x, auto y, auto z) {
    def gcd(x, y):
    for i in range(min(x, y), -1, -1):
    if not x % i and not y % i: return i
    div = gcd(x, y) if x * y else 0
    return not z % div and z <= x + y if div else not z
}"
367.py,"def isPerfectSquare(self, num):
        """"""
        :type num: int
        :rtype: bool
        """"""
        i=1
        while i**2<=num:
            if i**2<num: i+=1
            if i**2==num: return True
        return False","auto isPerfectSquare(auto num) {
    """"""
    :type num: int
    :rtype: bool
    """"""
    i=1
    while i**2<=num:
    if i**2<num: i+=1
    if i**2==num: return True
    return False
}"
368.py,"def largestDivisibleSubset(self, nums):
        dp, n = [[num] for num in sorted(nums)], len(nums)
        for i in range(n - 1):
            for j in range(i + 1, n):
                if not dp[j][-1] % dp[i][-1] and len(dp[i]) >= len(dp[j]):
                    dp[j] = dp[i] + dp[j][-1:]
        return dp and sorted(dp, key = len)[-1]","auto largestDivisibleSubset(auto nums) {
    dp, n = [[num] for num in sorted(nums)], len(nums)
    for i in range(n - 1):
    for j in range(i + 1, n):
    if not dp[j][-1] % dp[i][-1] and len(dp[i]) >= len(dp[j]):
    dp[j] = dp[i] + dp[j][-1:]
    return dp and sorted(dp, key = len)[-1]
}"
37.py,"def solveSudoku(self, board):
        rows, cols, triples, visit = collections.defaultdict(set), collections.defaultdict(set), collections.defaultdict(set), collections.deque([])
        for r in range(9):
            for c in range(9):
                if board[r][c] != ""."":
                    rows[r].add(board[r][c])
                    cols[c].add(board[r][c])
                    triples[(r // 3, c // 3)].add(board[r][c])
                else:
                    visit.append((r, c))
        def dfs():
            if not visit:
                return True
            r, c = visit[0]
            t = (r // 3, c // 3)
            for dig in {""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""}:
                if dig not in rows[r] and dig not in cols[c] and dig not in triples[t]:
                    board[r][c] = dig
                    rows[r].add(dig)
                    cols[c].add(dig)
                    triples[t].add(dig)
                    visit.popleft()
                    if dfs():
                        return True
                    else:
                        board[r][c] = "".""
                        rows[r].discard(dig)
                        cols[c].discard(dig)
                        triples[t].discard(dig)
                        visit.appendleft((r, c))
            return False
        dfs()","auto solveSudoku(auto board) {
    rows, cols, triples, visit = collections.defaultdict(set), collections.defaultdict(set), collections.defaultdict(set), collections.deque([])
    for r in range(9):
    for c in range(9):
    if board[r][c] != ""."":
    rows[r].add(board[r][c])
    cols[c].add(board[r][c])
    triples[(r // 3, c // 3)].add(board[r][c])
    else:
    visit.append((r, c))
    def dfs():
    if not visit:
    return True
    r, c = visit[0]
    t = (r // 3, c // 3)
    for dig in {""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""}:
    if dig not in rows[r] and dig not in cols[c] and dig not in triples[t]:
    board[r][c] = dig
    rows[r].add(dig)
    cols[c].add(dig)
    triples[t].add(dig)
    visit.popleft()
    if dfs():
    return True
    else:
    board[r][c] = "".""
    rows[r].discard(dig)
    cols[c].discard(dig)
    triples[t].discard(dig)
    visit.appendleft((r, c))
    return False
    dfs()
}"
370.py,"def getModifiedArray(self, length, updates):
        start, end, res, cur = collections.defaultdict(int), collections.defaultdict(int), [0] * length, 0
        for s, e, inc in updates:
            start[s] += inc
            end[e] += -inc
        for i in range(length):
            if start[i]:
                cur += start[i]
            res[i] += cur
            if end[i]:
                cur += end[i]
        return res","auto getModifiedArray(auto length, auto updates) {
    start, end, res, cur = collections.defaultdict(int), collections.defaultdict(int), [0] * length, 0
    for s, e, inc in updates:
    start[s] += inc
    end[e] += -inc
    for i in range(length):
    if start[i]:
    cur += start[i]
    res[i] += cur
    if end[i]:
    cur += end[i]
    return res
}"
371.py,"def getSum(self, a, b):
        """"""
        :type a: int
        :type b: int
        :rtype: int
        """"""
        mx, mask = 0x7FFFFFFF, 0xFFFFFFFF
        while b:
            a, b = (a ^ b) & mask, ((a & b) << 1) & mask
        return a if a <= mx else ~(a ^ mask)","auto getSum(auto a, auto b) {
    """"""
    :type a: int
    :type b: int
    :rtype: int
    """"""
    mx, mask = 0x7FFFFFFF, 0xFFFFFFFF
    while b:
    a, b = (a ^ b) & mask, ((a & b) << 1) & mask
    return a if a <= mx else ~(a ^ mask)
}"
372.py,"def superPow(self, a, b):
        return pow(a, int(''.join(map(str, b))), 1337)","auto superPow(auto a, auto b) {
    return pow(a, int(''.join(map(str, b))), 1337)
}"
373.py,"def kSmallestPairs(self, nums1, nums2, k):
        if not nums1 or not nums2: return []
        n, res, cnt, heap = len(nums2), [], 0, [(nums1[i] + nums2[0], i, 0) for i in range(len(nums1))]
        while heap and cnt < k:
            cnt += 1
            sm, i, j = heapq.heappop(heap)
            res.append([nums1[i], nums2[j]])
            if j + 1 < n: heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))
        return res","auto kSmallestPairs(auto nums1, auto nums2, auto k) {
    if not nums1 or not nums2: return []
    n, res, cnt, heap = len(nums2), [], 0, [(nums1[i] + nums2[0], i, 0) for i in range(len(nums1))]
    while heap and cnt < k:
    cnt += 1
    sm, i, j = heapq.heappop(heap)
    res.append([nums1[i], nums2[j]])
    if j + 1 < n: heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))
    return res
}"
375.py,"def getMoneyAmount(self, n):
        dic = {}
        def dfs(l, r):
            if l >=r: return 0
            if (l, r) not in dic: dic[(l, r)] = min(num + max(dfs(l, num - 1), dfs(num + 1, r)) for num in range(l, r))
            return dic[(l, r)]
        return dfs(1, n)","auto getMoneyAmount(auto n) {
    dic = {}
    def dfs(l, r):
    if l >=r: return 0
    if (l, r) not in dic: dic[(l, r)] = min(num + max(dfs(l, num - 1), dfs(num + 1, r)) for num in range(l, r))
    return dic[(l, r)]
    return dfs(1, n)
}"
376.py,"def wiggleMaxLength(self, nums):
        if len(nums) <= 2: return 0 if not nums else 1 if nums[0] == nums[-1] else 2
        inc = nums[0] < nums[1] if nums[0] != nums[1] else None
        cnt = 2 if inc != None else 1
        for i in range(2, len(nums)):
            if nums[i - 1] != nums[i] and (inc == None or inc != (nums[i - 1] < nums[i])):
                inc = nums[i - 1] < nums[i] 
                cnt += 1
        return cnt","auto wiggleMaxLength(auto nums) {
    if len(nums) <= 2: return 0 if not nums else 1 if nums[0] == nums[-1] else 2
    inc = nums[0] < nums[1] if nums[0] != nums[1] else None
    cnt = 2 if inc != None else 1
    for i in range(2, len(nums)):
    if nums[i - 1] != nums[i] and (inc == None or inc != (nums[i - 1] < nums[i])):
    inc = nums[i - 1] < nums[i]
    cnt += 1
    return cnt
}"
377.py,"def combinationSum4(self, nums, target):
        memo = {}
        def dfs(sm):
            if sm in memo:
                return memo[sm]
            else:
                if sm >= target:
                    memo[sm] = sm == target
                    return memo[sm]
                cnt = 0
                for num in nums:
                    memo[sm + num] = dfs(sm + num)
                    cnt += memo[sm + num]
                return cnt          
        return dfs(0)","auto combinationSum4(auto nums, auto target) {
    memo = {}
    def dfs(sm):
    if sm in memo:
    return memo[sm]
    else:
    if sm >= target:
    memo[sm] = sm == target
    return memo[sm]
    cnt = 0
    for num in nums:
    memo[sm + num] = dfs(sm + num)
    cnt += memo[sm + num]
    return cnt
    return dfs(0)
}"
378.py,"def kthSmallest(self, matrix, k):
        return sorted(itertools.chain(*matrix))[k - 1]","auto kthSmallest(auto matrix, auto k) {
    return sorted(itertools.chain(*matrix))[k - 1]
}"
38.py,"def countAndSay(self, n):
        curr = ""1""
        for i in range(n - 1):
            tmp, cnt = """", 1
            for j, c in enumerate(curr):
                if j > 0 and curr[j - 1] == c: 
                    cnt += 1
                elif j > 0: 
                    tmp += str(cnt) + curr[j - 1]
                    cnt = 1
                if j == len(curr) - 1: 
                    tmp += str(cnt) + curr[j] 
            curr = tmp
        return curr","auto countAndSay(auto n) {
    curr = ""1""
    for i in range(n - 1):
    tmp, cnt = """", 1
    for j, c in enumerate(curr):
    if j > 0 and curr[j - 1] == c:
    cnt += 1
    elif j > 0:
    tmp += str(cnt) + curr[j - 1]
    cnt = 1
    if j == len(curr) - 1:
    tmp += str(cnt) + curr[j]
    curr = tmp
    return curr
}"
383.py,"def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        cnt = collections.Counter(magazine)
        for c in ransomNote:
            if cnt[c]:
                cnt[c] -= 1
            else:
                return False
        return True","auto canConstruct(auto ransomNote, auto magazine) {
    cnt = collections.Counter(magazine)
    for c in ransomNote:
    if cnt[c]:
    cnt[c] -= 1
    else:
    return false
    return true
}"
384.py,"def __init__(self, nums: List[int]):
        self.arr = nums
        self.org = nums[:]

    def reset(self) -> List[int]:
        """"""
        Resets the array to its original configuration and return it.
        """"""
        self.arr = self.org[:]
        return self.arr

    def shuffle(self) -> List[int]:
        """"""
        Returns a random shuffling of the array.
        """"""
        random.shuffle(self.arr)
        return self.arr


# Your Solution object will be instantiated and called as such:
# obj = Solution(nums)
# param_1 = obj.reset()
# param_2 = obj.shuffle()","auto __init__(auto nums) {
    self.arr = nums
    self.org = nums[:]
    
    def reset(self) -> List[int]:
    """"""
    Resets the array to its original configuration and return it.
    """"""
    self.arr = self.org[:]
    return self.arr
    
    def shuffle(self) -> List[int]:
    """"""
    Returns a random shuffling of the array.
    """"""
    random.shuffle(self.arr)
    return self.arr
    
    
    # Your Solution object will be instantiated and called as such:
    # obj = Solution(nums)
    # param_1 = obj.reset()
    # param_2 = obj.shuffle()
}"
385.py,"def deserialize(self, s):
        stack, num, last = [], """", None
        for c in s:
            if c.isdigit() or c == ""-"": num += c
            elif c == "","" and num:
                stack[-1].add(NestedInteger(int(num)))
                num = """"
            elif c == ""["":
                elem = NestedInteger()
                if stack: stack[-1].add(elem)
                stack.append(elem)
            elif c == ""]"":
                if num:
                    stack[-1].add(NestedInteger(int(num)))
                    num = """"
                last = stack.pop()
        return last if last else NestedInteger(int(num))","auto deserialize(auto s) {
    stack, num, last = [], """", None
    for c in s:
    if c.isdigit() or c == ""-"": num += c
    elif c == "","" and num:
    stack[-1].add(NestedInteger(int(num)))
    num = """"
    elif c == ""["":
    elem = NestedInteger()
    if stack: stack[-1].add(elem)
    stack.append(elem)
    elif c == ""]"":
    if num:
    stack[-1].add(NestedInteger(int(num)))
    num = """"
    last = stack.pop()
    return last if last else NestedInteger(int(num))
}"
387.py,"def firstUniqChar(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        dic = collections.defaultdict(int)
        for c in s:
            dic[c] += 1
        for i, c in enumerate(s):
            if dic[c] == 1: return i
        return -1","auto firstUniqChar(auto s) {
    """"""
    :type s: str
    :rtype: int
    """"""
    dic = collections.defaultdict(int)
    for c in s:
    dic[c] += 1
    for i, c in enumerate(s):
    if dic[c] == 1: return i
    return -1
}"
388.py,"def lengthLongestPath(self, input: str) -> int:
        maxlen = 0
        pathlen = {0: 0}
        for line in input.splitlines():
            name = line.lstrip('\u005Ct')
            depth = len(line) - len(name)
            if '.' in name:
                maxlen = max(maxlen, pathlen[depth] + len(name))
            else:
                pathlen[depth + 1] = pathlen[depth] + len(name) + 1
        return maxlen","auto lengthLongestPath(auto input) {
    maxlen = 0
    pathlen = {0: 0}
    for line in input.splitlines():
    name = line.lstrip('\u005Ct')
    depth = len(line) - len(name)
    if '.' in name:
    maxlen = max(maxlen, pathlen[depth] + len(name))
    else:
    pathlen[depth + 1] = pathlen[depth] + len(name) + 1
    return maxlen
}"
389.py,"def findTheDifference(self, s, t):
        return next(iter(collections.Counter(t) - collections.Counter(s)))","auto findTheDifference(auto s, auto t) {
    return next(iter(collections.Counter(t) - collections.Counter(s)))
}"
39.py,"def combinationSum(self, c, t):
        res, stack, n = [], [(0, [], 0)], len(c)
        while stack:
            sm, tmp, r = stack.pop()
            for i in range(r, n):
                if sm + c[i] < t: 
                    stack.append((sm + c[i], tmp + [c[i]], i))
                elif sm + c[i] == t: 
                    res.append(tmp + [c[i]])
        return res","auto combinationSum(auto c, auto t) {
    res, stack, n = [], [(0, [], 0)], len(c)
    while stack:
    sm, tmp, r = stack.pop()
    for i in range(r, n):
    if sm + c[i] < t:
    stack.append((sm + c[i], tmp + [c[i]], i))
    elif sm + c[i] == t:
    res.append(tmp + [c[i]])
    return res
}"
390.py,"def lastRemaining(self, n):
        head, left, step, remaining = 1, 1, 1, n
        while remaining > 1:
            if left or remaining % 2: head += step
            left = 1 - left
            step *= 2
            remaining //= 2
        return head","auto lastRemaining(auto n) {
    head, left, step, remaining = 1, 1, 1, n
    while remaining > 1:
    if left or remaining % 2: head += step
    left = 1 - left
    step *= 2
    remaining //= 2
    return head
}"
391.py,"def isRectangleCover(self, rectangles):
        cnt = collections.Counter()
        for x1, y1, x2, y2 in rectangles:
            cnt[(x1, y1)] += 1
            cnt[(x1, y2)] += 1
            cnt[(x2, y2)] += 1
            cnt[(x2, y1)] += 1
        x1, y1, x2, y2 = min([r[:2] for r in rectangles]) + max(r[-2:] for r in rectangles)
        for x, y in ((x1, y1), (x1, y2), (x2, y2), (x2, y1)):
            if cnt[(x, y)] != 1: return False
            cnt.pop((x, y))
        return all(cnt[k] in (2, 4) for k in cnt) and sum((x2 - x1) * (y2 - y1) for x1, y1, x2, y2 in rectangles) == (x2 - x1) * (y2 - y1)","auto isRectangleCover(auto rectangles) {
    cnt = collections.Counter()
    for x1, y1, x2, y2 in rectangles:
    cnt[(x1, y1)] += 1
    cnt[(x1, y2)] += 1
    cnt[(x2, y2)] += 1
    cnt[(x2, y1)] += 1
    x1, y1, x2, y2 = min([r[:2] for r in rectangles]) + max(r[-2:] for r in rectangles)
    for x, y in ((x1, y1), (x1, y2), (x2, y2), (x2, y1)):
    if cnt[(x, y)] != 1: return False
    cnt.pop((x, y))
    return all(cnt[k] in (2, 4) for k in cnt) and sum((x2 - x1) * (y2 - y1) for x1, y1, x2, y2 in rectangles) == (x2 - x1) * (y2 - y1)
}"
392.py,"def isSubsequence(self, s, t):
        ind = -1
        for i in s:
            try: ind = t.index(i, ind + 1)
            except: return False
        return True","auto isSubsequence(auto s, auto t) {
    ind = -1
    for i in s:
    try: ind = t.index(i, ind + 1)
    except: return False
    return True
}"
393.py,"def validUtf8(self, data: List[int]) -> bool:
        def rest(i):
            if len(data) < i:
                return False
            for _ in range(i):
                if not data.pop().startswith(""10""):
                    return False
            return True

        data, byte = [str(bin(seq)[2:].zfill(8)) for seq in data[::-1]], None
        while data:
            seq = data.pop()
            if seq.startswith(""0""):
                continue
            elif seq.startswith(""110""):
                if not rest(1):
                    return False
            elif seq.startswith(""1110""):
                if not rest(2):
                    return False
            elif seq.startswith(""11110""):
                if not rest(3):
                    return False
            else:
                return False
        return True
","auto validUtf8(auto data) {
    def rest(i):
    if len(data) < i:
    return false
    for _ in range(i):
    if not data.pop().startswith(""10""):
    return false
    return true
    
    data, byte = [str(bin(seq)[2:].zfill(8)) for seq in data[::-1]], nullptr
    while data:
    seq = data.pop()
    if seq.startswith(""0""):
    continue
    elif seq.startswith(""110""):
    if not rest(1):
    return false
    elif seq.startswith(""1110""):
    if not rest(2):
    return false
    elif seq.startswith(""11110""):
    if not rest(3):
    return false
    else:
    return false
    return true
}"
394.py,"def decodeString(self, s):
        stack, num, string = [], 0, """"
        for c in s:
            if c == ""["":
                stack += string,
                stack += num,
                num, string = 0, """"
            elif c == ""]"":
                pre_num, pre_string = stack.pop(), stack.pop()
                string = pre_string + pre_num * string
            elif c.isdigit(): num = num * 10 + int(c)
            else: string += c
        return string","auto decodeString(auto s) {
    stack, num, string = [], 0, """"
    for c in s:
    if c == ""["":
    stack += string,
    stack += num,
    num, string = 0, """"
    elif c == ""]"":
    pre_num, pre_string = stack.pop(), stack.pop()
    string = pre_string + pre_num * string
    elif c.isdigit(): num = num * 10 + int(c)
    else: string += c
    return string
}"
395.py,"def longestSubstring(self, s, k):
        br = [-1] + [i for i, c in enumerate(s) if s.count(c) < k] + [len(s)]
        return len(s) if len(br) == 2 else max(self.longestSubstring(s[br[i - 1] + 1:br[i]], k) for i in range(1, len(br)))","auto longestSubstring(auto s, auto k) {
    br = [-1] + [i for i, c in enumerate(s) if s.count(c) < k] + [len(s)]
    return len(s) if len(br) == 2 else max(self.longestSubstring(s[br[i - 1] + 1:br[i]], k) for i in range(1, len(br)))
}"
396.py,"def maxRotateFunction(self, A):
        """"""
        :type A: List[int]
        :rtype: int
        """"""
        mx, sm = 0, sum(A)
        for i in range(len(A)):
            mx += i * A[i]
        curr = mx
        for i in range(1, len(A)):
            curr = curr - sm + A[i - 1] * len(A)
            mx = max(mx, curr)
        return mx","auto maxRotateFunction(auto A) {
    """"""
    :type A: List[int]
    :rtype: int
    """"""
    mx, sm = 0, sum(A)
    for i in range(len(A)):
    mx += i * A[i]
    curr = mx
    for i in range(1, len(A)):
    curr = curr - sm + A[i - 1] * len(A)
    mx = max(mx, curr)
    return mx
}"
397.py,"def integerReplacement(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        if n == 1: 
            return 0
        elif n % 2 == 0: 
            return self.integerReplacement(n/2)+1
        else: 
            return min(self.integerReplacement(n+1),self.integerReplacement(n-1))+1","auto integerReplacement(auto n) {
    """"""
    :type n: int
    :rtype: int
    """"""
    if n == 1:
    return 0
    elif n % 2 == 0:
    return self.integerReplacement(n/2)+1
    else:
    return min(self.integerReplacement(n+1),self.integerReplacement(n-1))+1
}"
398.py,"def __init__(self, nums):
        self.indexes = collections.defaultdict(set)
        for i, num in enumerate(nums):
            self.indexes[num].add(i)

    def pick(self, target):
        return random.sample(self.indexes[target], 1)[0]","auto __init__(auto nums) {
    self.indexes = collections.defaultdict(set)
    for i, num in enumerate(nums):
    self.indexes[num].add(i)
    
    def pick(self, target):
    return random.sample(self.indexes[target], 1)[0]
}"
399.py,"def calcEquation(self, equations, values, queries):
        def explore(x, y, r, q):
            results[(x, y)] = r
            for z in edges[y]:
                if z not in q:
                    results[(x, z)], results[(z, x)] = r * vals[(y, z)], 1 / (r * vals[(y, z)])
                    explore(x, z, r * vals[(y, z)], q | {z})
        edges, vals, visited, results, res = collections.defaultdict(set), {}, set(), {}, []
        for i, eq in enumerate(equations):
            edges[eq[0]].add(eq[1])
            edges[eq[1]].add(eq[0])
            vals[(eq[0], eq[1])], vals[(eq[1], eq[0])] = values[i], 1 / values[i]
        for i, eq in enumerate(equations):
            for p in eq:
                if p not in visited:
                    visited.add(p)
                    explore(p, p, 1.0, {p})
        for q in queries:
            if (q[0], q[1]) in results: res += results[(q[0], q[1])],
            else: res += -1.0,
        return res","auto calcEquation(auto equations, auto values, auto queries) {
    def explore(x, y, r, q):
    results[(x, y)] = r
    for z in edges[y]:
    if z not in q:
    results[(x, z)], results[(z, x)] = r * vals[(y, z)], 1 / (r * vals[(y, z)])
    explore(x, z, r * vals[(y, z)], q | {z})
    edges, vals, visited, results, res = collections.defaultdict(set), {}, set(), {}, []
    for i, eq in enumerate(equations):
    edges[eq[0]].add(eq[1])
    edges[eq[1]].add(eq[0])
    vals[(eq[0], eq[1])], vals[(eq[1], eq[0])] = values[i], 1 / values[i]
    for i, eq in enumerate(equations):
    for p in eq:
    if p not in visited:
    visited.add(p)
    explore(p, p, 1.0, {p})
    for q in queries:
    if (q[0], q[1]) in results: res += results[(q[0], q[1])],
    else: res += -1.0,
    return res
}"
4.py,"def findMedianSortedArrays(self, nums1, nums2):
        arr = sorted(nums1 + nums2)
        if len(arr) % 2 == 0: return (arr[len(arr) // 2] + arr[len(arr) // 2 - 1]) / 2
        else: return arr[len(arr) // 2]","auto findMedianSortedArrays(auto nums1, auto nums2) {
    arr = sorted(nums1 + nums2)
    if len(arr) % 2 == 0: return (arr[len(arr) // 2] + arr[len(arr) // 2 - 1]) / 2
    else: return arr[len(arr) // 2]
}"
40.py,"def combinationSum2(self, candidates, target):   
        res = []
        self.dfs(sorted(candidates), target, 0, [], res)
        return res
    def dfs(self, nums, target, index, path, res):    
        if target < 0:
            return 
        if target == 0 and path not in res:
            res.append(path)
            return 
        for i in range(index, len(nums)):
            if i>1 and nums[i] == nums[i-1]:
                continue
            self.dfs(nums[:i] + nums[i+1:], target-nums[i], i, path+[nums[i]], res)","auto combinationSum2(auto candidates, auto target) {
    res = []
    self.dfs(sorted(candidates), target, 0, [], res)
    return res
    def dfs(self, nums, target, index, path, res):
    if target < 0:
    return
    if target == 0 and path not in res:
    res.append(path)
    return
    for i in range(index, len(nums)):
    if i>1 and nums[i] == nums[i-1]:
    continue
    self.dfs(nums[:i] + nums[i+1:], target-nums[i], i, path+[nums[i]], res)
}"
401.py,"def readBinaryWatch(self, num):
        """"""
        :type num: int
        :rtype: List[str]
        """"""
        return ['%d:%02d' % (h, m)
            for h in range(12) for m in range(60)
            if (bin(h) + bin(m)).count('1') == num]","auto readBinaryWatch(auto num) {
    """"""
    :type num: int
    :rtype: List[str]
    """"""
    return ['%d:%02d' % (h, m)
    for h in range(12) for m in range(60)
    if (bin(h) + bin(m)).count('1') == num]
}"
402.py,"def removeKdigits(self, num, k):
        out = []
        for digit in num:
            while k and out and out[-1] > digit:
                out.pop()
                k -= 1
            out.append(digit)
        return ''.join(out[:-k or None]).lstrip('0') or ""0""","auto removeKdigits(auto num, auto k) {
    out = []
    for digit in num:
    while k and out and out[-1] > digit:
    out.pop()
    k -= 1
    out.append(digit)
    return ''.join(out[:-k or None]).lstrip('0') or ""0""
}"
403.py,"def canCross(self, stones):
        memo, stones, target = {}, set(stones), stones[-1]
        def dfs(unit, last):
            if unit == target: return True
            if (unit, last) not in memo: 
                memo[(unit, last)] = any(dfs(unit + move, move) for move in (last - 1, last, last + 1) if move and unit + move in stones)
            return memo[(unit, last)]
        return dfs(1, 1) if 1 in stones else False","auto canCross(auto stones) {
    memo, stones, target = {}, set(stones), stones[-1]
    def dfs(unit, last):
    if unit == target: return True
    if (unit, last) not in memo:
    memo[(unit, last)] = any(dfs(unit + move, move) for move in (last - 1, last, last + 1) if move and unit + move in stones)
    return memo[(unit, last)]
    return dfs(1, 1) if 1 in stones else False
}"
405.py,"def toHex(self, num):
        if not num: return ""0""
        mp, ans = ""0123456789abcdef"", """"
        for i in range(8):
            n = num & 15       
            c = mp[n]          
            ans = c + ans
            num = num >> 4
        return ans.lstrip('0')","auto toHex(auto num) {
    if not num: return ""0""
    mp, ans = ""0123456789abcdef"", """"
    for i in range(8):
    n = num & 15
    c = mp[n]
    ans = c + ans
    num = num >> 4
    return ans.lstrip('0')
}"
406.py,"def reconstructQueue(self, people):
        arr = [0] * len(people)
        people.sort()
        for h, k in people:
            cnt = 0
            for i in range(len(arr)):
                if not arr[i] or arr[i][0] == h:
                    cnt += 1
                    if cnt == k + 1:
                        arr[i] = [h, k]
        return arr","auto reconstructQueue(auto people) {
    arr = [0] * len(people)
    people.sort()
    for h, k in people:
    cnt = 0
    for i in range(len(arr)):
    if not arr[i] or arr[i][0] == h:
    cnt += 1
    if cnt == k + 1:
    arr[i] = [h, k]
    return arr
}"
407.py,"def trapRainWater(self, heightMap):
        m, n, heap, trapped = len(heightMap), len(heightMap and heightMap[0]), [], 0
        for i in range(m):
            for j in range(n):
                if i in {0, m - 1} or j in {0, n - 1}:
                    heapq.heappush(heap, (heightMap[i][j], i, j))
                    heightMap[i][j] = -1          
        while heap:
            h, i, j = heapq.heappop(heap)
            for x, y in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):
                if 0 < x < m - 1 and 0 < y < n - 1 and heightMap[x][y] != -1:
                    trapped += max(h - heightMap[x][y], 0)
                    heapq.heappush(heap, (max(heightMap[x][y], h), x, y))
                    heightMap[x][y] = -1
        return trapped","auto trapRainWater(auto heightMap) {
    m, n, heap, trapped = len(heightMap), len(heightMap and heightMap[0]), [], 0
    for i in range(m):
    for j in range(n):
    if i in {0, m - 1} or j in {0, n - 1}:
    heapq.heappush(heap, (heightMap[i][j], i, j))
    heightMap[i][j] = -1
    while heap:
    h, i, j = heapq.heappop(heap)
    for x, y in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):
    if 0 < x < m - 1 and 0 < y < n - 1 and heightMap[x][y] != -1:
    trapped += max(h - heightMap[x][y], 0)
    heapq.heappush(heap, (max(heightMap[x][y], h), x, y))
    heightMap[x][y] = -1
    return trapped
}"
408.py,"def validWordAbbreviation(self, word: str, abbr: str) -> bool:
        i = num = 0
        for c in abbr:
            if c.isdigit():
                if num == 0 and c == '0':
                    return False
                num = num * 10 + int(c)
            else:
                if num:
                    #print(i, num)
                    i += num 
                    num = 0
                if i >= len(word) or word[i] != c:
                    #print(i, c)
                    return False
                i += 1
        return i == len(word) if num == 0 else i + num == len(word)","auto validWordAbbreviation(auto word, auto abbr) {
    i = num = 0
    for c in abbr:
    if c.isdigit():
    if num == 0 and c == '0':
    return false
    num = num * 10 + int(c)
    else:
    if num:
    #print(i, num)
    i += num
    num = 0
    if i >= len(word) or word[i] != c:
    #print(i, c)
    return false
    i += 1
    return i == len(word) if num == 0 else i + num == len(word)
}"
409.py,"def longestPalindrome(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        from collections import Counter
        out=even=sum(v for k,v in Counter(s).items() if v%2==0)
        odd_big=[v for k,v in Counter(s).items() if v%2!=0 and v>1]
        odd_small=[v for k,v in Counter(s).items() if v==1]
        if len(odd_big)==1: out+=odd_big[0]
        else:
            out+=sum(odd_big)-len(odd_big)+1  
            if len(odd_small)==0 and len(odd_big)==0: out-=1
        return out","auto longestPalindrome(auto s) {
    """"""
    :type s: str
    :rtype: int
    """"""
    from collections import Counter
    out=even=sum(v for k,v in Counter(s).items() if v%2==0)
    odd_big=[v for k,v in Counter(s).items() if v%2!=0 and v>1]
    odd_small=[v for k,v in Counter(s).items() if v==1]
    if len(odd_big)==1: out+=odd_big[0]
    else:
    out+=sum(odd_big)-len(odd_big)+1
    if len(odd_small)==0 and len(odd_big)==0: out-=1
    return out
}"
41.py,"def firstMissingPositive(self, nums: List[int], res: int = 1) -> int:
        for num in sorted(nums):
            res += num == res
        return res
        ","auto firstMissingPositive(auto nums, auto res) {
    for num in sorted(nums):
    res += num == res
    return res
}"
410.py,"def splitArray(self, nums, m):
        def valid(mid):
            cnt = sm = 0
            for num in nums:
                sm += num
                if sm > mid:
                    cnt += 1
                    if cnt>= m: return False
                    sm = num
            return True
        l, h = max(nums), sum(nums)
        while l < h:
            mid = (l + h) // 2
            if valid(mid):
                h = mid
            else:
                l = mid + 1
        return l","auto splitArray(auto nums, auto m) {
    def valid(mid):
    cnt = sm = 0
    for num in nums:
    sm += num
    if sm > mid:
    cnt += 1
    if cnt>= m: return False
    sm = num
    return True
    l, h = max(nums), sum(nums)
    while l < h:
    mid = (l + h) // 2
    if valid(mid):
    h = mid
    else:
    l = mid + 1
    return l
}"
412.py,"def fizzBuzz(self, n):
        """"""
        :type n: int
        :rtype: List[str]
        """"""
        num = []
        for i in range(1, n + 1):
            if i % 3 == 0 and i % 5 == 0:
                num.append(""FizzBuzz"")
            elif i % 3 == 0:
                num.append(""Fizz"")
            elif i % 5 == 0:
                num.append(""Buzz"")
            else:
                num.append(str(i))
        return num","auto fizzBuzz(auto n) {
    """"""
    :type n: int
    :rtype: List[str]
    """"""
    num = []
    for i in range(1, n + 1):
    if i % 3 == 0 and i % 5 == 0:
    num.append(""FizzBuzz"")
    elif i % 3 == 0:
    num.append(""Fizz"")
    elif i % 5 == 0:
    num.append(""Buzz"")
    else:
    num.append(str(i))
    return num
}"
413.py,"def numberOfArithmeticSlices(self, A):
        if len(A) < 3:
            return 0
        A.append(float(""inf""))
        d, l, n, res = A[1] - A[0], 0, len(A), 0
        for i in range(2, n):
            if d != A[i] - A[i - 1]:
                diff = i - l - 2
                if diff > 0:
                    res += diff * (diff + 1) // 2
                d, l = A[i] - A[i - 1], i - 1
        return res","auto numberOfArithmeticSlices(auto A) {
    if len(A) < 3:
    return 0
    A.append(float(""inf""))
    d, l, n, res = A[1] - A[0], 0, len(A), 0
    for i in range(2, n):
    if d != A[i] - A[i - 1]:
    diff = i - l - 2
    if diff > 0:
    res += diff * (diff + 1) // 2
    d, l = A[i] - A[i - 1], i - 1
    return res
}"
414.py,"def thirdMax(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        s=list(set(nums))
        if s[-1]<s[0]: s=[item for item in s if item>=0]
        if len(s)>=3: return s[-3]
        else: return s[-1] ","auto thirdMax(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: int
    """"""
    s=list(set(nums))
    if s[-1]<s[0]: s=[item for item in s if item>=0]
    if len(s)>=3: return s[-3]
    else: return s[-1]
}"
415.py,"def addStrings(self, num1, num2):
        """"""
        :type num1: str
        :type num2: str
        :rtype: str
        """"""
        return """".join(str(sum([(ord(num1[i])-ord(""0""))*(10**(len(num1)-1-i)) for i in range(len(num1))]+[(ord(num2[i])-ord(""0""))*(10**(len(num2)-1-i)) for i in range(len(num2))])))","auto addStrings(auto num1, auto num2) {
    """"""
    :type num1: str
    :type num2: str
    :rtype: str
    """"""
    return """".join(str(sum([(ord(num1[i])-ord(""0""))*(10**(len(num1)-1-i)) for i in range(len(num1))]+[(ord(num2[i])-ord(""0""))*(10**(len(num2)-1-i)) for i in range(len(num2))])))
}"
416.py,"def canPartition(self, nums):
        sm, n = sum(nums), len(nums)
        if sm % 2:
            return False
        sm //= 2
        dp = [False] * (sm + 1)
        dp[0] = True
        for num in nums:
            for j in range(num, sm + 1)[::-1]:
                dp[j] = dp[j] or dp[j - num]
        return dp[-1]","auto canPartition(auto nums) {
    sm, n = sum(nums), len(nums)
    if sm % 2:
    return False
    sm //= 2
    dp = [False] * (sm + 1)
    dp[0] = True
    for num in nums:
    for j in range(num, sm + 1)[::-1]:
    dp[j] = dp[j] or dp[j - num]
    return dp[-1]
}"
417.py,"def pacificAtlantic(self, matrix):
        pac, atl, m, n = set(), set(), len(matrix), len(matrix and matrix[0])
        def explore(i, j, ocean): 
            ocean.add((i, j))
            if i > 0 and (i - 1, j) not in ocean and matrix[i - 1][j] >= matrix[i][j]: explore(i - 1, j, ocean)
            if j > 0 and (i, j - 1) not in ocean and matrix[i][j - 1] >= matrix[i][j]: explore(i, j - 1, ocean)
            if i + 1 < m  and (i + 1, j) not in ocean and matrix[i + 1][j] >= matrix[i][j]: explore(i + 1, j, ocean)
            if j + 1 < n  and (i, j +1) not in ocean and matrix[i][j + 1] >= matrix[i][j]: explore(i, j + 1, ocean)
        for i in range(max(m, n)):
            if i < m and (i, 0) not in pac: explore(i, 0, pac)
            if i < n and (0, i) not in pac: explore(0, i, pac)
            if i < n and (m - 1, i) not in atl: explore(m - 1, i, atl)
            if i < m and (i, n - 1) not in atl: explore(i, n - 1, atl)
        return [[x, y] for x, y in pac & atl]","auto pacificAtlantic(auto matrix) {
    pac, atl, m, n = set(), set(), len(matrix), len(matrix and matrix[0])
    def explore(i, j, ocean):
    ocean.add((i, j))
    if i > 0 and (i - 1, j) not in ocean and matrix[i - 1][j] >= matrix[i][j]: explore(i - 1, j, ocean)
    if j > 0 and (i, j - 1) not in ocean and matrix[i][j - 1] >= matrix[i][j]: explore(i, j - 1, ocean)
    if i + 1 < m  and (i + 1, j) not in ocean and matrix[i + 1][j] >= matrix[i][j]: explore(i + 1, j, ocean)
    if j + 1 < n  and (i, j +1) not in ocean and matrix[i][j + 1] >= matrix[i][j]: explore(i, j + 1, ocean)
    for i in range(max(m, n)):
    if i < m and (i, 0) not in pac: explore(i, 0, pac)
    if i < n and (0, i) not in pac: explore(0, i, pac)
    if i < n and (m - 1, i) not in atl: explore(m - 1, i, atl)
    if i < m and (i, n - 1) not in atl: explore(i, n - 1, atl)
    return [[x, y] for x, y in pac & atl]
}"
418.py,"def wordsTyping(self, sentence, rows, cols):
        left, count, sm, ptr, wordLen = [0] * len(sentence), 0, 0, 0, len(sentence[0])
        for i, w in enumerate(sentence):
            while sm + wordLen <= cols:
                sm += wordLen
                ptr += 1
                wordLen = len(sentence[ptr % len(sentence)]) + 1
            left[i] = ptr - i
            sm -= len(w) + 1
        for r in range(rows):
            count += left[count % len(sentence)]
        return count // len(sentence)","auto wordsTyping(auto sentence, auto rows, auto cols) {
    left, count, sm, ptr, wordLen = [0] * len(sentence), 0, 0, 0, len(sentence[0])
    for i, w in enumerate(sentence):
    while sm + wordLen <= cols:
    sm += wordLen
    ptr += 1
    wordLen = len(sentence[ptr % len(sentence)]) + 1
    left[i] = ptr - i
    sm -= len(w) + 1
    for r in range(rows):
    count += left[count % len(sentence)]
    return count // len(sentence)
}"
419.py,"def countBattleships(self, board):
        return sum(board[i][j] == ""X"" and (i == 0 or board[i - 1][j] == ""."") and (j == 0 or board[i][j - 1] == ""."") for i in range(len(board)) for j in range(len(board[0])))","auto countBattleships(auto board) {
    return sum(board[i][j] == ""X"" and (i == 0 or board[i - 1][j] == ""."") and (j == 0 or board[i][j - 1] == ""."") for i in range(len(board)) for j in range(len(board[0])))
}"
42.py,"def trap(self, height):
        res, left, l, r = 0, {}, 0, 0
        for i, h in enumerate(height):
            left[i] = l
            if h > l: 
                l = h
        for i in range(len(height) - 1, -1, -1):
            roof = min(left[i] , r)
            if roof > height[i]:
                res += roof - height[i]
            if height[i] > r:
                r = height[i]
        return res","auto trap(auto height) {
    res, left, l, r = 0, {}, 0, 0
    for i, h in enumerate(height):
    left[i] = l
    if h > l:
    l = h
    for i in range(len(height) - 1, -1, -1):
    roof = min(left[i] , r)
    if roof > height[i]:
    res += roof - height[i]
    if height[i] > r:
    r = height[i]
    return res
}"
421.py,"def findMaximumXOR(self, nums, ans = 0):
        ans = 0
        for bit in range(30, -1, -1):
            ans <<= 1
            attempt = ans | 1
            prefix = set()
            for x in nums:
                p = x >> bit
                if attempt ^ p in prefix:
                    ans = attempt
                    break
                prefix.add(p)
        return ans","auto findMaximumXOR(auto nums, auto ans = 0) {
    ans = 0
    for bit in range(30, -1, -1):
    ans <<= 1
    attempt = ans | 1
    prefix = set()
    for x in nums:
    p = x >> bit
    if attempt ^ p in prefix:
    ans = attempt
    break
    prefix.add(p)
    return ans
}"
422.py,"def validWordSquare(self, words):
        for j, row in enumerate(words):
            col = """"
            for s in words:
                try: col += s[j]
                except: break
            if row != col: return False
        return True","auto validWordSquare(auto words) {
    for j, row in enumerate(words):
    col = """"
    for s in words:
    try: col += s[j]
    except: break
    if row != col: return False
    return True
}"
424.py,"def characterReplacement(self, s, k):
        """"""
        :type s: str
        :type k: int
        :rtype: int
        """"""
        dic, start, end = {}, 0, 0
        for end in range(1, len(s)+1):
            if not s[end-1] in dic: dic[s[end-1]] = 1
            else: dic[s[end-1]] += 1
            if end-start-max(dic.values()) > k: 
                dic[s[start]] -= 1
                start += 1
        return end-start","auto characterReplacement(auto s, auto k) {
    """"""
    :type s: str
    :type k: int
    :rtype: int
    """"""
    dic, start, end = {}, 0, 0
    for end in range(1, len(s)+1):
    if not s[end-1] in dic: dic[s[end-1]] = 1
    else: dic[s[end-1]] += 1
    if end-start-max(dic.values()) > k:
    dic[s[start]] -= 1
    start += 1
    return end-start
}"
425.py,"def wordSquares(self, words):
        pref, res = collections.defaultdict(set), []
        for w in words:
            for i in range(len(w)):
                pref[w[:i + 1]].add(w)
        def dfs(i, arr):
            if i == len(arr[0]):
                res.append(arr)
            else:
                for w in pref["""".join(row[i] for row in arr)]:
                    dfs(i + 1, arr + [w])   
        for w in words:
            dfs(1, [w])
        return res","auto wordSquares(auto words) {
    pref, res = collections.defaultdict(set), []
    for w in words:
    for i in range(len(w)):
    pref[w[:i + 1]].add(w)
    def dfs(i, arr):
    if i == len(arr[0]):
    res.append(arr)
    else:
    for w in pref["""".join(row[i] for row in arr)]:
    dfs(i + 1, arr + [w])
    for w in words:
    dfs(1, [w])
    return res
}"
426.py,"def treeToDoublyList(self, root):
        head, tail = [None], [None]
        def dfs(node, pre):
            if not node:
                return
            l = dfs(node.left, pre)
            new = Node(node.val, l or pre, None)
            if pre and not l:
                pre.right = new
            elif l:
                l.right = new
            if not pre and not l:
                head[0] = new
            if not tail[0] or node.val > tail[0].val:
                tail[0] = new
            r = dfs(node.right, new)
            return r if r else new
        dfs(root, None)
        if head[0]:
            head[0].left = tail[0]
            tail[0].right = head[0]
        return head[0]","auto treeToDoublyList(auto root) {
    head, tail = [None], [None]
    def dfs(node, pre):
    if not node:
    return
    l = dfs(node.left, pre)
    new = Node(node.val, l or pre, None)
    if pre and not l:
    pre.right = new
    elif l:
    l.right = new
    if not pre and not l:
    head[0] = new
    if not tail[0] or node.val > tail[0].val:
    tail[0] = new
    r = dfs(node.right, new)
    return r if r else new
    dfs(root, None)
    if head[0]:
    head[0].left = tail[0]
    tail[0].right = head[0]
    return head[0]
}"
427.py,"def construct(self, grid):
        def dfs(x, y, l):
            if l == 1:
                node = Node(grid[x][y] == 1, True, None, None, None, None)
            else:
                tLeft = dfs(x, y, l // 2)
                tRight = dfs(x, y + l // 2, l // 2)
                bLeft = dfs(x + l // 2, y, l// 2)
                bRight = dfs(x + l // 2, y + l // 2, l // 2)
                value = tLeft.val or tRight.val or bLeft.val or bRight.val
                if tLeft.isLeaf and tRight.isLeaf and bLeft.isLeaf and bRight.isLeaf and tLeft.val == tRight.val == bLeft.val == bRight.val:
                    node = Node(value, True, None, None, None, None)
                else:
                    node = Node(value, False, tLeft, tRight, bLeft, bRight)
            return node
        return grid and dfs(0, 0, len(grid)) or None","auto construct(auto grid) {
    def dfs(x, y, l):
    if l == 1:
    node = Node(grid[x][y] == 1, True, None, None, None, None)
    else:
    tLeft = dfs(x, y, l // 2)
    tRight = dfs(x, y + l // 2, l // 2)
    bLeft = dfs(x + l // 2, y, l// 2)
    bRight = dfs(x + l // 2, y + l // 2, l // 2)
    value = tLeft.val or tRight.val or bLeft.val or bRight.val
    if tLeft.isLeaf and tRight.isLeaf and bLeft.isLeaf and bRight.isLeaf and tLeft.val == tRight.val == bLeft.val == bRight.val:
    node = Node(value, True, None, None, None, None)
    else:
    node = Node(value, False, tLeft, tRight, bLeft, bRight)
    return node
    return grid and dfs(0, 0, len(grid)) or None
}"
43.py,"def multiply(self, num1, num2):
        dic, l1, l2 = {str(i): i for i in range(10)}, len(num1) - 1, len(num2) - 1
        return str(sum([dic[n1] * (10**(l1-i)) for i, n1 in enumerate(num1)]) * sum([dic[n2] * (10**(l2-j)) for j, n2 in enumerate(num2)]))","auto multiply(auto num1, auto num2) {
    dic, l1, l2 = {str(i): i for i in range(10)}, len(num1) - 1, len(num2) - 1
    return str(sum([dic[n1] * (10**(l1-i)) for i, n1 in enumerate(num1)]) * sum([dic[n2] * (10**(l2-j)) for j, n2 in enumerate(num2)]))
}"
433.py,"def minMutation(self, start: str, end: str, bank: List[str]) -> int:
        bfs = [start]
        genes = set(bank)
        cnt = 0
        while bfs:
            arr = []
            for g in bfs:
                if g == end:
                    return cnt
                for i, c in enumerate(g):
                    for new in 'AGTC':
                        if new != c:
                            s = g[:i] + new + g[i + 1:]
                            if s in genes:
                                arr.append(s)
                                genes.discard(s)
            bfs = arr
            cnt += 1
        return -1","auto minMutation(auto start, auto end, auto bank) {
    bfs = [start]
    genes = set(bank)
    cnt = 0
    while bfs:
    arr = []
    for g in bfs:
    if g == end:
    return cnt
    for i, c in enumerate(g):
    for new in 'AGTC':
    if new != c:
    s = g[:i] + new + g[i + 1:]
    if s in genes:
    arr.append(s)
    genes.discard(s)
    bfs = arr
    cnt += 1
    return -1
}"
434.py,"def countSegments(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        return len(s.split())
        ","auto countSegments(auto s) {
    """"""
    :type s: str
    :rtype: int
    """"""
    return len(s.split())
}"
436.py,"def findRightInterval(self, intervals):
        def binarySearch(l, r):
            x, found = intervals[l - 1].end, None
            while l <= r:
                mid = (l + r) // 2
                if intervals[mid].start >= x:
                    r = mid - 1
                    found = mid
                else:
                    l = mid + 1
            return ind[intervals[found]] if found != None else -1
        root = intervals[:]
        ind = {intr:i for i, intr in enumerate(root)}
        intervals.sort(key = lambda x: x.start)
        for i in range(len(intervals)):
            root[ind[intervals[i]]] = binarySearch(i + 1, len(intervals) - 1)
        return root","auto findRightInterval(auto intervals) {
    def binarySearch(l, r):
    x, found = intervals[l - 1].end, None
    while l <= r:
    mid = (l + r) // 2
    if intervals[mid].start >= x:
    r = mid - 1
    found = mid
    else:
    l = mid + 1
    return ind[intervals[found]] if found != None else -1
    root = intervals[:]
    ind = {intr:i for i, intr in enumerate(root)}
    intervals.sort(key = lambda x: x.start)
    for i in range(len(intervals)):
    root[ind[intervals[i]]] = binarySearch(i + 1, len(intervals) - 1)
    return root
}"
438.py,"def findAnagrams(self, s, p):
        """"""
        :type s: str
        :type p: str
        :rtype: List[int]
        """"""
        out=list()
        from collections import Counter
        s_counter, p_counter=Counter(s[:len(p)-1]), Counter(p)
        for i in range(len(p)-1,len(s)):
            s_counter[s[i]]+=1
            if s_counter==p_counter: out.append(i-len(p)+1)
            s_counter[s[i-len(p)+1]]-=1
            if s_counter[s[i-len(p)+1]]==0: del s_counter[s[i-len(p)+1]]
        return out","auto findAnagrams(auto s, auto p) {
    """"""
    :type s: str
    :type p: str
    :rtype: List[int]
    """"""
    out=list()
    from collections import Counter
    s_counter, p_counter=Counter(s[:len(p)-1]), Counter(p)
    for i in range(len(p)-1,len(s)):
    s_counter[s[i]]+=1
    if s_counter==p_counter: out.append(i-len(p)+1)
    s_counter[s[i-len(p)+1]]-=1
    if s_counter[s[i-len(p)+1]]==0: del s_counter[s[i-len(p)+1]]
    return out
}"
439.py,"def parseTernary(self, expression, stack = []):
        for c in expression[::-1]:
            if stack and stack[-1] == ""?"":
                _, first, q, second = stack.pop(), stack.pop(), stack.pop(), stack.pop()
                stack.append(c == ""T"" and first or second)
            else:
                stack.append(c)
        return stack.pop()","auto parseTernary(auto expression, auto stack = []) {
    for c in expression[::-1]:
    if stack and stack[-1] == ""?"":
    _, first, q, second = stack.pop(), stack.pop(), stack.pop(), stack.pop()
    stack.append(c == ""T"" and first or second)
    else:
    stack.append(c)
    return stack.pop()
}"
44.py,"def isMatch(self, s, p):
        sp = pp = match = 0
        star = -1
        while sp < len(s):
            if (pp < len(p) and (s[sp] == p[pp] or p[pp] == '?')):
                sp +=1
                pp +=1
            elif pp < len(p) and p[pp] == '*':
                star = pp
                match = sp
                pp +=1
            elif star != -1:
                pp = star + 1
                match +=1
                sp = match
            else:
                return False
        while(pp < len(p) and p[pp] == '*'):
            pp += 1
        return pp == len(p)","auto isMatch(auto s, auto p) {
    sp = pp = match = 0
    star = -1
    while sp < len(s):
    if (pp < len(p) and (s[sp] == p[pp] or p[pp] == '?')):
    sp +=1
    pp +=1
    elif pp < len(p) and p[pp] == '*':
    star = pp
    match = sp
    pp +=1
    elif star != -1:
    pp = star + 1
    match +=1
    sp = match
    else:
    return False
    while(pp < len(p) and p[pp] == '*'):
    pp += 1
    return pp == len(p)
}"
441.py,"def arrangeCoins(self, n: int) -> int:
        sm = res = 0
        for i in range(1, n + 1):
            sm += i
            if sm > n:
                break
            res += 1
        return res","auto arrangeCoins(auto n) {
    sm = res = 0
    for i in range(1, n + 1):
    sm += i
    if sm > n:
    break
    res += 1
    return res
}"
442.py,"def findDuplicates(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        out=list()
        for i in range(len(nums)):
            if nums[abs(nums[i])-1]<0: out.append(abs(nums[i]))
            else: nums[abs(nums[i])-1]*=-1
        return out","auto findDuplicates(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: List[int]
    """"""
    out=list()
    for i in range(len(nums)):
    if nums[abs(nums[i])-1]<0: out.append(abs(nums[i]))
    else: nums[abs(nums[i])-1]*=-1
    return out
}"
443.py,"def compress(self, chars):
        """"""
        :type chars: List[str]
        :rtype: int
        """"""
        curr, count, i = chars[0], 1, 1
        while i<len(chars):
            if chars[i]!=curr:
                curr=chars[i]
                if count>1: chars[:i]+= (i for i in """".join(str(count))); i+=len([i for i in """".join(str(count))])
                i, count =i+1, 1
            else:
                if i==len(chars)-1: chars.pop(i); chars+=[i for i in """".join(str(count+1))]; break
                chars.pop(i); count+=1
        return len(chars)      ","auto compress(auto chars) {
    """"""
    :type chars: List[str]
    :rtype: int
    """"""
    curr, count, i = chars[0], 1, 1
    while i<len(chars):
    if chars[i]!=curr:
    curr=chars[i]
    if count>1: chars[:i]+= (i for i in """".join(str(count))); i+=len([i for i in """".join(str(count))])
    i, count =i+1, 1
    else:
    if i==len(chars)-1: chars.pop(i); chars+=[i for i in """".join(str(count+1))]; break
    chars.pop(i); count+=1
    return len(chars)
}"
444.py,"def sequenceReconstruction(self, org, seqs):
        order, orders, graph, seen = collections.defaultdict(int), set(), collections.defaultdict(set), set()
        for seq in seqs:
            for i in range(len(seq)):
                if i > 0:
                    if seq[i] == seq[i - 1]: return False
                    graph[seq[i - 1]].add(seq[i])
                seen.add(seq[i])
        if not seen: return False
        for i in range(len(org) - 1, -1, -1):
            if org[i] in seen: seen.discard(org[i])
            order[org[i]] = max([order[v] for v in graph[org[i]]] or [0]) + 1
            before = set(v for v in graph[org[i]] if v in seen) 
            if order[org[i]] in orders or before:
                return False
            orders.add(order[org[i]])
        return not seen","auto sequenceReconstruction(auto org, auto seqs) {
    order, orders, graph, seen = collections.defaultdict(int), set(), collections.defaultdict(set), set()
    for seq in seqs:
    for i in range(len(seq)):
    if i > 0:
    if seq[i] == seq[i - 1]: return False
    graph[seq[i - 1]].add(seq[i])
    seen.add(seq[i])
    if not seen: return False
    for i in range(len(org) - 1, -1, -1):
    if org[i] in seen: seen.discard(org[i])
    order[org[i]] = max([order[v] for v in graph[org[i]]] or [0]) + 1
    before = set(v for v in graph[org[i]] if v in seen)
    if order[org[i]] in orders or before:
    return False
    orders.add(order[org[i]])
    return not seen
}"
445.py,"def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        s1, s2, s3 = [], [], []
        p1, p2 = l1, l2
        while p1:
            s1.append(p1.val)
            p1 = p1.next
        while p2:
            s2.append(p2.val)
            p2 = p2.next
        if len(s1) < len(s2):
            s1, s2 = s2, s1
            l1, l2 = l2, l1
        residual = 0
        while len(s1) > 0:
            temp = s1.pop() + residual
            if len(s2) > 0:
                temp += s2.pop()
            s3.append(temp % 10)
            residual = temp // 10
        head, p = ListNode(1), l1
        head.next = p
        while len(s3) > 0:
            p.val = s3.pop()
            p = p.next
        return head if residual == 1 else head.next","auto addTwoNumbers(auto l1, auto l2) {
    s1, s2, s3 = [], [], []
    p1, p2 = l1, l2
    while p1:
    s1.append(p1.val)
    p1 = p1.next
    while p2:
    s2.append(p2.val)
    p2 = p2.next
    if len(s1) < len(s2):
    s1, s2 = s2, s1
    l1, l2 = l2, l1
    residual = 0
    while len(s1) > 0:
    temp = s1.pop() + residual
    if len(s2) > 0:
    temp += s2.pop()
    s3.append(temp % 10)
    residual = temp // 10
    head, p = ListNode(1), l1
    head.next = p
    while len(s3) > 0:
    p.val = s3.pop()
    p = p.next
    return head if residual == 1 else head.next
}"
446.py,"def numberOfArithmeticSlices(self, A):
        dp, res = collections.defaultdict(dict), 0
        for j in range(len(A)):
            for i in range(j):
                dp[j][A[j] - A[i]] = dp[j].get(A[j] - A[i], 0) + dp[i].get(A[j] - A[i], 1) 
                if A[j] - A[i] in dp[i]: res, dp[j][A[j] - A[i]] = res + dp[i][A[j] - A[i]], dp[j][A[j] - A[i]] + 1
        return res           ","auto numberOfArithmeticSlices(auto A) {
    dp, res = collections.defaultdict(dict), 0
    for j in range(len(A)):
    for i in range(j):
    dp[j][A[j] - A[i]] = dp[j].get(A[j] - A[i], 0) + dp[i].get(A[j] - A[i], 1)
    if A[j] - A[i] in dp[i]: res, dp[j][A[j] - A[i]] = res + dp[i][A[j] - A[i]], dp[j][A[j] - A[i]] + 1
    return res
}"
448.py,"def findDisappearedNumbers(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        return [x for x in set([i for i in range(1,len(nums)+1)])-set(nums)]","auto findDisappearedNumbers(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: List[int]
    """"""
    return [x for x in set([i for i in range(1,len(nums)+1)])-set(nums)]
}"
45.py,"def jump(self, nums):
        last = cur = jump = i = 0
        while cur < len(nums) - 1:
            while i <= last:
                if i + nums[i] > cur: cur = i + nums[i]
                i += 1
            last = cur
            jump += 1
        return jump","auto jump(auto nums) {
    last = cur = jump = i = 0
    while cur < len(nums) - 1:
    while i <= last:
    if i + nums[i] > cur: cur = i + nums[i]
    i += 1
    last = cur
    jump += 1
    return jump
}"
451.py,"def frequencySort(self, s: str) -> str:
        cnt = collections.Counter(s)
        res = ''
        for k, v in sorted(cnt.items(), key = lambda x: -cnt[x[0]]):
            res += k * v
        return res","auto frequencySort(auto s) {
    cnt = collections.Counter(s)
    res = ''
    for k, v in sorted(cnt.items(), key = lambda x: -cnt[x[0]]):
    res += k * v
    return res
}"
452.py,"def findMinArrowShots(self, p):
        p.sort(key = lambda x: x[1])
        (res, curr) = (1, p[0][1]) if p else (0, None)
        for n in p:
            if n[0] > curr: res, curr = res + 1, n[1]
        return res","auto findMinArrowShots(auto p) {
    p.sort(key = lambda x: x[1])
    (res, curr) = (1, p[0][1]) if p else (0, None)
    for n in p:
    if n[0] > curr: res, curr = res + 1, n[1]
    return res
}"
453.py,"def minMoves(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        return sum(nums) - min(nums) * len(nums) ","auto minMoves(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: int
    """"""
    return sum(nums) - min(nums) * len(nums)
}"
454.py,"def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:
        ab = collections.Counter([a + b for a in A for b in B])
        return sum(-c - d in ab and ab[-c-d] for c in C for d in D)","auto fourSumCount(auto A, auto B, auto C, auto D) {
    ab = collections.Counter([a + b for a in A for b in B])
    return sum(-c - d in ab and ab[-c-d] for c in C for d in D)
}"
455.py,"def findContentChildren(self, g, s):
        g.sort(reverse = True); s.sort(reverse = True); res = 0
        while s and g:
            if g[-1] <= s[-1]: res += 1; g.pop(); s.pop()
            else: s.pop()
        return res","auto findContentChildren(auto g, auto s) {
    g.sort(reverse = True); s.sort(reverse = True); res = 0
    while s and g:
    if g[-1] <= s[-1]: res += 1; g.pop(); s.pop()
    else: s.pop()
    return res
}"
456.py,"def find132pattern(self, nums):
        stack, s3 = [], -float(""inf"")
        for n in nums[::-1]:
            if n < s3: return True
            while stack and stack[-1] < n: s3 = stack.pop()
            stack.append(n)
        return False","auto find132pattern(auto nums) {
    stack, s3 = [], -float(""inf"")
    for n in nums[::-1]:
    if n < s3: return True
    while stack and stack[-1] < n: s3 = stack.pop()
    stack.append(n)
    return False
}"
459.py,"def repeatedSubstringPattern(self, s):
        """"""
        :type s: str
        :rtype: bool
        """"""
        return True if len(s)>1 and (s in [s[:i]*(len(s)//i) for i in range(2,len(s)) if len(s)%i==0]  or s==s[0]*len(s)) else False ","auto repeatedSubstringPattern(auto s) {
    """"""
    :type s: str
    :rtype: bool
    """"""
    return True if len(s)>1 and (s in [s[:i]*(len(s)//i) for i in range(2,len(s)) if len(s)%i==0]  or s==s[0]*len(s)) else False
}"
461.py,"def hammingDistance(self, x: int, y: int) -> int:
        return sum(a != b for a, b in zip(bin(x)[2:].zfill(32), bin(y)[2:].zfill(32)))","auto hammingDistance(auto x, auto y) {
    return sum(a != b for a, b in zip(bin(x)[2:].zfill(32), bin(y)[2:].zfill(32)))
}"
462.py,"def minMoves2(self, nums):
        nums.sort()
        m = nums[(len(nums) - 1) // 2] 
        return sum(abs(num - m) for num in nums)","auto minMoves2(auto nums) {
    nums.sort()
    m = nums[(len(nums) - 1) // 2]
    return sum(abs(num - m) for num in nums)
}"
463.py,"def islandPerimeter(self, grid: List[List[int]]) -> int:
        self.res = 0
        used = set()
        def dfs(i, j):
            used.add((i, j))
            self.res += 4
            for x, y in (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1):
                if 0 <= x < m and 0 <= y < n and grid[x][y]:
                    self.res -= 1
                    if (x, y) not in used:
                        dfs(x, y)
        m, n = len(grid), len(grid[0])
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1 and (i, j) not in used:
                    dfs(i, j)
        return self.res","auto islandPerimeter(auto grid) {
    self.res = 0
    used = set()
    def dfs(i, j):
    used.add((i, j))
    self.res += 4
    for x, y in (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1):
    if 0 <= x < m and 0 <= y < n and grid[x][y]:
    self.res -= 1
    if (x, y) not in used:
    dfs(x, y)
    m, n = len(grid), len(grid[0])
    for i in range(m):
    for j in range(n):
    if grid[i][j] == 1 and (i, j) not in used:
    dfs(i, j)
    return self.res
}"
464.py,"def canIWin(self, maxChoosableInteger, desiredTotal):
        memo = {}
        def dfs(arr, total):
            s = str(arr)
            if s in memo:
                return memo[s]
            elif arr[-1] >= total:
                return True
            for i in range(len(arr)):
                if not dfs(arr[:i] + arr[i + 1:], total - arr[i]):
                    memo[s] = True
                    return True
            memo[s] = False
            return False
        if (1 + maxChoosableInteger) * maxChoosableInteger/2 < desiredTotal:
            return False
        return dfs(list(range(1, maxChoosableInteger + 1)), desiredTotal)","auto canIWin(auto maxChoosableInteger, auto desiredTotal) {
    memo = {}
    def dfs(arr, total):
    s = str(arr)
    if s in memo:
    return memo[s]
    elif arr[-1] >= total:
    return True
    for i in range(len(arr)):
    if not dfs(arr[:i] + arr[i + 1:], total - arr[i]):
    memo[s] = True
    return True
    memo[s] = False
    return False
    if (1 + maxChoosableInteger) * maxChoosableInteger/2 < desiredTotal:
    return False
    return dfs(list(range(1, maxChoosableInteger + 1)), desiredTotal)
}"
465.py,"def minTransfers(self, transactions: List[List[int]]) -> int:
        def remove_one_zero_clique(non_zero):
            n = len(non_zero)
            q = collections.deque()            
            # q store ([index set], sum of set)
            q.append(([0], non_zero[0]))
            min_zero_set = None

            while q:
                cur_set, cur_sum = q.popleft()
                if cur_sum == 0:
                    min_zero_set = cur_set
                    break
                for j in range(cur_set[-1] + 1, n):
                    q.append((cur_set + [j], cur_sum + non_zero[j]))
            
            min_zero_set = set(min_zero_set)
            return [non_zero[i] for i in range(n) if i not in min_zero_set]
        
        
        bal = collections.defaultdict(int)
        for t in transactions:
            bal[t[0]] -= t[2]
            bal[t[1]] += t[2]
        non_zero = [bal[k] for k in bal if bal[k] != 0]
        
        bal_cnt = len(non_zero)
        while len(non_zero) > 0:
            non_zero = remove_one_zero_clique(non_zero)
            bal_cnt -= 1
        return bal_cnt","auto minTransfers(auto transactions) {
    def remove_one_zero_clique(non_zero):
    n = len(non_zero)
    q = collections.deque()
    # q store ([index set], sum of set)
    q.append(([0], non_zero[0]))
    min_zero_set = nullptr
    
    while q:
    cur_set, cur_sum = q.popleft()
    if cur_sum == 0:
    min_zero_set = cur_set
    break
    for j in range(cur_set[-1] + 1, n):
    q.append((cur_set + [j], cur_sum + non_zero[j]))
    
    min_zero_set = set(min_zero_set)
    return [non_zero[i] for i in range(n) if i not in min_zero_set]
    
    
    bal = collections.defaultdict(int)
    for t in transactions:
    bal[t[0]] -= t[2]
    bal[t[1]] += t[2]
    non_zero = [bal[k] for k in bal if bal[k] != 0]
    
    bal_cnt = len(non_zero)
    while len(non_zero) > 0:
    non_zero = remove_one_zero_clique(non_zero)
    bal_cnt -= 1
    return bal_cnt
}"
467.py,"def findSubstringInWraproundString(self, p):
        res, l = {i: 1 for i in p}, 1
        for i, j in zip(p, p[1:]):
            l = l + 1 if (ord(j) - ord(i)) % 26 == 1 else 1
            res[j] = max(res[j], l)
        return sum(res.values())","auto findSubstringInWraproundString(auto p) {
    res, l = {i: 1 for i in p}, 1
    for i, j in zip(p, p[1:]):
    l = l + 1 if (ord(j) - ord(i)) % 26 == 1 else 1
    res[j] = max(res[j], l)
    return sum(res.values())
}"
468.py,"def validIPAddress(self, IP):
        """"""
        :type IP: str
        :rtype: str
        """"""
        ip4, ip6 = IP.split("".""), IP.split("":"")
        if len(ip4) == 4:
            for num in ip4:
                try: 
                    if not (num[0] in string.digits and int(num) < 256 and (num[0] != ""0"" or num == ""0"")): return ""Neither""
                except: return ""Neither""
            return ""IPv4""
        elif len(ip6) == 8:
            for num in ip6:
                try: 
                    if not (num[0] in string.hexdigits and 0 <= int(num, 16) and len(num) <= 4): return ""Neither""
                except: return ""Neither""
            return ""IPv6""
        return ""Neither""","auto validIPAddress(auto IP) {
    """"""
    :type IP: str
    :rtype: str
    """"""
    ip4, ip6 = IP.split("".""), IP.split("":"")
    if len(ip4) == 4:
    for num in ip4:
    try:
    if not (num[0] in string.digits and int(num) < 256 and (num[0] != ""0"" or num == ""0"")): return ""Neither""
    except: return ""Neither""
    return ""IPv4""
    elif len(ip6) == 8:
    for num in ip6:
    try:
    if not (num[0] in string.hexdigits and 0 <= int(num, 16) and len(num) <= 4): return ""Neither""
    except: return ""Neither""
    return ""IPv6""
    return ""Neither""
}"
469.py,"def isConvex(self, points):
        def direction(a, b, c): return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])
        d, n = 0, len(points)
        for i in range(n):
            a = direction(points[i], points[(i + 1) % n], points[(i + 2) % n])
            if not d: d = a
            elif a * d < 0: return False
        return True","auto isConvex(auto points) {
    def direction(a, b, c): return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])
    d, n = 0, len(points)
    for i in range(n):
    a = direction(points[i], points[(i + 1) % n], points[(i + 2) % n])
    if not d: d = a
    elif a * d < 0: return False
    return True
}"
47.py,"def permuteUnique(self, nums):
        dic = set()
        for p in itertools.permutations(nums):
            if p not in dic: 
                dic.add(p)
        return list(dic)","auto permuteUnique(auto nums) {
    dic = set()
    for p in itertools.permutations(nums):
    if p not in dic:
    dic.add(p)
    return list(dic)
}"
470.py,"def rand10(self):
        return sum(rand7() for _ in range(10)) % 10 + 1","auto rand10() {
    return sum(rand7() for _ in range(10)) % 10 + 1
}"
471.py,"def encode(self, s: str) -> str:
        def dfs(i, j):
            if i == j: return s[i]
            if (i, j) not in memo:
                c1 = min((dfs(i, k) + dfs(k + 1, j) if s[i:k + 1] != s[k + 1:j + 1] else '2[' + dfs(i, k) + ']' for k in range(i, j)), key = len)
                c2 = s[i:j + 1]
                memo[(i, j)] = min(c1, c2, key = len)
                for k in range(i, i + (j - i) // 2 + 1):
                    tar, ind, cnt = s[i:k + 1], i, 0
                    while ind + k - i <= j and s[ind:ind + k - i + 1] == tar:
                        cnt += 1
                        ind += k - i + 1
                    c3 = str(cnt) + '[' + tar + ']' + dfs(ind, j) if ind <= j else str(cnt) + '[' + tar + ']'
                    memo[(i, j)] = min(memo[(i, j)], c3, key = len)
            return memo[(i, j)]
        memo = {}
        return dfs(0, len(s) - 1)","auto encode(auto s) {
    def dfs(i, j):
    if i == j: return s[i]
    if (i, j) not in memo:
    c1 = min((dfs(i, k) + dfs(k + 1, j) if s[i:k + 1] != s[k + 1:j + 1] else '2[' + dfs(i, k) + ']' for k in range(i, j)), key = len)
    c2 = s[i:j + 1]
    memo[(i, j)] = min(c1, c2, key = len)
    for k in range(i, i + (j - i) // 2 + 1):
    tar, ind, cnt = s[i:k + 1], i, 0
    while ind + k - i <= j and s[ind:ind + k - i + 1] == tar:
    cnt += 1
    ind += k - i + 1
    c3 = str(cnt) + '[' + tar + ']' + dfs(ind, j) if ind <= j else str(cnt) + '[' + tar + ']'
    memo[(i, j)] = min(memo[(i, j)], c3, key = len)
    return memo[(i, j)]
    memo = {}
    return dfs(0, len(s) - 1)
}"
472.py,"def findAllConcatenatedWordsInADict(self, words):
        def check(w, st):
            if w in st: return True
            for i in range(1, len(w)):
                if w[:i] in st and check(w[i:], st): return True
            return False
        w_set, res = set(words), []
        for w in words:
            w_set.remove(w)
            if check(w, w_set): res += w,
            w_set.add(w)
        return res","auto findAllConcatenatedWordsInADict(auto words) {
    def check(w, st):
    if w in st: return True
    for i in range(1, len(w)):
    if w[:i] in st and check(w[i:], st): return True
    return False
    w_set, res = set(words), []
    for w in words:
    w_set.remove(w)
    if check(w, w_set): res += w,
    w_set.add(w)
    return res
}"
473.py,"def makesquare(self, nums):
        def dfs(index, edge, count, used):
            for i in range(index, len(nums)):
                if i in used or edge - nums[i] < 0: continue
                elif edge - nums[i] > 0 and dfs(i + 1, edge - nums[i], count, used | {i}): return True
                elif edge - nums[i] == 0 and (count and dfs(1, l, count - 1, used | {i})) or not count: return True
            return False
        sm = sum(nums)
        if len(nums) < 4 or sm % 4 != 0: return False
        l = sm // 4 
        nums.sort(reverse = True)
        if nums[0] > l: return False
        return nums[0] == l and dfs(1, l, 1, {0}) or dfs(1, l - nums[0], 2, {0})","auto makesquare(auto nums) {
    def dfs(index, edge, count, used):
    for i in range(index, len(nums)):
    if i in used or edge - nums[i] < 0: continue
    elif edge - nums[i] > 0 and dfs(i + 1, edge - nums[i], count, used | {i}): return True
    elif edge - nums[i] == 0 and (count and dfs(1, l, count - 1, used | {i})) or not count: return True
    return False
    sm = sum(nums)
    if len(nums) < 4 or sm % 4 != 0: return False
    l = sm // 4
    nums.sort(reverse = True)
    if nums[0] > l: return False
    return nums[0] == l and dfs(1, l, 1, {0}) or dfs(1, l - nums[0], 2, {0})
}"
474.py,"def findMaxForm(self, strs, m, n):
        res = [0]
        memo = set()
        def dfs(st, zeros, ones, cnt):
            if (zeros, ones, cnt) not in memo:
                if cnt > res[0]:
                    res[0] = cnt
                if zeros or ones:
                    for s in st:
                        if st[s] and cntr[s][""0""] <= zeros and cntr[s][""1""] <= ones:
                            st[s] -= 1
                            dfs(st, zeros - cntr[s][""0""], ones - cntr[s][""1""], cnt + 1)
                            st[s] += 1
                memo.add((zeros, ones, cnt))
                
        cntr = {s:collections.Counter(s) for s in strs}
        dfs(collections.Counter(strs), m, n, 0)
        return res[0]","auto findMaxForm(auto strs, auto m, auto n) {
    res = [0]
    memo = set()
    def dfs(st, zeros, ones, cnt):
    if (zeros, ones, cnt) not in memo:
    if cnt > res[0]:
    res[0] = cnt
    if zeros or ones:
    for s in st:
    if st[s] and cntr[s][""0""] <= zeros and cntr[s][""1""] <= ones:
    st[s] -= 1
    dfs(st, zeros - cntr[s][""0""], ones - cntr[s][""1""], cnt + 1)
    st[s] += 1
    memo.add((zeros, ones, cnt))
    
    cntr = {s:collections.Counter(s) for s in strs}
    dfs(collections.Counter(strs), m, n, 0)
    return res[0]
}"
475.py,"def findRadius(self, houses, heaters):
        heaters.sort()
        r = 0
        for h in houses:
            ind = bisect.bisect_left(heaters, h)
            if ind == len(heaters):
                r = max(r, h - heaters[-1])
            elif ind == 0:
                r = max(r, heaters[0] - h)
            else:
                r = max(r, min(heaters[ind] - h, h - heaters[ind - 1]))
        return r","auto findRadius(auto houses, auto heaters) {
    heaters.sort()
    r = 0
    for h in houses:
    ind = bisect.bisect_left(heaters, h)
    if ind == len(heaters):
    r = max(r, h - heaters[-1])
    elif ind == 0:
    r = max(r, heaters[0] - h)
    else:
    r = max(r, min(heaters[ind] - h, h - heaters[ind - 1]))
    return r
}"
476.py,"def findComplement(self, num):
        """"""
        :type num: int
        :rtype: int
        """"""
        return int("""".join([str((int(i)+1)%2) for i in bin(num)[2:]]),2)","auto findComplement(auto num) {
    """"""
    :type num: int
    :rtype: int
    """"""
    return int("""".join([str((int(i)+1)%2) for i in bin(num)[2:]]),2)
}"
477.py,"def totalHammingDistance(self, nums):
        ones, n, res = [0] * 32, len(nums), 0
        for num in nums:
            for i, c in enumerate(bin(num)[2:][::-1]):
                if c == ""1"": ones[i] += 1
        for one in ones: res += one * (n - one)
        return res","auto totalHammingDistance(auto nums) {
    ones, n, res = [0] * 32, len(nums), 0
    for num in nums:
    for i, c in enumerate(bin(num)[2:][::-1]):
    if c == ""1"": ones[i] += 1
    for one in ones: res += one * (n - one)
    return res
}"
478.py,"def __init__(self, radius, x_center, y_center):
        self.x, self.y, self.r = x_center, y_center, radius

    def randPoint(self):
        r, angle, scale = random.uniform(0, self.r), random.uniform(0, 2 * math.pi), math.sqrt(random.uniform(0, 1))
        return [self.x + self.r * scale * math.cos(angle), self.y + self.r * scale * math.sin(angle)]","auto __init__(auto radius, auto x_center, auto y_center) {
    self.x, self.y, self.r = x_center, y_center, radius
    
    def randPoint(self):
    r, angle, scale = random.uniform(0, self.r), random.uniform(0, 2 * math.pi), math.sqrt(random.uniform(0, 1))
    return [self.x + self.r * scale * math.cos(angle), self.y + self.r * scale * math.sin(angle)]
}"
479.py,"def largestPalindrome(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        return list(num for i,num in enumerate([0,9,987,123,597,677,1218,877,475]) if i==n)[0]","auto largestPalindrome(auto n) {
    """"""
    :type n: int
    :rtype: int
    """"""
    return list(num for i,num in enumerate([0,9,987,123,597,677,1218,877,475]) if i==n)[0]
}"
480.py,"def medianSlidingWindow(self, nums, k):
        window = sorted(nums[:k])
        medians = []
        for a, b in zip(nums, nums[k:] + [0]):
            medians.append((window[k//2] + window[~(k//2)]) / 2.)
            window.remove(a)
            bisect.insort(window, b)
        return medians","auto medianSlidingWindow(auto nums, auto k) {
    window = sorted(nums[:k])
    medians = []
    for a, b in zip(nums, nums[k:] + [0]):
    medians.append((window[k//2] + window[~(k//2)]) / 2.)
    window.remove(a)
    bisect.insort(window, b)
    return medians
}"
482.py,"def licenseKeyFormatting(self, S, K):
        S = S.replace(""-"", """").upper()[::-1]
        return '-'.join([S[i:i+K] for i in range(0, len(S), K)])[::-1]","auto licenseKeyFormatting(auto S, auto K) {
    S = S.replace(""-"", """").upper()[::-1]
    return '-'.join([S[i:i+K] for i in range(0, len(S), K)])[::-1]
}"
483.py,"def smallestGoodBase(self, n):
        n = int(n)
        for m in range(int(math.log(n, 2)), 1, -1):
            k = int(n ** m ** -1)
            if (k ** (m + 1) -1) // (k - 1) == n:
                return str(k)
        return str(n-1) ","auto smallestGoodBase(auto n) {
    n = int(n)
    for m in range(int(math.log(n, 2)), 1, -1):
    k = int(n ** m ** -1)
    if (k ** (m + 1) -1) // (k - 1) == n:
    return str(k)
    return str(n-1)
}"
484.py,"def findPermutation(self, s):
        arr, cnt, n = list(range(1, len(s) + 2)), 0, len(s)
        for i in range(n + 1):
            if i < n and s[i] == ""D"":
                cnt += 1
            elif cnt:
                arr[i - cnt:i + 1] =  arr[i - cnt:i + 1][::-1]
                cnt = 0
        return arr","auto findPermutation(auto s) {
    arr, cnt, n = list(range(1, len(s) + 2)), 0, len(s)
    for i in range(n + 1):
    if i < n and s[i] == ""D"":
    cnt += 1
    elif cnt:
    arr[i - cnt:i + 1] =  arr[i - cnt:i + 1][::-1]
    cnt = 0
    return arr
}"
485.py,"def findMaxConsecutiveOnes(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        cons=[0,0]
        for num in nums:
            if num==1:cons[1]+=1
            else:cons[1]=0
            cons[0]=max(cons[0],cons[1])
        return cons[0]
        ","auto findMaxConsecutiveOnes(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: int
    """"""
    cons=[0,0]
    for num in nums:
    if num==1:cons[1]+=1
    else:cons[1]=0
    cons[0]=max(cons[0],cons[1])
    return cons[0]
}"
486.py,"def PredictTheWinner(self, nums):
        def dfs(l, r, p1, p2, turn):
            if l > r:
                return p1 >= p2
            elif turn:
                return dfs(l + 1, r, p1 + nums[l], p2, 0) or dfs(l, r - 1, p1 + nums[r], p2, 0)
            else:
                return dfs(l + 1, r, p1, p2 + nums[l], 1) and dfs(l, r - 1, p1, p2 + nums[r], 1)
        return dfs(0, len(nums) - 1, 0, 0, 1)","auto PredictTheWinner(auto nums) {
    def dfs(l, r, p1, p2, turn):
    if l > r:
    return p1 >= p2
    elif turn:
    return dfs(l + 1, r, p1 + nums[l], p2, 0) or dfs(l, r - 1, p1 + nums[r], p2, 0)
    else:
    return dfs(l + 1, r, p1, p2 + nums[l], 1) and dfs(l, r - 1, p1, p2 + nums[r], 1)
    return dfs(0, len(nums) - 1, 0, 0, 1)
}"
487.py,"def findMaxConsecutiveOnes(self, nums):
        l, zero, mx = 0, -1, 0
        for r, num in enumerate(nums + [0]):
            if not num:
                l, zero, mx = zero + 1, r, max(mx, r - l)
        return mx","auto findMaxConsecutiveOnes(auto nums) {
    l, zero, mx = 0, -1, 0
    for r, num in enumerate(nums + [0]):
    if not num:
    l, zero, mx = zero + 1, r, max(mx, r - l)
    return mx
}"
488.py,"def findMinStep(self, board, hand):   
        def dfs(s, c):
            if not s: return 0
            res, i = float(""inf""), 0
            while i < len(s):
                j = i + 1
                while j < len(s) and s[i] == s[j]: j += 1
                incr = 3 - (j - i)
                if c[s[i]] >= incr:
                    incr = 0 if incr < 0 else incr
                    c[s[i]] -= incr
                    tep = dfs(s[:i] + s[j:], c)
                    if tep >= 0: res = min(res, tep + incr)
                    c[s[i]] += incr
                i = j
            return res if res != float(""inf"") else -1
        return dfs(board, collections.Counter(hand))","auto findMinStep(auto board, auto hand) {
    def dfs(s, c):
    if not s: return 0
    res, i = float(""inf""), 0
    while i < len(s):
    j = i + 1
    while j < len(s) and s[i] == s[j]: j += 1
    incr = 3 - (j - i)
    if c[s[i]] >= incr:
    incr = 0 if incr < 0 else incr
    c[s[i]] -= incr
    tep = dfs(s[:i] + s[j:], c)
    if tep >= 0: res = min(res, tep + incr)
    c[s[i]] += incr
    i = j
    return res if res != float(""inf"") else -1
    return dfs(board, collections.Counter(hand))
}"
49.py,"def groupAnagrams(self, strs):
        dic = collections.defaultdict(list)
        for s in strs: 
            dic["""".join(sorted(s))].append(s)
        return list(dic.values())","auto groupAnagrams(auto strs) {
    dic = collections.defaultdict(list)
    for s in strs:
    dic["""".join(sorted(s))].append(s)
    return list(dic.values())
}"
490.py,"def hasPath(self, maze, start, destination):
        m, n, stopped = len(maze), len(maze[0]), set()
        def dfs(x, y):
            if (x, y) in stopped: 
                return False
            stopped.add((x, y))
            if [x, y] == destination:
                return True
            for i, j in (-1, 0) , (1, 0), (0, -1), (0, 1):
                newX, newY = x, y
                while 0 <= newX + i < m and 0 <= newY + j < n and maze[newX + i][newY + j] != 1:
                    newX += i
                    newY += j
                if dfs(newX, newY):
                    return True
            return False
        return dfs(*start)","auto hasPath(auto maze, auto start, auto destination) {
    m, n, stopped = len(maze), len(maze[0]), set()
    def dfs(x, y):
    if (x, y) in stopped:
    return False
    stopped.add((x, y))
    if [x, y] == destination:
    return True
    for i, j in (-1, 0) , (1, 0), (0, -1), (0, 1):
    newX, newY = x, y
    while 0 <= newX + i < m and 0 <= newY + j < n and maze[newX + i][newY + j] != 1:
    newX += i
    newY += j
    if dfs(newX, newY):
    return True
    return False
    return dfs(*start)
}"
491.py,"def findSubsequences(self, nums):
        subs = {()}
        for num in nums:
            subs |= {sub + (num,) for sub in subs if not sub or sub[-1] <= num}
        return [sub for sub in subs if len(sub) >= 2]","auto findSubsequences(auto nums) {
    subs = {()}
    for num in nums:
    subs |= {sub + (num,) for sub in subs if not sub or sub[-1] <= num}
    return [sub for sub in subs if len(sub) >= 2]
}"
492.py,"def constructRectangle(self, area):
        """"""
        :type area: int
        :rtype: List[int]
        """"""
        import math
        l, w = int(math.sqrt(area)), int(math.sqrt(area))
        while l*w!=area:
            if area%w==0: l=int(area/w)
            else: w-=1
        return [l,w]","auto constructRectangle(auto area) {
    """"""
    :type area: int
    :rtype: List[int]
    """"""
    import math
    l, w = int(math.sqrt(area)), int(math.sqrt(area))
    while l*w!=area:
    if area%w==0: l=int(area/w)
    else: w-=1
    return [l,w]
}"
493.py,"def reversePairs(self, nums: List[int]) -> int:
        res = [0]
        def merge(nums):
            if len(nums) <= 1: return nums
            left, right = merge(nums[:len(nums)//2]), merge(nums[len(nums)//2:])
            for r in right:
                add = len(left) - bisect.bisect(left, 2 * r)
                if not add: break
                res[0] += add
            return sorted(left+right)
        merge(nums)
        return res[0]","auto reversePairs(auto nums) {
    res = [0]
    def merge(nums):
    if len(nums) <= 1: return nums
    left, right = merge(nums[:len(nums)//2]), merge(nums[len(nums)//2:])
    for r in right:
    add = len(left) - bisect.bisect(left, 2 * r)
    if not add: break
    res[0] += add
    return sorted(left+right)
    merge(nums)
    return res[0]
}"
494.py,"def findTargetSumWays(self, nums, S):
        d = {S:1}
        for i in range(len(nums)):
            new_d = collections.defaultdict(int)
            for k, v in d.items():
                new_d[k+nums[i]] += v
                new_d[k-nums[i]] += v
            d = new_d
        return d[0]","auto findTargetSumWays(auto nums, auto S) {
    d = {S:1}
    for i in range(len(nums)):
    new_d = collections.defaultdict(int)
    for k, v in d.items():
    new_d[k+nums[i]] += v
    new_d[k-nums[i]] += v
    d = new_d
    return d[0]
}"
495.py,"def findPoisonedDuration(self, timeSeries, duration):
        """"""
        :type timeSeries: List[int]
        :type duration: int
        :rtype: int
        """"""
        timeSeries.sort()
        res, upper = 0, 0
        for i, num in enumerate(timeSeries): 
            if num > upper: upper = num
            res, upper = res + num + duration - upper, num + duration
        return res","auto findPoisonedDuration(auto timeSeries, auto duration) {
    """"""
    :type timeSeries: List[int]
    :type duration: int
    :rtype: int
    """"""
    timeSeries.sort()
    res, upper = 0, 0
    for i, num in enumerate(timeSeries):
    if num > upper: upper = num
    res, upper = res + num + duration - upper, num + duration
    return res
}"
496.py,"def nextGreaterElement(self, nums1, nums2):
        """"""
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """"""
        out=list()
        for num in nums1: 
            out.append(-1)
            for j in range(nums2.index(num)+1,len(nums2)):
                if nums2[j]>num: out[-1]=nums2[j]; break
        return out","auto nextGreaterElement(auto nums1, auto nums2) {
    """"""
    :type nums1: List[int]
    :type nums2: List[int]
    :rtype: List[int]
    """"""
    out=list()
    for num in nums1:
    out.append(-1)
    for j in range(nums2.index(num)+1,len(nums2)):
    if nums2[j]>num: out[-1]=nums2[j]; break
    return out
}"
497.py,"def __init__(self, rects):
        self.rects, self.ranges, sm = rects, [], 0
        for x1, y1, x2, y2 in rects:
            sm += (x2 - x1 + 1) * (y2 - y1 + 1)
            self.ranges.append(sm)

    def pick(self):
        x1, y1, x2, y2 = self.rects[bisect.bisect_left(self.ranges, random.randint(1, self.ranges[-1]))]
        return [random.randint(x1, x2), random.randint(y1, y2)]","auto __init__(auto rects) {
    self.rects, self.ranges, sm = rects, [], 0
    for x1, y1, x2, y2 in rects:
    sm += (x2 - x1 + 1) * (y2 - y1 + 1)
    self.ranges.append(sm)
    
    def pick(self):
    x1, y1, x2, y2 = self.rects[bisect.bisect_left(self.ranges, random.randint(1, self.ranges[-1]))]
    return [random.randint(x1, x2), random.randint(y1, y2)]
}"
498.py,"def findDiagonalOrder(self, matrix):
        i, j, d, res, n, m = 0, 0, 1, [], len(matrix), len(matrix and matrix[0]) 
        while i < n and j < m:
            res.append(matrix[i][j])
            if j + 1 < m and (i == 0 and d == 1) or (i == n - 1 and d == -1): j, d = j + 1, -d
            elif i + 1 < n and (j == 0 and d == -1) or (j == m - 1 and d == 1): i, d = i + 1, -d
            elif d == 1: i, j = i - 1, j + 1
            else: i, j = i + 1, j - 1
        return res","auto findDiagonalOrder(auto matrix) {
    i, j, d, res, n, m = 0, 0, 1, [], len(matrix), len(matrix and matrix[0])
    while i < n and j < m:
    res.append(matrix[i][j])
    if j + 1 < m and (i == 0 and d == 1) or (i == n - 1 and d == -1): j, d = j + 1, -d
    elif i + 1 < n and (j == 0 and d == -1) or (j == m - 1 and d == 1): i, d = i + 1, -d
    elif d == 1: i, j = i - 1, j + 1
    else: i, j = i + 1, j - 1
    return res
}"
499.py,"def findShortestWay(self, maze, ball, hole):
        m, n, q, stopped = len(maze), len(maze[0]), [(0, """", ball[0], ball[1])], {(ball[0], ball[1]): [0, """"]}
        while q:
            dist, pattern, x, y = heapq.heappop(q)
            if [x, y] == hole:
                return pattern
            for i, j, p in ((-1, 0, ""u""), (1, 0, ""d""), (0, -1, ""l""), (0, 1, ""r"")):
                newX, newY, d = x, y, 0
                while 0 <= newX + i < m and 0 <= newY + j < n and maze[newX + i][newY + j] != 1:
                    newX += i
                    newY += j
                    d += 1
                    if [newX, newY] == hole:
                        break
                if (newX, newY) not in stopped or [dist + d, pattern + p] < stopped[(newX, newY)]:
                    stopped[(newX, newY)] = [dist + d, pattern + p]
                    heapq.heappush(q, (dist + d, pattern + p, newX, newY))
        return ""impossible""","auto findShortestWay(auto maze, auto ball, auto hole) {
    m, n, q, stopped = len(maze), len(maze[0]), [(0, """", ball[0], ball[1])], {(ball[0], ball[1]): [0, """"]}
    while q:
    dist, pattern, x, y = heapq.heappop(q)
    if [x, y] == hole:
    return pattern
    for i, j, p in ((-1, 0, ""u""), (1, 0, ""d""), (0, -1, ""l""), (0, 1, ""r"")):
    newX, newY, d = x, y, 0
    while 0 <= newX + i < m and 0 <= newY + j < n and maze[newX + i][newY + j] != 1:
    newX += i
    newY += j
    d += 1
    if [newX, newY] == hole:
    break
    if (newX, newY) not in stopped or [dist + d, pattern + p] < stopped[(newX, newY)]:
    stopped[(newX, newY)] = [dist + d, pattern + p]
    heapq.heappush(q, (dist + d, pattern + p, newX, newY))
    return ""impossible""
}"
5.py,"def longestPalindrome(self, s: str) -> str:
        def check(l, r):
            while 0 <= l <= r < len(s) and s[l] == s[r]:
                l -= 1
                r += 1
            return s[l + 1:r]
        pals = [check(i, i) for i in range(len(s))] + [check(i, i + 1) for i in range(len(s) - 1) if s[i] == s[i + 1]]
        return sorted(pals, key = len)[-1] if pals else ''","auto longestPalindrome(auto s) {
    def check(l, r):
    while 0 <= l <= r < len(s) and s[l] == s[r]:
    l -= 1
    r += 1
    return s[l + 1:r]
    pals = [check(i, i) for i in range(len(s))] + [check(i, i + 1) for i in range(len(s) - 1) if s[i] == s[i + 1]]
    return sorted(pals, key = len)[-1] if pals else ''
}"
50.py,"def myPow(self, x: float, n: int) -> float:
        if n < 0:
            n *= -1
            x = 1 / x
        elif not n:
            return 1
        half = self.myPow(x, n // 2)
        return x * half * half if n % 2 else half * half","auto myPow(auto x, auto n) {
    if n < 0:
    n *= -1
    x = 1 / x
    elif not n:
    return 1
    half = self.myPow(x, n // 2)
    return x * half * half if n % 2 else half * half
}"
500.py,"def findWords(self, words):
        return [w for w in words if any(not set(w.lower()) - row for row in (set(""qwertyuiop""), set(""asdfghjkl""), set(""zxcvbnm"")))]","auto findWords(auto words) {
    return [w for w in words if any(not set(w.lower()) - row for row in (set(""qwertyuiop""), set(""asdfghjkl""), set(""zxcvbnm"")))]
}"
502.py,"def findMaximizedCapital(self, k, W, Profits, Capital):
        pool, new = [], [(c, p) for c, p in zip(Capital, Profits)]
        heapq.heapify(new)
        for i in range(k):
            while new and new[0][0] <= W:
                c, p = heapq.heappop(new)
                heapq.heappush(pool, -p)
            try:
                p = -heapq.heappop(pool)
                W += p
            except:
                break
        return W","auto findMaximizedCapital(auto k, auto W, auto Profits, auto Capital) {
    pool, new = [], [(c, p) for c, p in zip(Capital, Profits)]
    heapq.heapify(new)
    for i in range(k):
    while new and new[0][0] <= W:
    c, p = heapq.heappop(new)
    heapq.heappush(pool, -p)
    try:
    p = -heapq.heappop(pool)
    W += p
    except:
    break
    return W
}"
503.py,"def nextGreaterElements(self, nums):
        stack, res = [], [-1] * len(nums)
        for j in range(2):
            for i in range(len(nums)):
                while stack and (nums[stack[-1]] < nums[i]): res[stack.pop()] = nums[i]
                if j == 1 and not stack: break
                stack += i, 
        return res","auto nextGreaterElements(auto nums) {
    stack, res = [], [-1] * len(nums)
    for j in range(2):
    for i in range(len(nums)):
    while stack and (nums[stack[-1]] < nums[i]): res[stack.pop()] = nums[i]
    if j == 1 and not stack: break
    stack += i,
    return res
}"
504.py,"def convertToBase7(self, num):
        lead = """" if num > 0 else ""0"" if num == 0 else ""-""
        res, num = [], abs(num)
        while num:
            res.append(int(num % 7))
            num //= 7
        return lead + """".join(str(c) for c in res[::-1])","auto convertToBase7(auto num) {
    lead = """" if num > 0 else ""0"" if num == 0 else ""-""
    res, num = [], abs(num)
    while num:
    res.append(int(num % 7))
    num //= 7
    return lead + """".join(str(c) for c in res[::-1])
}"
505.py,"def shortestDistance(self, maze, start, destination):
        m, n, q, stopped = len(maze), len(maze[0]), [(0, start[0], start[1])], {(start[0], start[1]):0}
        while q:
            dist, x, y = heapq.heappop(q)
            if [x, y] == destination:
                return dist
            for i, j in ((-1, 0), (1, 0), (0, -1), (0, 1)):
                newX, newY, d = x, y, 0
                while 0 <= newX + i < m and 0 <= newY + j < n and maze[newX + i][newY + j] != 1:
                    newX += i
                    newY += j
                    d += 1
                if (newX, newY) not in stopped or dist + d < stopped[(newX, newY)]:
                    stopped[(newX, newY)] = dist + d
                    heapq.heappush(q, (dist + d, newX, newY))
        return -1","auto shortestDistance(auto maze, auto start, auto destination) {
    m, n, q, stopped = len(maze), len(maze[0]), [(0, start[0], start[1])], {(start[0], start[1]):0}
    while q:
    dist, x, y = heapq.heappop(q)
    if [x, y] == destination:
    return dist
    for i, j in ((-1, 0), (1, 0), (0, -1), (0, 1)):
    newX, newY, d = x, y, 0
    while 0 <= newX + i < m and 0 <= newY + j < n and maze[newX + i][newY + j] != 1:
    newX += i
    newY += j
    d += 1
    if (newX, newY) not in stopped or dist + d < stopped[(newX, newY)]:
    stopped[(newX, newY)] = dist + d
    heapq.heappush(q, (dist + d, newX, newY))
    return -1
}"
506.py,"def findRelativeRanks(self, nums):
        rank = {n:i>2 and str(i+1) or [""Gold"",""Silver"",""Bronze""][i] + ' Medal' for i,n in enumerate(sorted(nums,reverse=True))}
        return [rank[num] for num in nums]","auto findRelativeRanks(auto nums) {
    rank = {n:i>2 and str(i+1) or [""Gold"",""Silver"",""Bronze""][i] + ' Medal' for i,n in enumerate(sorted(nums,reverse=True))}
    return [rank[num] for num in nums]
}"
507.py,"def checkPerfectNumber(self, num):
        """"""
        :type num: int
        :rtype: bool
        """"""
        sm, div =1, 2
        while div**2<=num:
            if num%div==0: sm+=div+(num//div)
            div+=1
        return sm==num and div>2","auto checkPerfectNumber(auto num) {
    """"""
    :type num: int
    :rtype: bool
    """"""
    sm, div =1, 2
    while div**2<=num:
    if num%div==0: sm+=div+(num//div)
    div+=1
    return sm==num and div>2
}"
509.py,"def fib(self, N: int) -> int:
        return self.fib(N - 1) + self.fib(N - 2) if N > 1 else N
        ","auto fib(auto N) {
    return self.fib(N - 1) + self.fib(N - 2) if N > 1 else N
}"
51.py,"def solveNQueens(self, n):
        res = []
        def dfs(i, l, r, m, arr):
            if i == n:
                res.append(arr)
            else:
                l = l[1:] + [0]
                r = [0] + r[:-1]
                for j in range(n):
                    if m[j] == l[j] == r[j] == 0:
                        l[j] = r[j] = m[j] = 1 
                        dfs(i + 1, l, r, m, arr + [(""."" * j) + ""Q"" + (""."" * (n - j - 1))])
                        l[j] = r[j] = m[j] = 0
        dfs(0, [0] * n, [0] * n, [0] * n, [])
        return res","auto solveNQueens(auto n) {
    res = []
    def dfs(i, l, r, m, arr):
    if i == n:
    res.append(arr)
    else:
    l = l[1:] + [0]
    r = [0] + r[:-1]
    for j in range(n):
    if m[j] == l[j] == r[j] == 0:
    l[j] = r[j] = m[j] = 1
    dfs(i + 1, l, r, m, arr + [(""."" * j) + ""Q"" + (""."" * (n - j - 1))])
    l[j] = r[j] = m[j] = 0
    dfs(0, [0] * n, [0] * n, [0] * n, [])
    return res
}"
514.py,"def findRotateSteps(self, ring, key):
        ind, n, dp, pre = collections.defaultdict(list), len(ring), [0] * len(ring), key[0]
        for i, c in enumerate(ring): ind[c].append(i)
        for i in ind[key[0]]: dp[i] = min(i, n - i) + 1
        for c in key[1:]:
            for i in ind[c]: dp[i] = min(dp[j] + min(i - j, j + n - i) if i >= j else dp[j] + min(j - i, i + n - j) for j in ind[pre]) + 1
            pre = c
        return min(dp[i] for i in ind[key[-1]])","auto findRotateSteps(auto ring, auto key) {
    ind, n, dp, pre = collections.defaultdict(list), len(ring), [0] * len(ring), key[0]
    for i, c in enumerate(ring): ind[c].append(i)
    for i in ind[key[0]]: dp[i] = min(i, n - i) + 1
    for c in key[1:]:
    for i in ind[c]: dp[i] = min(dp[j] + min(i - j, j + n - i) if i >= j else dp[j] + min(j - i, i + n - j) for j in ind[pre]) + 1
    pre = c
    return min(dp[i] for i in ind[key[-1]])
}"
516.py,"def longestPalindromeSubseq(self, s):
        dp = [[0 for j in range(len(s))] for i in range(len(s))]
        for i in range(len(s) - 1, -1, -1):
            dp[i][i] = 1
            for j in range(i + 1, len(s)):
                dp[i][j] = dp[i + 1][j - 1] + 2 if s[i] == s[j] else max(dp[i + 1][j], dp[i][j - 1])
        return dp[0][len(s) - 1]","auto longestPalindromeSubseq(auto s) {
    dp = [[0 for j in range(len(s))] for i in range(len(s))]
    for i in range(len(s) - 1, -1, -1):
    dp[i][i] = 1
    for j in range(i + 1, len(s)):
    dp[i][j] = dp[i + 1][j - 1] + 2 if s[i] == s[j] else max(dp[i + 1][j], dp[i][j - 1])
    return dp[0][len(s) - 1]
}"
517.py,"def findMinMoves(self, machines):
        target, n, sm, res, total = sum(machines) // len(machines), len(machines), 0, 0, sum(machines)
        if target * n != total: return -1
        for i in range(n):
            l, sm, r = target * i - sm, sm + machines[i], target * (n - i - 1) - total + sm + machines[i]
            res = max(res, l + r, l, r)
        return res","auto findMinMoves(auto machines) {
    target, n, sm, res, total = sum(machines) // len(machines), len(machines), 0, 0, sum(machines)
    if target * n != total: return -1
    for i in range(n):
    l, sm, r = target * i - sm, sm + machines[i], target * (n - i - 1) - total + sm + machines[i]
    res = max(res, l + r, l, r)
    return res
}"
519.py,"def __init__(self, n_rows, n_cols):
        self.rows, self.cols, self.used = n_rows, n_cols, set()
        
    def flip(self):
        while True:
            r, c = random.randint(1, self.rows), random.randint(1, self.cols)
            if (r, c) not in self.used:
                self.used.add((r, c))
                return [r - 1, c - 1]
            
    def reset(self):
        self.used = set()","auto __init__(auto n_rows, auto n_cols) {
    self.rows, self.cols, self.used = n_rows, n_cols, set()
    
    def flip(self):
    while True:
    r, c = random.randint(1, self.rows), random.randint(1, self.cols)
    if (r, c) not in self.used:
    self.used.add((r, c))
    return [r - 1, c - 1]
    
    def reset(self):
    self.used = set()
}"
52.py,"def totalNQueens(self, n):
        res = [0] 
        def dfs(i, l, r, m):
            if i == n: 
                res[0] += 1
            else:
                l = l[1:] + [0]
                r = [0] + r[:-1]
                for j in range(n):
                    if m[j] == l[j] == r[j] == 0:
                        l[j] = r[j] = m[j] = 1 
                        dfs(i + 1, l, r, m)
                        l[j] = r[j] = m[j] = 0
        dfs(0, [0] * n, [0] * n, [0] * n)
        return res[0]","auto totalNQueens(auto n) {
    res = [0]
    def dfs(i, l, r, m):
    if i == n:
    res[0] += 1
    else:
    l = l[1:] + [0]
    r = [0] + r[:-1]
    for j in range(n):
    if m[j] == l[j] == r[j] == 0:
    l[j] = r[j] = m[j] = 1
    dfs(i + 1, l, r, m)
    l[j] = r[j] = m[j] = 0
    dfs(0, [0] * n, [0] * n, [0] * n)
    return res[0]
}"
520.py,"def detectCapitalUse(self, word):
        return word[0].isupper() and word[1:].islower() or word.isupper() or word.islower()","auto detectCapitalUse(auto word) {
    return word[0].isupper() and word[1:].islower() or word.isupper() or word.islower()
}"
521.py,"def findLUSlength(self, a, b):
        """"""
        :type a: str
        :type b: str
        :rtype: int
        """"""
        return -1 if a == b else max(len(a), len(b))","auto findLUSlength(auto a, auto b) {
    """"""
    :type a: str
    :type b: str
    :rtype: int
    """"""
    return -1 if a == b else max(len(a), len(b))
}"
522.py,"def findLUSlength(self, strs):
        def find(s, t):
            i = 0
            for c in t:
                if c == s[i]: i += 1
                if i == len(s): return True
            return False
        for s in sorted(strs, key=len, reverse=True):
            if sum(find(s, t) for t in strs) == 1: return len(s)
        return -1","auto findLUSlength(auto strs) {
    def find(s, t):
    i = 0
    for c in t:
    if c == s[i]: i += 1
    if i == len(s): return True
    return False
    for s in sorted(strs, key=len, reverse=True):
    if sum(find(s, t) for t in strs) == 1: return len(s)
    return -1
}"
523.py,"def checkSubarraySum(self, nums, k):
        if not k: return any(nums[i] == nums[i - 1] == 0 for i in range(1, len(nums)))
        mods, sm = set(), 0
        for i, num in enumerate(nums):
            sm = (sm + num) % k
            if (sm in mods and num or (i and not nums[i - 1])) or (not sm and i): return True
            mods |= {sm}
        return False","auto checkSubarraySum(auto nums, auto k) {
    if not k: return any(nums[i] == nums[i - 1] == 0 for i in range(1, len(nums)))
    mods, sm = set(), 0
    for i, num in enumerate(nums):
    sm = (sm + num) % k
    if (sm in mods and num or (i and not nums[i - 1])) or (not sm and i): return True
    mods |= {sm}
    return False
}"
524.py,"def findLongestWord(self, s, d):
        d.sort(key = lambda x: (-len(x), x))
        for w in d:
            i = 0
            for c in s:
                if c == w[i]: i += 1
                if i == len(w): return w
        return """"","auto findLongestWord(auto s, auto d) {
    d.sort(key = lambda x: (-len(x), x))
    for w in d:
    i = 0
    for c in s:
    if c == w[i]: i += 1
    if i == len(w): return w
    return """"
}"
525.py,"def findMaxLength(self, nums: List[int]) -> int:
        ind, res, sm = {0:-1}, 0, 0
        for i, num in enumerate(nums):
            sm += num and 1 or -1
            if sm in ind:
                res = max(res, i - ind[sm])
            else:
                ind[sm] = i
        return res","auto findMaxLength(auto nums) {
    ind, res, sm = {0:-1}, 0, 0
    for i, num in enumerate(nums):
    sm += num and 1 or -1
    if sm in ind:
    res = max(res, i - ind[sm])
    else:
    ind[sm] = i
    return res
}"
527.py,"def wordsAbbreviation(self, dict):
        abb = collections.defaultdict(int)
        for i, w in enumerate(dict):
            for j in range(1, len(w) - 2):
                abb[w[:j] + str(len(w) - j - 1) + w[-1]] += 1
        for i, w in enumerate(dict):
            for j in range(1, len(w) - 2):
                new = w[:j] + str(len(w) - j - 1) + w[-1]
                if abb[new] == 1:
                    dict[i] = new
                    break
        return dict","auto wordsAbbreviation(auto dict) {
    abb = collections.defaultdict(int)
    for i, w in enumerate(dict):
    for j in range(1, len(w) - 2):
    abb[w[:j] + str(len(w) - j - 1) + w[-1]] += 1
    for i, w in enumerate(dict):
    for j in range(1, len(w) - 2):
    new = w[:j] + str(len(w) - j - 1) + w[-1]
    if abb[new] == 1:
    dict[i] = new
    break
    return dict
}"
528.py,"def __init__(self, w):
        self.ranges, sm = [], 0
        for weight in w:
            self.ranges.append([sm, sm + weight])
            sm += weight
        self.mn, self.mx = 1, sm
    def pickIndex(self):
        num, l, r = random.randint(self.mn, self.mx), 0, len(self.ranges) - 1
        while l <= r:
            mid = (l + r) // 2
            if self.ranges[mid][1] < num:
                l = mid + 1
            elif num <= self.ranges[mid][0]:
                r = mid - 1
            else:
                return mid","auto __init__(auto w) {
    self.ranges, sm = [], 0
    for weight in w:
    self.ranges.append([sm, sm + weight])
    sm += weight
    self.mn, self.mx = 1, sm
    def pickIndex(self):
    num, l, r = random.randint(self.mn, self.mx), 0, len(self.ranges) - 1
    while l <= r:
    mid = (l + r) // 2
    if self.ranges[mid][1] < num:
    l = mid + 1
    elif num <= self.ranges[mid][0]:
    r = mid - 1
    else:
    return mid
}"
53.py,"def maxSubArray(self, nums):
        sm, mn, mx = 0, 0, -float(""inf"")
        for num in nums:
            sm += num
            mx, mn = max(mx, sm - mn), min(mn, sm)
        return mx","auto maxSubArray(auto nums) {
    sm, mn, mx = 0, 0, -float(""inf"")
    for num in nums:
    sm += num
    mx, mn = max(mx, sm - mn), min(mn, sm)
    return mx
}"
531.py,"def findLonelyPixel(self, grid: List[List[str]]) -> int:
        rows = collections.defaultdict(list)
        cols = collections.defaultdict(list)
        m, n = len(grid), len(grid[0])
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 'B':
                    rows[i].append(j)
                    cols[j].append(i)
        res = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 'B' and rows[i] == [j] and cols[j] == [i]:
                    res += 1
        return res","auto findLonelyPixel(auto grid) {
    rows = collections.defaultdict(list)
    cols = collections.defaultdict(list)
    m, n = len(grid), len(grid[0])
    for i in range(m):
    for j in range(n):
    if grid[i][j] == 'B':
    rows[i].append(j)
    cols[j].append(i)
    res = 0
    for i in range(m):
    for j in range(n):
    if grid[i][j] == 'B' and rows[i] == [j] and cols[j] == [i]:
    res += 1
    return res
}"
532.py,"def findPairs(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        dic, pair = {}, 0
        for num in nums:
            if (num-k in dic or num+k in dic) and (not num in dic or (k==0 and dic[num]==1)) and k>=0: 
                if num-k in dic and k!=0: pair+=1
                if num+k in dic: pair+=1 
                if num in dic: dic[num]+=1; continue
            if num in dic: continue
            dic[num]=1
        return pair","auto findPairs(auto nums, auto k) {
    """"""
    :type nums: List[int]
    :type k: int
    :rtype: int
    """"""
    dic, pair = {}, 0
    for num in nums:
    if (num-k in dic or num+k in dic) and (not num in dic or (k==0 and dic[num]==1)) and k>=0:
    if num-k in dic and k!=0: pair+=1
    if num+k in dic: pair+=1
    if num in dic: dic[num]+=1; continue
    if num in dic: continue
    dic[num]=1
    return pair
}"
533.py,"def findBlackPixel(self, picture, N):
        m, n, res = len(picture), len(picture[0]), 0
        for row in picture:
            r_cnt = row.count(""B"")
            if r_cnt != N:
                continue
            for j in range(n):
                if row[j] == ""B"":
                    col_cnt = same = 0
                    for i in range(m):
                        if picture[i][j] == ""B"":
                            col_cnt += 1
                            if picture[i] == row:
                                same += 1 
                            else:
                                break
                    if r_cnt == col_cnt == same:
                        res += 1
        return res","auto findBlackPixel(auto picture, auto N) {
    m, n, res = len(picture), len(picture[0]), 0
    for row in picture:
    r_cnt = row.count(""B"")
    if r_cnt != N:
    continue
    for j in range(n):
    if row[j] == ""B"":
    col_cnt = same = 0
    for i in range(m):
    if picture[i][j] == ""B"":
    col_cnt += 1
    if picture[i] == row:
    same += 1
    else:
    break
    if r_cnt == col_cnt == same:
    res += 1
    return res
}"
537.py,"def complexNumberMultiply(self, a, b):
        """"""
        :type a: str
        :type b: str
        :rtype: str
        """"""
        re, im = 0, 0
        re_a, im_a = list(map(int,a[:-1].split(""+"")))
        re_b, im_b = list(map(int,b[:-1].split(""+"")))
        re += re_a * re_b - im_a * im_b
        im += re_a * im_b + re_b *im_a
        return str(re)+""+""+str(im)+""i""","auto complexNumberMultiply(auto a, auto b) {
    """"""
    :type a: str
    :type b: str
    :rtype: str
    """"""
    re, im = 0, 0
    re_a, im_a = list(map(int,a[:-1].split(""+"")))
    re_b, im_b = list(map(int,b[:-1].split(""+"")))
    re += re_a * re_b - im_a * im_b
    im += re_a * im_b + re_b *im_a
    return str(re)+""+""+str(im)+""i""
}"
539.py,"def findMinDifference(self, tp):
        def getMinute(t): 
            h , m = t.split("":"")
            return int(h) * 60 + int(m)
        tp = sorted(map(getMinute, tp))
        mn = sys.maxsize
        for i in range(len(tp) - 1): 
            mn = min(mn, tp[i + 1] - tp[i])
            if mn == 0: return 0
        return min(mn, 1440 + tp[0] - tp[-1])","auto findMinDifference(auto tp) {
    def getMinute(t):
    h , m = t.split("":"")
    return int(h) * 60 + int(m)
    tp = sorted(map(getMinute, tp))
    mn = sys.maxsize
    for i in range(len(tp) - 1):
    mn = min(mn, tp[i + 1] - tp[i])
    if mn == 0: return 0
    return min(mn, 1440 + tp[0] - tp[-1])
}"
54.py,"def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        res = []
        seen = set()
        def dfs(i, j, d):
            seen.add((i, j))
            res.append(matrix[i][j])
            if d == 'r':
                if j + 1 < n and (i, j + 1) not in seen:
                    dfs(i, j + 1, d)
                elif i + 1 < m and (i + 1, j) not in seen:
                    dfs(i + 1, j , 'd')
            elif d == 'd':
                if i + 1 < m and (i + 1, j) not in seen:
                    dfs(i + 1, j , d)
                elif j and (i, j - 1) not in seen:
                    dfs(i, j - 1, 'l')
            elif d == 'l':
                if j and (i, j - 1) not in seen:
                    dfs(i, j - 1, d)
                elif i and (i - 1, j) not in seen:
                    dfs(i - 1, j, 'u')
            else:
                if i and (i - 1, j) not in seen:
                    dfs(i - 1, j, d)
                elif j + 1 < n and (i, j + 1) not in seen:
                    dfs(i, j + 1, 'r')
        if not matrix: return []
        m, n = len(matrix), len(matrix[0])
        dfs(0, 0, 'r')
        return res
        ","auto spiralOrder(auto matrix) {
    res = []
    seen = set()
    def dfs(i, j, d):
    seen.add((i, j))
    res.append(matrix[i][j])
    if d == 'r':
    if j + 1 < n and (i, j + 1) not in seen:
    dfs(i, j + 1, d)
    elif i + 1 < m and (i + 1, j) not in seen:
    dfs(i + 1, j , 'd')
    elif d == 'd':
    if i + 1 < m and (i + 1, j) not in seen:
    dfs(i + 1, j , d)
    elif j and (i, j - 1) not in seen:
    dfs(i, j - 1, 'l')
    elif d == 'l':
    if j and (i, j - 1) not in seen:
    dfs(i, j - 1, d)
    elif i and (i - 1, j) not in seen:
    dfs(i - 1, j, 'u')
    else:
    if i and (i - 1, j) not in seen:
    dfs(i - 1, j, d)
    elif j + 1 < n and (i, j + 1) not in seen:
    dfs(i, j + 1, 'r')
    if not matrix: return []
    m, n = len(matrix), len(matrix[0])
    dfs(0, 0, 'r')
    return res
}"
540.py,"def singleNonDuplicate(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        left, right = 0, len(nums)-1
        while left<=right:
            mid = (left+right)//2
            if mid+1<len(nums) and nums[mid] == nums[mid+1]:
                if mid % 2 == 0: left = mid+2
                else: right = mid-1
            elif mid-1>=0 and nums[mid] == nums[mid-1]:
                if mid % 2 == 0: right = mid-2
                else: left = mid+1
            else: return nums[mid]
                ","auto singleNonDuplicate(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: int
    """"""
    left, right = 0, len(nums)-1
    while left<=right:
    mid = (left+right)//2
    if mid+1<len(nums) and nums[mid] == nums[mid+1]:
    if mid % 2 == 0: left = mid+2
    else: right = mid-1
    elif mid-1>=0 and nums[mid] == nums[mid-1]:
    if mid % 2 == 0: right = mid-2
    else: left = mid+1
    else: return nums[mid]
}"
541.py,"def reverseStr(self, s, k):
        """"""
        :type s: str
        :type k: int
        :rtype: str
        """"""
        return """".join([s[i:i+k][::-1]+s[i+k:i+2*k]   if len(s)>=i or len(s)>i-k else s[k*i:][::-1] for i in range(0,len(s),k*2)])","auto reverseStr(auto s, auto k) {
    """"""
    :type s: str
    :type k: int
    :rtype: str
    """"""
    return """".join([s[i:i+k][::-1]+s[i+k:i+2*k]   if len(s)>=i or len(s)>i-k else s[k*i:][::-1] for i in range(0,len(s),k*2)])
}"
542.py,"def updateMatrix(self, matrix):
        m, n = len(matrix), len(matrix and matrix[0])
        for i in range(m):
            for j in range(n):
                if matrix[i][j] != 0:
                    matrix[i][j] = float(""inf"")
                    if i > 0 and matrix[i - 1][j] + 1 < matrix[i][j]:
                        matrix[i][j] = matrix[i - 1][j] + 1
                    if j > 0 and matrix[i][j - 1] + 1 < matrix[i][j]:
                        matrix[i][j] = matrix[i][j - 1] + 1
        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                if matrix[i][j] != 0:
                    if i + 1 < m and matrix[i + 1][j] + 1 < matrix[i][j]:
                        matrix[i][j] = matrix[i + 1][j] + 1
                    if j + 1 < n and matrix[i][j + 1] + 1 < matrix[i][j]:
                        matrix[i][j] = matrix[i][j + 1] + 1
        return matrix","auto updateMatrix(auto matrix) {
    m, n = len(matrix), len(matrix and matrix[0])
    for i in range(m):
    for j in range(n):
    if matrix[i][j] != 0:
    matrix[i][j] = float(""inf"")
    if i > 0 and matrix[i - 1][j] + 1 < matrix[i][j]:
    matrix[i][j] = matrix[i - 1][j] + 1
    if j > 0 and matrix[i][j - 1] + 1 < matrix[i][j]:
    matrix[i][j] = matrix[i][j - 1] + 1
    for i in range(m - 1, -1, -1):
    for j in range(n - 1, -1, -1):
    if matrix[i][j] != 0:
    if i + 1 < m and matrix[i + 1][j] + 1 < matrix[i][j]:
    matrix[i][j] = matrix[i + 1][j] + 1
    if j + 1 < n and matrix[i][j + 1] + 1 < matrix[i][j]:
    matrix[i][j] = matrix[i][j + 1] + 1
    return matrix
}"
544.py,"def findContestMatch(self, n):
        arr = [str(i) for i in range(1, n + 1)]
        while len(arr) > 1: arr = [""("" + arr[i] + "","" + arr[len(arr) - 1 - i] + "")"" for i in range(len(arr) // 2)]
        return "","".join(arr)    ","auto findContestMatch(auto n) {
    arr = [str(i) for i in range(1, n + 1)]
    while len(arr) > 1: arr = [""("" + arr[i] + "","" + arr[len(arr) - 1 - i] + "")"" for i in range(len(arr) // 2)]
    return "","".join(arr)
}"
546.py,"def removeBoxes(self, A):
        n = len(A)
        memo = [[[0] * n for _ in range(n) ] for _ in range(n)]
        def dp(i, j, k):
            if i > j: return 0
            if not memo[i][j][k]:
                m = i
                while m+1 <= j and A[m+1] == A[i]:
                    m += 1
                i, k = m, k + m - i
                ans = dp(i+1, j, 0) + (k+1) ** 2
                for m in range(i+1, j+1):
                    if A[i] == A[m]:
                        ans = max(ans, dp(i+1, m-1, 0) + dp(m, j, k+1))
                memo[i][j][k] = ans
            return memo[i][j][k]
        return dp(0, n-1, 0)","auto removeBoxes(auto A) {
    n = len(A)
    memo = [[[0] * n for _ in range(n) ] for _ in range(n)]
    def dp(i, j, k):
    if i > j: return 0
    if not memo[i][j][k]:
    m = i
    while m+1 <= j and A[m+1] == A[i]:
    m += 1
    i, k = m, k + m - i
    ans = dp(i+1, j, 0) + (k+1) ** 2
    for m in range(i+1, j+1):
    if A[i] == A[m]:
    ans = max(ans, dp(i+1, m-1, 0) + dp(m, j, k+1))
    memo[i][j][k] = ans
    return memo[i][j][k]
    return dp(0, n-1, 0)
}"
547.py,"def findCircleNum(self, m):
        res, n = 0, len(m)
        def explore(i):
            m[i][i] = 0
            for j in range(n):
                if i != j and m[i][j] == m[j][j] == 1: explore(j)
        for i in range(n):
            if m[i][i] == 1: explore(i); res += 1
        return res","auto findCircleNum(auto m) {
    res, n = 0, len(m)
    def explore(i):
    m[i][i] = 0
    for j in range(n):
    if i != j and m[i][j] == m[j][j] == 1: explore(j)
    for i in range(n):
    if m[i][i] == 1: explore(i); res += 1
    return res
}"
549.py,"def longestConsecutive(self, root):
        dec, inc = {}, {}
        def dfs(node):
            if not node: return 0
            l = dfs(node.left)
            r = dfs(node.right)
            incL = inc[node.left] + 1 if node.left and node.val == node.left.val + 1 else 1
            incR = inc[node.right] + 1 if node.right and node.val == node.right.val + 1 else 1
            inc[node] = max(incL, incR)
            decL = dec[node.left] + 1 if node.left and node.val == node.left.val - 1 else 1
            decR = dec[node.right] + 1 if node.right and node.val == node.right.val - 1 else 1
            dec[node] = max(decL, decR)
            if node.left and node.right and node.left.val == node.val - 1 and node.right.val == node.val + 1:
                m = inc[node.left] + dec[node.right] + 1
            elif node.left and node.right and node.left.val == node.val + 1 and node.right.val == node.val - 1:
                m = dec[node.left] + inc[node.right] + 1
            else:
                m = 0
            return max(m, l, r, inc[node], dec[node])
        return dfs(root)","auto longestConsecutive(auto root) {
    dec, inc = {}, {}
    def dfs(node):
    if not node: return 0
    l = dfs(node.left)
    r = dfs(node.right)
    incL = inc[node.left] + 1 if node.left and node.val == node.left.val + 1 else 1
    incR = inc[node.right] + 1 if node.right and node.val == node.right.val + 1 else 1
    inc[node] = max(incL, incR)
    decL = dec[node.left] + 1 if node.left and node.val == node.left.val - 1 else 1
    decR = dec[node.right] + 1 if node.right and node.val == node.right.val - 1 else 1
    dec[node] = max(decL, decR)
    if node.left and node.right and node.left.val == node.val - 1 and node.right.val == node.val + 1:
    m = inc[node.left] + dec[node.right] + 1
    elif node.left and node.right and node.left.val == node.val + 1 and node.right.val == node.val - 1:
    m = dec[node.left] + inc[node.right] + 1
    else:
    m = 0
    return max(m, l, r, inc[node], dec[node])
    return dfs(root)
}"
55.py,"def canJump(self, nums):
        """"""
        :type nums: List[int]
        :rtype: bool
        """"""
        i = mx = 0
        while i < len(nums) and i <= mx:
            if nums[i] + i >= len(nums) - 1: return True
            mx, i = max(mx, i + nums[i]), i + 1
        return False","auto canJump(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: bool
    """"""
    i = mx = 0
    while i < len(nums) and i <= mx:
    if nums[i] + i >= len(nums) - 1: return True
    mx, i = max(mx, i + nums[i]), i + 1
    return False
}"
551.py,"def checkRecord(self, s):
        """"""
        :type s: str
        :rtype: bool
        """"""
        return False if ""LLL"" in s or s.count(""A"")>1 else True","auto checkRecord(auto s) {
    """"""
    :type s: str
    :rtype: bool
    """"""
    return False if ""LLL"" in s or s.count(""A"")>1 else True
}"
553.py,"def optimalDivision(self, nums):
        """"""
        :type nums: List[int]
        :rtype: str
        """"""
        if len(nums) == 1: return str(nums[0])
        elif len(nums) == 2: return str(nums[0])+""/""+str(nums[1])
        else: return str(nums[0])+""/(""+""/"".join(str(i) for i in nums[1:])+"")""","auto optimalDivision(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: str
    """"""
    if len(nums) == 1: return str(nums[0])
    elif len(nums) == 2: return str(nums[0])+""/""+str(nums[1])
    else: return str(nums[0])+""/(""+""/"".join(str(i) for i in nums[1:])+"")""
}"
554.py,"def leastBricks(self, wall: List[List[int]]) -> int:
        m = len(wall)
        sm = sum(wall[0])
        cnt = collections.defaultdict(int)
        for i in range(m):
            x = 0
            for num in wall[i]:
                x += num
                if x != sm:
                    cnt[x] += 1
        mx = 0
        for i in range(m):
            x = 0
            for num in wall[i]:
                x += num
                mx = max(mx, cnt[x])
        return m - mx","auto leastBricks(auto wall) {
    m = len(wall)
    sm = sum(wall[0])
    cnt = collections.defaultdict(int)
    for i in range(m):
    x = 0
    for num in wall[i]:
    x += num
    if x != sm:
    cnt[x] += 1
    mx = 0
    for i in range(m):
    x = 0
    for num in wall[i]:
    x += num
    mx = max(mx, cnt[x])
    return m - mx
}"
555.py,"def splitLoopedString(self, strs):
        arr, res = [s > s[::-1] and s or s[::-1] for s in strs], """"
        for i, word in enumerate(strs):
            for w in (word, word[::-1]):
                s, ind = """", 0
                for j in range(len(w)):
                    if not s or w[j:] + w[:j] > s: s, ind = w[j:] + w[:j], j   
                cur = w[ind:] + """".join(arr[i + 1:]) + """".join(arr[:i]) + w[:ind]
                if not res or cur > res: res = cur
        return res","auto splitLoopedString(auto strs) {
    arr, res = [s > s[::-1] and s or s[::-1] for s in strs], """"
    for i, word in enumerate(strs):
    for w in (word, word[::-1]):
    s, ind = """", 0
    for j in range(len(w)):
    if not s or w[j:] + w[:j] > s: s, ind = w[j:] + w[:j], j
    cur = w[ind:] + """".join(arr[i + 1:]) + """".join(arr[:i]) + w[:ind]
    if not res or cur > res: res = cur
    return res
}"
556.py,"def nextGreaterElement(self, n):
        arr = [c for c in str(n)]
        for l in range(len(arr) - 2, -1, -1):
            r = len(arr) - 1
            while l < r and arr[r] <= arr[l]:
                r -= 1
            if l != r:
                arr[l], arr[r] = arr[r], arr[l]
                arr[l + 1:] = sorted(arr[l + 1:])
                num = int("""".join(arr))
                return num if -2 ** 31 <= num <= 2 ** 31 - 1 else -1
        return -1","auto nextGreaterElement(auto n) {
    arr = [c for c in str(n)]
    for l in range(len(arr) - 2, -1, -1):
    r = len(arr) - 1
    while l < r and arr[r] <= arr[l]:
    r -= 1
    if l != r:
    arr[l], arr[r] = arr[r], arr[l]
    arr[l + 1:] = sorted(arr[l + 1:])
    num = int("""".join(arr))
    return num if -2 ** 31 <= num <= 2 ** 31 - 1 else -1
    return -1
}"
557.py,"def reverseWords(self, s):
        """"""
        :type s: str
        :rtype: str
        """"""
        j, s_out=0, str()
        for i, char in enumerate(s):
            if i==len(s)-1: s_out+=s[j:i+1][::-1]; return """".join(s_out)
            if char=="" "": s_out+=s[j:i][::-1]; j=i+1; s_out+="" ""
        return """".join(s_out)","auto reverseWords(auto s) {
    """"""
    :type s: str
    :rtype: str
    """"""
    j, s_out=0, str()
    for i, char in enumerate(s):
    if i==len(s)-1: s_out+=s[j:i+1][::-1]; return """".join(s_out)
    if char=="" "": s_out+=s[j:i][::-1]; j=i+1; s_out+="" ""
    return """".join(s_out)
}"
558.py,"def intersect(self, q1, q2):
        if q1.isLeaf:
            return q1.val and q1 or q2
        elif q2.isLeaf:
            return q2.val and q2 or q1
        else:
            tLeft = self.intersect(q1.topLeft, q2.topLeft)
            tRight = self.intersect(q1.topRight, q2.topRight)
            bLeft = self.intersect(q1.bottomLeft, q2.bottomLeft)
            bRight = self.intersect(q1.bottomRight, q2.bottomRight)
            if tLeft.isLeaf and tRight.isLeaf and bLeft.isLeaf and bRight.isLeaf and tLeft.val == tRight.val == bLeft.val == bRight.val:
                node = Node(tLeft.val, True, None, None, None, None) 
            else:
                node = Node(False, False, tLeft, tRight, bLeft, bRight)
        return node","auto intersect(auto q1, auto q2) {
    if q1.isLeaf:
    return q1.val and q1 or q2
    elif q2.isLeaf:
    return q2.val and q2 or q1
    else:
    tLeft = self.intersect(q1.topLeft, q2.topLeft)
    tRight = self.intersect(q1.topRight, q2.topRight)
    bLeft = self.intersect(q1.bottomLeft, q2.bottomLeft)
    bRight = self.intersect(q1.bottomRight, q2.bottomRight)
    if tLeft.isLeaf and tRight.isLeaf and bLeft.isLeaf and bRight.isLeaf and tLeft.val == tRight.val == bLeft.val == bRight.val:
    node = Node(tLeft.val, True, None, None, None, None)
    else:
    node = Node(False, False, tLeft, tRight, bLeft, bRight)
    return node
}"
560.py,"def subarraySum(self, nums, k):
        sums, res, sm = {}, 0, 0
        for i in range(len(nums)):
            sums[sm], sm = sm in sums and sums[sm] + 1 or 1, sm + nums[i]
            if sm - k in sums: res += sums[sm - k]
        return res","auto subarraySum(auto nums, auto k) {
    sums, res, sm = {}, 0, 0
    for i in range(len(nums)):
    sums[sm], sm = sm in sums and sums[sm] + 1 or 1, sm + nums[i]
    if sm - k in sums: res += sums[sm - k]
    return res
}"
561.py,"def arrayPairSum(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        nums.sort()
        sum=0
        while nums:
            num1=nums.pop()
            num2=nums.pop()
            sum+=num2
        return sum
            ","auto arrayPairSum(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: int
    """"""
    nums.sort()
    sum=0
    while nums:
    num1=nums.pop()
    num2=nums.pop()
    sum+=num2
    return sum
}"
562.py,"def longestLine(self, M):
        hor, ver, dig, aDig, mx, m, n = {}, {}, {}, {}, 0, len(M), len(M and M[0])
        for i in range(m):
            for j in range(n):
                if M[i][j]:
                    ver[(i, j)] = j > 0 and M[i][j - 1] and ver[(i, j - 1)] + 1 or 1
                    hor[(i, j)] = i > 0 and M[i - 1][j] and hor[(i - 1, j)] + 1 or 1
                    dig[(i, j)] = i > 0 and j > 0 and M[i - 1][j - 1] and dig[(i - 1, j - 1)] + 1 or 1
                    aDig[(i, j)] = i > 0 and j + 1 < n and M[i - 1][j + 1] and aDig[(i - 1, j + 1)] + 1 or 1
                    mx = max(mx, ver[(i, j)], hor[(i, j)], dig[(i, j)], aDig[(i, j)])
        return mx","auto longestLine(auto M) {
    hor, ver, dig, aDig, mx, m, n = {}, {}, {}, {}, 0, len(M), len(M and M[0])
    for i in range(m):
    for j in range(n):
    if M[i][j]:
    ver[(i, j)] = j > 0 and M[i][j - 1] and ver[(i, j - 1)] + 1 or 1
    hor[(i, j)] = i > 0 and M[i - 1][j] and hor[(i - 1, j)] + 1 or 1
    dig[(i, j)] = i > 0 and j > 0 and M[i - 1][j - 1] and dig[(i - 1, j - 1)] + 1 or 1
    aDig[(i, j)] = i > 0 and j + 1 < n and M[i - 1][j + 1] and aDig[(i - 1, j + 1)] + 1 or 1
    mx = max(mx, ver[(i, j)], hor[(i, j)], dig[(i, j)], aDig[(i, j)])
    return mx
}"
564.py,"def nearestPalindromic(self, S):
        K = len(S)
        candidates = [str(10**k + d) for k in (K-1, K) for d in (-1, 1)]
        prefix = S[:(K+1)//2]
        P = int(prefix)
        for start in map(str, (P-1, P, P+1)):
            candidates.append(start + (start[:-1] if K%2 else start)[::-1])

        def delta(x):
            return abs(int(S) - int(x))

        ans = None
        for cand in candidates:
            if cand != S and not cand.startswith('00'):
                if (ans is None or delta(cand) < delta(ans) or
                        delta(cand) == delta(ans) and int(cand) < int(ans)):
                    ans = cand
        return ans","auto nearestPalindromic(auto S) {
    K = len(S)
    candidates = [str(10**k + d) for k in (K-1, K) for d in (-1, 1)]
    prefix = S[:(K+1)//2]
    P = int(prefix)
    for start in map(str, (P-1, P, P+1)):
    candidates.append(start + (start[:-1] if K%2 else start)[::-1])
    
    def delta(x):
    return abs(int(S) - int(x))
    
    ans = None
    for cand in candidates:
    if cand != S and not cand.startswith('00'):
    if (ans is None or delta(cand) < delta(ans) or
    delta(cand) == delta(ans) and int(cand) < int(ans)):
    ans = cand
    return ans
}"
565.py,"def arrayNesting(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        dic={}
        for i in range(len(nums)):
            if i in dic:
                continue
            j=i
            dic[j]=1
            while nums[i]!=j:
                dic[j]+=1
                i=nums[i]
                dic[i]=1
        return max(dic.values())","auto arrayNesting(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: int
    """"""
    dic={}
    for i in range(len(nums)):
    if i in dic:
    continue
    j=i
    dic[j]=1
    while nums[i]!=j:
    dic[j]+=1
    i=nums[i]
    dic[i]=1
    return max(dic.values())
}"
566.py,"def matrixReshape(self, nums, r, c):
        """"""
        :type nums: List[List[int]]
        :type r: int
        :type c: int
        :rtype: List[List[int]]
        """"""
        nums_ordered=[x for y in nums for x in y]
        if r*c==len(nums)*len(nums[0]):
            return [nums_ordered[c*i:c*(i+1)] for i in range(r)]
        else:return nums
        ","auto matrixReshape(auto nums, auto r, auto c) {
    """"""
    :type nums: List[List[int]]
    :type r: int
    :type c: int
    :rtype: List[List[int]]
    """"""
    nums_ordered=[x for y in nums for x in y]
    if r*c==len(nums)*len(nums[0]):
    return [nums_ordered[c*i:c*(i+1)] for i in range(r)]
    else:return nums
}"
567.py,"def checkInclusion(self, s1, s2):
        if len(s1) > len(s2): return False
        dic = collections.defaultdict(int)
        for i in range(len(s1)):
            dic[s1[i]] += 1
            if dic[s1[i]] == 0: del dic[s1[i]]
            dic[s2[i]] -= 1
            if dic[s2[i]] == 0: del dic[s2[i]]
        i = 0
        for j in range(len(s1), len(s2)):
            if not dic: return True
            dic[s2[j]] -= 1
            if dic[s2[j]] == 0: del dic[s2[j]]
            dic[s2[i]] += 1
            if dic[s2[i]] == 0: del dic[s2[i]]
            i += 1
        return not dic","auto checkInclusion(auto s1, auto s2) {
    if len(s1) > len(s2): return False
    dic = collections.defaultdict(int)
    for i in range(len(s1)):
    dic[s1[i]] += 1
    if dic[s1[i]] == 0: del dic[s1[i]]
    dic[s2[i]] -= 1
    if dic[s2[i]] == 0: del dic[s2[i]]
    i = 0
    for j in range(len(s1), len(s2)):
    if not dic: return True
    dic[s2[j]] -= 1
    if dic[s2[j]] == 0: del dic[s2[j]]
    dic[s2[i]] += 1
    if dic[s2[i]] == 0: del dic[s2[i]]
    i += 1
    return not dic
}"
568.py,"def maxVacationDays(self, flights: List[List[int]], days: List[List[int]]) -> int:
        if not flights or not days:
            return 0
        n, k = len(flights), len(days[0])
        dp = [[-1] * (k + 1) for c in range(n)]
        dp[0][0] = 0
        for w in range(1, k + 1):
            for c in range(n):
                dp[c][w] = max([dp[pre][w - 1] + days[c][w - 1] for pre in range(n) if (flights[pre][c] or pre == c) and dp[pre][w - 1] >= 0] or [-1])
        return max(dp[c][-1] for c in range(n))","auto maxVacationDays(auto flights, auto days) {
    if not flights or not days:
    return 0
    n, k = len(flights), len(days[0])
    dp = [[-1] * (k + 1) for c in range(n)]
    dp[0][0] = 0
    for w in range(1, k + 1):
    for c in range(n):
    dp[c][w] = max([dp[pre][w - 1] + days[c][w - 1] for pre in range(n) if (flights[pre][c] or pre == c) and dp[pre][w - 1] >= 0] or [-1])
    return max(dp[c][-1] for c in range(n))
}"
57.py,"def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        new, i = [], 0
        for i, it in enumerate(intervals):
            if newInterval[1] < it[0]: 
                i -= 1
                break
            elif it[1] < newInterval[0]: 
                new += it,
            else: 
                newInterval[0], newInterval[1] = min(it[0], newInterval[0]), max(it[1], newInterval[1])
        return new + [newInterval] + intervals[i + 1:]
        ","auto insert(auto intervals, auto newInterval) {
    new, i = [], 0
    for i, it in enumerate(intervals):
    if newInterval[1] < it[0]:
    i -= 1
    break
    elif it[1] < newInterval[0]:
    new += it,
    else:
    newInterval[0], newInterval[1] = min(it[0], newInterval[0]), max(it[1], newInterval[1])
    return new + [newInterval] + intervals[i + 1:]
}"
572.py,"def isSubtree(self, s, t):
        """"""
        :type s: TreeNode
        :type t: TreeNode
        :rtype: bool
        """"""
        def traverse(node):
            if not node: return ""^""
            return ""$""+str(node.val)+""?""+traverse(node.left)+""@""+traverse(node.right)
        return traverse(t) in traverse(s)","auto isSubtree(auto s, auto t) {
    """"""
    :type s: TreeNode
    :type t: TreeNode
    :rtype: bool
    """"""
    def traverse(node):
    if not node: return ""^""
    return ""$""+str(node.val)+""?""+traverse(node.left)+""@""+traverse(node.right)
    return traverse(t) in traverse(s)
}"
573.py,"def minDistance(self, height, width, t, s, n):
        sm = 2 * sum(abs(x - t[0]) + abs(y - t[1]) for x, y in n)
        return min(sm - abs(x - t[0]) - abs(y - t[1]) + abs(x - s[0]) + abs(y - s[1]) for x, y in n)","auto minDistance(auto height, auto width, auto t, auto s, auto n) {
    sm = 2 * sum(abs(x - t[0]) + abs(y - t[1]) for x, y in n)
    return min(sm - abs(x - t[0]) - abs(y - t[1]) + abs(x - s[0]) + abs(y - s[1]) for x, y in n)
}"
575.py,"def distributeCandies(self, candies):
        """"""
        :type candies: List[int]
        :rtype: int
        """"""
        return len(set(candies)) if len(set(candies))<=len(candies)//2 else len(candies)//2","auto distributeCandies(auto candies) {
    """"""
    :type candies: List[int]
    :rtype: int
    """"""
    return len(set(candies)) if len(set(candies))<=len(candies)//2 else len(candies)//2
}"
576.py,"def __init__(self): self.dic = collections.defaultdict(int)
    def findPaths(self, m, n, N, i, j):
        if N >= 0 and (i < 0 or j < 0 or i >= m or j >= n): return 1
        elif N < 0: return 0
        elif (i, j, N) not in self.dic: 
            for p in ((1, 0), (-1, 0), (0, 1), (0, -1)): self.dic[(i, j, N)] += self.findPaths(m, n, N - 1, i + p[0], j + p[1]) 
        return self.dic[(i, j, N)] % (10 ** 9 + 7) ","auto __init__() {
    def findPaths(self, m, n, N, i, j):
    if N >= 0 and (i < 0 or j < 0 or i >= m or j >= n): return 1
    elif N < 0: return 0
    elif (i, j, N) not in self.dic:
    for p in ((1, 0), (-1, 0), (0, 1), (0, -1)): self.dic[(i, j, N)] += self.findPaths(m, n, N - 1, i + p[0], j + p[1])
    return self.dic[(i, j, N)] % (10 ** 9 + 7)
}"
58.py,"def lengthOfLastWord(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        if len(s)==0:
            return 0
        count=0
        prev_count=0
        for letter in s:
            if count>0:
                prev_count=count
            if letter=="" "":
                count=0
                continue
            count+=1
        if count>0:
            return count
        else:
            return prev_count","auto lengthOfLastWord(auto s) {
    """"""
    :type s: str
    :rtype: int
    """"""
    if len(s)==0:
    return 0
    count=0
    prev_count=0
    for letter in s:
    if count>0:
    prev_count=count
    if letter=="" "":
    count=0
    continue
    count+=1
    if count>0:
    return count
    else:
    return prev_count
}"
581.py,"def findUnsortedSubarray(self, nums: List[int]) -> int:
        arr = sorted(nums)
        i = 0
        for i in range(len(arr)):
            if arr[i] != nums[i]:
                for j in range(len(arr) - 1, -1, -1):
                    if arr[j] != nums[j]:
                        return j - i + 1
        return 0","auto findUnsortedSubarray(auto nums) {
    arr = sorted(nums)
    i = 0
    for i in range(len(arr)):
    if arr[i] != nums[i]:
    for j in range(len(arr) - 1, -1, -1):
    if arr[j] != nums[j]:
    return j - i + 1
    return 0
}"
582.py,"def killProcess(self, pid, ppid, kill):
        indexes, res = collections.defaultdict(list), [kill]
        for i, p in enumerate(ppid):
            indexes[p].append(i)
        stack = [kill]
        while stack:
            for i in indexes[stack.pop()]:
                res.append(pid[i])
                stack.append(pid[i])
        return res","auto killProcess(auto pid, auto ppid, auto kill) {
    indexes, res = collections.defaultdict(list), [kill]
    for i, p in enumerate(ppid):
    indexes[p].append(i)
    stack = [kill]
    while stack:
    for i in indexes[stack.pop()]:
    res.append(pid[i])
    stack.append(pid[i])
    return res
}"
583.py,"def minDistance(self, w1, w2):
        m, n = len(w1), len(w2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(m + 1):
            for j in range(n + 1):
                if i == 0 or j == 0:
                    dp[i][j] = i + j
                elif w1[i - 1] == w2[j - 1]: 
                    dp[i][j] = dp[i - 1][j - 1]
                else: 
                    dp[i][j] = min(dp[i][j - 1] + 1, dp[i - 1][j] + 1)
        return dp[-1][-1]","auto minDistance(auto w1, auto w2) {
    m, n = len(w1), len(w2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(m + 1):
    for j in range(n + 1):
    if i == 0 or j == 0:
    dp[i][j] = i + j
    elif w1[i - 1] == w2[j - 1]:
    dp[i][j] = dp[i - 1][j - 1]
    else:
    dp[i][j] = min(dp[i][j - 1] + 1, dp[i - 1][j] + 1)
    return dp[-1][-1]
}"
59.py,"def generateMatrix(self, n):
        """"""
        :type n: int
        :rtype: List[List[int]]
        """"""
        def dirToIndex(x, y, d):
            if d == ""r"": return (x, y + 1, d) if y + 1 < n and matrix[x][y + 1] == 0 else (x + 1, y, ""d"")
            elif d == ""d"": return (x + 1, y, d) if x + 1 < n and matrix[x + 1][y] == 0 else (x, y - 1, ""l"")
            elif d == ""l"": return (x, y - 1, d) if y > 0 and matrix[x][y - 1] == 0 else (x - 1, y, ""u"")
            else: return (x - 1, y, d) if x > 0 and matrix[x - 1][y] == 0 else (x, y +1, ""r"")
        matrix = [[0 for i in range(1, n + 1)] for j in range(n)]
        num, dir, i, j = 1, ""r"", 0, 0
        while 0 <= i < n and 0 <= j < n and matrix[i][j] == 0:
            matrix[i][j] = num
            num += 1
            i, j, dir = dirToIndex(i, j, dir)
        return matrix        ","auto generateMatrix(auto n) {
    """"""
    :type n: int
    :rtype: List[List[int]]
    """"""
    def dirToIndex(x, y, d):
    if d == ""r"": return (x, y + 1, d) if y + 1 < n and matrix[x][y + 1] == 0 else (x + 1, y, ""d"")
    elif d == ""d"": return (x + 1, y, d) if x + 1 < n and matrix[x + 1][y] == 0 else (x, y - 1, ""l"")
    elif d == ""l"": return (x, y - 1, d) if y > 0 and matrix[x][y - 1] == 0 else (x - 1, y, ""u"")
    else: return (x - 1, y, d) if x > 0 and matrix[x - 1][y] == 0 else (x, y +1, ""r"")
    matrix = [[0 for i in range(1, n + 1)] for j in range(n)]
    num, dir, i, j = 1, ""r"", 0, 0
    while 0 <= i < n and 0 <= j < n and matrix[i][j] == 0:
    matrix[i][j] = num
    num += 1
    i, j, dir = dirToIndex(i, j, dir)
    return matrix
}"
591.py,"def isValid(self, S):
        CDATA_BEGIN = '![CDATA['
        CDATA_END = ']]>'

        def collect_tag(i):
            for j in range(i, len(S)):
                if S[j] == '>': break
            else:
                return None
            return S[i+1:j]

        def valid_tag(tag):
            return 1 <= len(tag) <= 9 and all('A' <= c <= 'Z' for c in tag)

        if not S or S[0] != '<': return False
        tag = collect_tag(0)
        if (tag is None or 
                not S.startswith('<{}>'.format(tag)) or 
                not S.endswith('</{}>'.format(tag)) or
                not valid_tag(tag)):
            return False
        S = S[len(tag) + 2: -len(tag) - 3]

        i = 0
        stack = []
        while i < len(S):
            if S[i] == '<':
                tag = collect_tag(i)
                if tag is None: return False
                if tag.startswith(CDATA_BEGIN):
                    while i < len(S) and S[i:i+3] != CDATA_END:
                        i += 1
                    if not S[i:i+3] == CDATA_END:
                        return False
                    i += 2
                elif tag.startswith('/'):
                    tag = tag[1:]
                    if not valid_tag(tag) or not stack or stack.pop() != tag:
                        return False
                else:
                    if not valid_tag(tag):
                        return False
                    stack.append(tag)
            i += 1

        return not stack","auto isValid(auto S) {
    CDATA_BEGIN = '![CDATA['
    CDATA_END = ']]>'
    
    def collect_tag(i):
    for j in range(i, len(S)):
    if S[j] == '>': break
    else:
    return None
    return S[i+1:j]
    
    def valid_tag(tag):
    return 1 <= len(tag) <= 9 and all('A' <= c <= 'Z' for c in tag)
    
    if not S or S[0] != '<': return False
    tag = collect_tag(0)
    if (tag is None or
    not S.startswith('<{}>'.format(tag)) or
    not S.endswith('</{}>'.format(tag)) or
    not valid_tag(tag)):
    return False
    S = S[len(tag) + 2: -len(tag) - 3]
    
    i = 0
    stack = []
    while i < len(S):
    if S[i] == '<':
    tag = collect_tag(i)
    if tag is None: return False
    if tag.startswith(CDATA_BEGIN):
    while i < len(S) and S[i:i+3] != CDATA_END:
    i += 1
    if not S[i:i+3] == CDATA_END:
    return False
    i += 2
    elif tag.startswith('/'):
    tag = tag[1:]
    if not valid_tag(tag) or not stack or stack.pop() != tag:
    return False
    else:
    if not valid_tag(tag):
    return False
    stack.append(tag)
    i += 1
    
    return not stack
}"
592.py,"def fractionAddition(self, e):
        
        def calc(i):
            l, r = i - 1, i + 1
            while l > 0 and e[l - 1].isdigit():
                l -= 1
            while r < len(e) - 1 and e[r + 1].isdigit():
                r += 1
            l = -int(e[l:i]) if l > 0 and e[l - 1] == ""-"" else int(e[l:i])
            r = int(e[i + 1:r + 1])
            return l, r
        
        def lcm(x, y):
            lcm = max(x, y)
            while True:
                if not lcm % x and not lcm % y:
                    return lcm
                lcm += 1
                
        def gcd(x, y):
            for i in range(min(x, y), 0, -1):
                if not x % i and not y % i:
                    return i
                
        n = d = None
        for i in range(len(e)):
            if e[i] == ""/"":
                if n:
                    n2, d2 = calc(i)
                    newD = lcm(d, d2)
                    newN = n * (newD // d) + n2 * (newD // d2)
                    if newN:
                        r = gcd(abs(newD), abs(newN))
                        n, d= newN // r, newD // r
                    else:
                        n, d = 0, 1
                else:
                    n, d = calc(i)
        return str(n) + ""/"" + str(d)","auto fractionAddition(auto e) {
    
    def calc(i):
    l, r = i - 1, i + 1
    while l > 0 and e[l - 1].isdigit():
    l -= 1
    while r < len(e) - 1 and e[r + 1].isdigit():
    r += 1
    l = -int(e[l:i]) if l > 0 and e[l - 1] == ""-"" else int(e[l:i])
    r = int(e[i + 1:r + 1])
    return l, r
    
    def lcm(x, y):
    lcm = max(x, y)
    while True:
    if not lcm % x and not lcm % y:
    return lcm
    lcm += 1
    
    def gcd(x, y):
    for i in range(min(x, y), 0, -1):
    if not x % i and not y % i:
    return i
    
    n = d = None
    for i in range(len(e)):
    if e[i] == ""/"":
    if n:
    n2, d2 = calc(i)
    newD = lcm(d, d2)
    newN = n * (newD // d) + n2 * (newD // d2)
    if newN:
    r = gcd(abs(newD), abs(newN))
    n, d= newN // r, newD // r
    else:
    n, d = 0, 1
    else:
    n, d = calc(i)
    return str(n) + ""/"" + str(d)
}"
593.py,"def validSquare(self, p1, p2, p3, p4):
        """"""
        :type p1: List[int]
        :type p2: List[int]
        :type p3: List[int]
        :type p4: List[int]
        :rtype: bool
        """"""
        from itertools import combinations as cb
        def D(C): 
            return (C[0][0] - C[1][0]) ** 2 + (C[0][1] - C[1][1]) ** 2
        S = set(map(D, cb((p1, p2, p3, p4), 2)))
        return len(S) == 2 and 0 not in S","auto validSquare(auto p1, auto p2, auto p3, auto p4) {
    """"""
    :type p1: List[int]
    :type p2: List[int]
    :type p3: List[int]
    :type p4: List[int]
    :rtype: bool
    """"""
    from itertools import combinations as cb
    def D(C):
    return (C[0][0] - C[1][0]) ** 2 + (C[0][1] - C[1][1]) ** 2
    S = set(map(D, cb((p1, p2, p3, p4), 2)))
    return len(S) == 2 and 0 not in S
}"
598.py,"def maxCount(self, m, n, ops):
        """"""
        :type m: int
        :type n: int
        :type ops: List[List[int]]
        :rtype: int
        """"""
        if ops==[]:
            return m*n
        return min(op[0] for op in ops)* min(op[1] for op in ops) ","auto maxCount(auto m, auto n, auto ops) {
    """"""
    :type m: int
    :type n: int
    :type ops: List[List[int]]
    :rtype: int
    """"""
    if ops==[]:
    return m*n
    return min(op[0] for op in ops)* min(op[1] for op in ops)
}"
599.py,"def findRestaurant(self, list1, list2):
        """"""
        :type list1: List[str]
        :type list2: List[str]
        :rtype: List[str]
        """"""
        dic={}
        for item1 in list1:
            for item2 in list2:
                if item1==item2:
                    dic[item1]=list1.index(item1)+list2.index(item2)
        return [k for k in dic if dic[k]==min(dic.values())]","auto findRestaurant(auto list1, auto list2) {
    """"""
    :type list1: List[str]
    :type list2: List[str]
    :rtype: List[str]
    """"""
    dic={}
    for item1 in list1:
    for item2 in list2:
    if item1==item2:
    dic[item1]=list1.index(item1)+list2.index(item2)
    return [k for k in dic if dic[k]==min(dic.values())]
}"
6.py,"def convert(self, s, numRows):
        if numRows == 1 or numRows >= len(s): return s
        row, direction, res = 0, -1, [""""] * numRows
        for char in s:
            res[row] += char
            if row == 0 or row == numRows - 1: direction *= -1 
            row += direction
        return """".join(res) ","auto convert(auto s, auto numRows) {
    if numRows == 1 or numRows >= len(s): return s
    row, direction, res = 0, -1, [""""] * numRows
    for char in s:
    res[row] += char
    if row == 0 or row == numRows - 1: direction *= -1
    row += direction
    return """".join(res)
}"
60.py,"def getPermutation(self, n, k):
        p = itertools.permutations(range(1, n + 1))
        for i in range(k): 
            res = next(p)
        return ''.join([str(i) for i in res])","auto getPermutation(auto n, auto k) {
    p = itertools.permutations(range(1, n + 1))
    for i in range(k):
    res = next(p)
    return ''.join([str(i) for i in res])
}"
600.py,"def findIntegers(self, num):
        num, sub = bin(num)[2:], 0
        zero, one = [1] * len(num), [1] * len(num)
        for i in range(1, len(num)):
            zero[i], one[i] = zero[i - 1] + one[i - 1], zero[i - 1]
        for i in range(1, len(num)):
            if num[i] == num[i - 1] == ""1"": break
            if num[i] == num[i - 1] == ""0"": sub += one[-1 - i]
        return zero[-1] + one[-1] - sub","auto findIntegers(auto num) {
    num, sub = bin(num)[2:], 0
    zero, one = [1] * len(num), [1] * len(num)
    for i in range(1, len(num)):
    zero[i], one[i] = zero[i - 1] + one[i - 1], zero[i - 1]
    for i in range(1, len(num)):
    if num[i] == num[i - 1] == ""1"": break
    if num[i] == num[i - 1] == ""0"": sub += one[-1 - i]
    return zero[-1] + one[-1] - sub
}"
605.py,"def canPlaceFlowers(self, flowerbed, n):
        """"""
        :type flowerbed: List[int]
        :type n: int
        :rtype: bool
        """"""
        num=n
        if len(flowerbed)<=1:
            if (num==1 and flowerbed==[0]) or (num==0):
                return True
            else:
                return False
        if flowerbed[0]==0 and flowerbed[1]==0:
            flowerbed[0]=1
            num-=1
        if flowerbed[-1]==0 and flowerbed[-2]==0:
            flowerbed[-1]=1
            num-=1
        for i in range(1,len(flowerbed)-2):
            if flowerbed[i]!=1 and flowerbed[i+1]!=1 and flowerbed[i-1]!=1:
                flowerbed[i]=1
                num-=1
        if num<=0:
            return True
        return False
            ","auto canPlaceFlowers(auto flowerbed, auto n) {
    """"""
    :type flowerbed: List[int]
    :type n: int
    :rtype: bool
    """"""
    num=n
    if len(flowerbed)<=1:
    if (num==1 and flowerbed==[0]) or (num==0):
    return True
    else:
    return False
    if flowerbed[0]==0 and flowerbed[1]==0:
    flowerbed[0]=1
    num-=1
    if flowerbed[-1]==0 and flowerbed[-2]==0:
    flowerbed[-1]=1
    num-=1
    for i in range(1,len(flowerbed)-2):
    if flowerbed[i]!=1 and flowerbed[i+1]!=1 and flowerbed[i-1]!=1:
    flowerbed[i]=1
    num-=1
    if num<=0:
    return True
    return False
}"
606.py,"def tree2str(self, t):
        """"""
        :type t: TreeNode
        :rtype: str
        """"""
        if not t: return """"
        parent=""%s"" %t.val
        left, right= """", """"
        if t.left or t.right: left= ""(%s)"" % self.tree2str(t.left)
        if t.right: right= ""(%s)"" % self.tree2str(t.right)
        return parent+left+right       ","auto tree2str(auto t) {
    """"""
    :type t: TreeNode
    :rtype: str
    """"""
    if not t: return """"
    parent=""%s"" %t.val
    left, right= """", """"
    if t.left or t.right: left= ""(%s)"" % self.tree2str(t.left)
    if t.right: right= ""(%s)"" % self.tree2str(t.right)
    return parent+left+right
}"
609.py,"def findDuplicate(self, paths):
        dic = collections.defaultdict(list)
        for path in paths:
            root, *f = path.split("" "")
            for file in f:
                txt, content = file.split(""("")
                dic[content] += root + ""/"" + txt,
        return [dic[key] for key in dic if len(dic[key]) > 1]","auto findDuplicate(auto paths) {
    dic = collections.defaultdict(list)
    for path in paths:
    root, *f = path.split("" "")
    for file in f:
    txt, content = file.split(""("")
    dic[content] += root + ""/"" + txt,
    return [dic[key] for key in dic if len(dic[key]) > 1]
}"
61.py,"def rotateRight(self, head, k):
        arr, count = [head], 0
        root = last = head
        while last and last.next and count < k:
            last, count = last.next, count+1
            arr.append(last)
        if k != count: 
            k = k % (count+1)
            last = arr[k]
        if k == 0 or not last: 
            return head
        curr = root
        while last.next:
            last, curr = last.next, curr.next
        last.next, curr.next, start = root, None, curr.next
        return start","auto rotateRight(auto head, auto k) {
    arr, count = [head], 0
    root = last = head
    while last and last.next and count < k:
    last, count = last.next, count+1
    arr.append(last)
    if k != count:
    k = k % (count+1)
    last = arr[k]
    if k == 0 or not last:
    return head
    curr = root
    while last.next:
    last, curr = last.next, curr.next
    last.next, curr.next, start = root, None, curr.next
    return start
}"
611.py,"def triangleNumber(self, nums):
        res, n = 0, len(nums); nums.sort()
        for i in range(n - 1, 1, -1):
            j, k = i - 1, 0
            while k < j:
                if nums[j] + nums[k] > nums[i]: res, j = res + j - k, j - 1
                else: k += 1
        return res","auto triangleNumber(auto nums) {
    res, n = 0, len(nums); nums.sort()
    for i in range(n - 1, 1, -1):
    j, k = i - 1, 0
    while k < j:
    if nums[j] + nums[k] > nums[i]: res, j = res + j - k, j - 1
    else: k += 1
    return res
}"
616.py,"def addBoldTag(self, S, words):
        trie, n, mask, res = {}, len(S), set(), """"
        for w in words:
            cur = trie
            for c in w:
                if c not in cur:
                    cur[c] = {}
                cur = cur[c]
            cur[""#""] = cur.get(""#"", set()) | {w}
        for i in range(n):
            cur, j = trie, i
            while j < n and S[j] in cur:
                cur = cur[S[j]]
                if ""#"" in cur:
                    mask |= {ind for ind in range(i, j + 1)}
                j += 1
        for i in range(n):
            if i in mask and (not i or i - 1 not in mask):
                res += ""<b>""
            res += S[i]
            if i in mask and (i == n - 1 or i + 1 not in mask):
                res += ""</b>""
        return res","auto addBoldTag(auto S, auto words) {
    trie, n, mask, res = {}, len(S), set(), """"
    for w in words:
    cur = trie
    for c in w:
    if c not in cur:
    cur[c] = {}
    cur = cur[c]
    cur[""#""] = cur.get(""#"", set()) | {w}
    for i in range(n):
    cur, j = trie, i
    while j < n and S[j] in cur:
    cur = cur[S[j]]
    if ""#"" in cur:
    mask |= {ind for ind in range(i, j + 1)}
    j += 1
    for i in range(n):
    if i in mask and (not i or i - 1 not in mask):
    res += ""<b>""
    res += S[i]
    if i in mask and (i == n - 1 or i + 1 not in mask):
    res += ""</b>""
    return res
}"
617.py,"def mergeTrees(self, t1, t2):
        """"""
        :type t1: TreeNode
        :type t2: TreeNode
        :rtype: TreeNode
        """"""
        if t1 and t2:
            root, root.left, root.right = TreeNode(t1.val + t2.val), self.mergeTrees(t1.left, t2.left), self.mergeTrees(t1.right, t2.right)
            return root
        else: return t1 or t2","auto mergeTrees(auto t1, auto t2) {
    """"""
    :type t1: TreeNode
    :type t2: TreeNode
    :rtype: TreeNode
    """"""
    if t1 and t2:
    root, root.left, root.right = TreeNode(t1.val + t2.val), self.mergeTrees(t1.left, t2.left), self.mergeTrees(t1.right, t2.right)
    return root
    else: return t1 or t2
}"
62.py,"def uniquePaths(self, m: int, n: int) -> int:
        dp = [[0] * m for _ in range(n)]
        dp[0][0] = 1
        for i in range(n):
            for j in range(m):
                if i - 1 >= 0:
                    dp[i][j] += dp[i - 1][j]
                if j - 1 >= 0:
                    dp[i][j] += dp[i][j - 1]
        return dp[-1][-1]","auto uniquePaths(auto m, auto n) {
    dp = [[0] * m for _ in range(n)]
    dp[0][0] = 1
    for i in range(n):
    for j in range(m):
    if i - 1 >= 0:
    dp[i][j] += dp[i - 1][j]
    if j - 1 >= 0:
    dp[i][j] += dp[i][j - 1]
    return dp[-1][-1]
}"
621.py,"def leastInterval(self, tasks, n):
        cnt = sorted(collections.Counter(tasks).values())
        idles = (cnt[-1] - 1) * n
        for i in range(len(cnt) - 1): idles -= min(cnt[i], cnt[-1] - 1)
        return idles > 0 and idles + len(tasks) or len(tasks)","auto leastInterval(auto tasks, auto n) {
    cnt = sorted(collections.Counter(tasks).values())
    idles = (cnt[-1] - 1) * n
    for i in range(len(cnt) - 1): idles -= min(cnt[i], cnt[-1] - 1)
    return idles > 0 and idles + len(tasks) or len(tasks)
}"
623.py,"def addOneRow(self, root, v, d):
        """"""
        :type root: TreeNode
        :type v: int
        :type d: int
        :rtype: TreeNode
        """"""
        q, depth = [root], 1
        while depth != d: parent, q, depth = q, [kid for node in q for kid in (node.left, node.right) if kid], depth+1
        if d != 1:
            for node in parent: node.left, node.right, node.left.left, node.right.right = TreeNode(v), TreeNode(v), node.left, node.right
            return root
        else: 
            first, first.left = TreeNode(v), root
            return first","auto addOneRow(auto root, auto v, auto d) {
    """"""
    :type root: TreeNode
    :type v: int
    :type d: int
    :rtype: TreeNode
    """"""
    q, depth = [root], 1
    while depth != d: parent, q, depth = q, [kid for node in q for kid in (node.left, node.right) if kid], depth+1
    if d != 1:
    for node in parent: node.left, node.right, node.left.left, node.right.right = TreeNode(v), TreeNode(v), node.left, node.right
    return root
    else:
    first, first.left = TreeNode(v), root
    return first
}"
624.py,"def maxDistance(self, arrays):
        arrays.sort(key = lambda x: x[0])
        d1 = max(arr[-1] for arr in arrays[1:]) - arrays[0][0]
        arrays.sort(key = lambda x: x[-1])
        d2 = arrays[-1][-1] - min(arr[0] for arr in arrays[:-1])
        return max(d1, d2)","auto maxDistance(auto arrays) {
    arrays.sort(key = lambda x: x[0])
    d1 = max(arr[-1] for arr in arrays[1:]) - arrays[0][0]
    arrays.sort(key = lambda x: x[-1])
    d2 = arrays[-1][-1] - min(arr[0] for arr in arrays[:-1])
    return max(d1, d2)
}"
625.py,"def smallestFactorization(self, a):
        res = []
        def dfs(num):
            if num == 1: return True
            for n in range(9, 1, -1):
                if not num % n:
                    res.append(str(n))
                    return dfs(num // n)
            return False 
        bol, num = dfs(a), int("""".join(sorted(res))) if res else 1
        return num if bol and -(2 ** 31) <= num <= 2 ** 31 - 1 else 0","auto smallestFactorization(auto a) {
    res = []
    def dfs(num):
    if num == 1: return True
    for n in range(9, 1, -1):
    if not num % n:
    res.append(str(n))
    return dfs(num // n)
    return False
    bol, num = dfs(a), int("""".join(sorted(res))) if res else 1
    return num if bol and -(2 ** 31) <= num <= 2 ** 31 - 1 else 0
}"
628.py,"def maximumProduct(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        nums.sort()
        return max(nums[-1]*nums[-2]*nums[-3], nums[-1]*nums[0]*nums[1])","auto maximumProduct(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: int
    """"""
    nums.sort()
    return max(nums[-1]*nums[-2]*nums[-3], nums[-1]*nums[0]*nums[1])
}"
629.py,"def kInversePairs(self, n, k):
        dp = [1] + [0] * k
        for i in range(2, n + 1):
            for j in range(1, k + 1): dp[j] += dp[j - 1]
            for j in range(k, 0, -1): dp[j] -= j - i >= 0 and dp[j - i]
        return dp[-1] % (10 ** 9 + 7)","auto kInversePairs(auto n, auto k) {
    dp = [1] + [0] * k
    for i in range(2, n + 1):
    for j in range(1, k + 1): dp[j] += dp[j - 1]
    for j in range(k, 0, -1): dp[j] -= j - i >= 0 and dp[j - i]
    return dp[-1] % (10 ** 9 + 7)
}"
63.py,"def uniquePathsWithObstacles(self, obstacleGrid):
        if obstacleGrid[0][0] == 1: return 0
        for i in range(len(obstacleGrid)):
            for j in range(len(obstacleGrid[0])): 
                if obstacleGrid[i][j] == 1 or i == j == 0:
                    obstacleGrid[i][j] -= 1
                else:
                    add1 = obstacleGrid[i - 1][j] if i > 0 else 0
                    add2 = obstacleGrid[i][j - 1] if j > 0 else 0
                    obstacleGrid[i][j] += add1 + add2
        return abs(obstacleGrid[-1][-1])","auto uniquePathsWithObstacles(auto obstacleGrid) {
    if obstacleGrid[0][0] == 1: return 0
    for i in range(len(obstacleGrid)):
    for j in range(len(obstacleGrid[0])):
    if obstacleGrid[i][j] == 1 or i == j == 0:
    obstacleGrid[i][j] -= 1
    else:
    add1 = obstacleGrid[i - 1][j] if i > 0 else 0
    add2 = obstacleGrid[i][j - 1] if j > 0 else 0
    obstacleGrid[i][j] += add1 + add2
    return abs(obstacleGrid[-1][-1])
}"
630.py,"def scheduleCourse(self, courses):
        pq = []
        start = 0
        for t, end in sorted(courses, key = lambda x: x[1]):
            start += t
            heapq.heappush(pq, -t)
            while start > end:
                start += heapq.heappop(pq)
        return len(pq)","auto scheduleCourse(auto courses) {
    pq = []
    start = 0
    for t, end in sorted(courses, key = lambda x: x[1]):
    start += t
    heapq.heappush(pq, -t)
    while start > end:
    start += heapq.heappop(pq)
    return len(pq)
}"
632.py,"def smallestRange(self, nums):
        L = R = None
        while True:
            mn = mx = nums[0][-1]
            ind = [0]
            for i, ls in enumerate(nums[1:]):
                if ls[-1] > mx:
                    mx, ind = ls[-1], [i + 1]
                elif ls[-1] == mx:
                    ind.append(i + 1)
                elif ls[-1] < mn:
                    mn = ls[-1]
            if L == None or mx - mn <= R - L:
                L, R = mn, mx
            for j in ind:
                nums[j].pop()
                if not nums[j]:
                    return [L, R]","auto smallestRange(auto nums) {
    L = R = None
    while True:
    mn = mx = nums[0][-1]
    ind = [0]
    for i, ls in enumerate(nums[1:]):
    if ls[-1] > mx:
    mx, ind = ls[-1], [i + 1]
    elif ls[-1] == mx:
    ind.append(i + 1)
    elif ls[-1] < mn:
    mn = ls[-1]
    if L == None or mx - mn <= R - L:
    L, R = mn, mx
    for j in ind:
    nums[j].pop()
    if not nums[j]:
    return [L, R]
}"
633.py,"def judgeSquareSum(self, c: int) -> bool:
        return not all(((c - i ** 2) ** 0.5) % 1 for i in range(int(c ** 0.5) + 1))","auto judgeSquareSum(auto c) {
    return not all(((c - i ** 2) ** 0.5) % 1 for i in range(int(c ** 0.5) + 1))
}"
636.py,"def exclusiveTime(self, n, logs):
        res, stack = [0] * n, []
        for log in logs:
            log = log.split("":"")
            if log[1] == ""start"":
                stack.append([int(log[2]), 0])
            else:
                start = stack.pop()
                time = int(log[2]) - start[0] + 1
                res[int(log[0])] += time - start[1]
                if stack:
                    stack[-1][1] += time
        return res","auto exclusiveTime(auto n, auto logs) {
    res, stack = [0] * n, []
    for log in logs:
    log = log.split("":"")
    if log[1] == ""start"":
    stack.append([int(log[2]), 0])
    else:
    start = stack.pop()
    time = int(log[2]) - start[0] + 1
    res[int(log[0])] += time - start[1]
    if stack:
    stack[-1][1] += time
    return res
}"
638.py,"def shoppingOffers(self, price, special, needs):
        def dfs(cur, needs):
            val = cur + sum(p * needs[i] for i, p in enumerate(price))
            for s in special:
                if all(n >= s[i] for i,n in enumerate(needs)): val = min(val, dfs(cur + s[-1], [n - s[i] for i,n in enumerate(needs)]))
            return val
        return dfs(0, needs)","auto shoppingOffers(auto price, auto special, auto needs) {
    def dfs(cur, needs):
    val = cur + sum(p * needs[i] for i, p in enumerate(price))
    for s in special:
    if all(n >= s[i] for i,n in enumerate(needs)): val = min(val, dfs(cur + s[-1], [n - s[i] for i,n in enumerate(needs)]))
    return val
    return dfs(0, needs)
}"
639.py,"def numDecodings(self, s):
        if s[0] == ""0"": return 0
        dp1 = dp2 = 1
        if s[0] == ""*"": dp2 = 9
        for i in range(1, len(s)):
            couple, newDp1 = s[i -1: i + 1], dp2
            if s[i] == ""0"":
                if s[i - 1] == ""0"" or s[i - 1] >= ""3"": return 0
                dp2 = 2 * dp1 if s[i - 1] == ""*"" else dp1
            elif s[i] == ""*"":
                dp2 *= 9
                if s[i - 1] == ""2"": dp2 += 6 * dp1
                elif s[i - 1] == ""1"": dp2 += 9 * dp1
                elif s[i - 1] == ""*"": dp2 += 15 * dp1
            elif ""10"" <= couple <= ""26"": dp2 += dp1
            elif s[i - 1] == ""*"": dp2 += 2 * dp1 if s[i] <= ""6"" else dp1
            dp1 = newDp1
        return dp2 % (10 ** 9 + 7)  ","auto numDecodings(auto s) {
    if s[0] == ""0"": return 0
    dp1 = dp2 = 1
    if s[0] == ""*"": dp2 = 9
    for i in range(1, len(s)):
    couple, newDp1 = s[i -1: i + 1], dp2
    if s[i] == ""0"":
    if s[i - 1] == ""0"" or s[i - 1] >= ""3"": return 0
    dp2 = 2 * dp1 if s[i - 1] == ""*"" else dp1
    elif s[i] == ""*"":
    dp2 *= 9
    if s[i - 1] == ""2"": dp2 += 6 * dp1
    elif s[i - 1] == ""1"": dp2 += 9 * dp1
    elif s[i - 1] == ""*"": dp2 += 15 * dp1
    elif ""10"" <= couple <= ""26"": dp2 += dp1
    elif s[i - 1] == ""*"": dp2 += 2 * dp1 if s[i] <= ""6"" else dp1
    dp1 = newDp1
    return dp2 % (10 ** 9 + 7)
}"
64.py,"def minPathSum(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: int
        """"""
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                grid[i][j] += min(grid[i][j - 1] if j > 0 else float(""inf""), grid[i - 1][j] if i > 0 else float(""inf"")) if i!=0 or j != 0 else 0
        return grid[-1][-1]","auto minPathSum(auto grid) {
    """"""
    :type grid: List[List[int]]
    :rtype: int
    """"""
    for i in range(len(grid)):
    for j in range(len(grid[0])):
    grid[i][j] += min(grid[i][j - 1] if j > 0 else float(""inf""), grid[i - 1][j] if i > 0 else float(""inf"")) if i!=0 or j != 0 else 0
    return grid[-1][-1]
}"
640.py,"def solveEquation(self, equation):
        def calc(eq):
            smX = smNum = 0
            add, num = True, """"
            for c in eq + ""+"":
                if c.isdigit():
                    num += c
                elif c == ""x"":
                    smX += int(num) if add and num else -int(num) if num else 1 if add else -1
                    num = """"
                else:
                    smNum += int(num) if add and num else -int(num) if num else 0
                    num, add = """", c == ""+""
            return smX, smNum
        eq = equation.split(""="")
        lX, lNum, rX, rNum = calc(eq[0]) + calc(eq[1])
        if lX == rX: 
            return ""No solution"" if lNum != rNum else ""Infinite solutions""
        return ""x="" + str((lNum - rNum) // (rX - lX))","auto solveEquation(auto equation) {
    def calc(eq):
    smX = smNum = 0
    add, num = True, """"
    for c in eq + ""+"":
    if c.isdigit():
    num += c
    elif c == ""x"":
    smX += int(num) if add and num else -int(num) if num else 1 if add else -1
    num = """"
    else:
    smNum += int(num) if add and num else -int(num) if num else 0
    num, add = """", c == ""+""
    return smX, smNum
    eq = equation.split(""="")
    lX, lNum, rX, rNum = calc(eq[0]) + calc(eq[1])
    if lX == rX:
    return ""No solution"" if lNum != rNum else ""Infinite solutions""
    return ""x="" + str((lNum - rNum) // (rX - lX))
}"
643.py,"def findMaxAverage(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: float
        """"""
        sm=sum(nums[:k])
        mx,j=sm/k, 0
        for i in range(k,len(nums)): sm+=nums[i]; sm-=nums[j]; curr=sm/k; mx=max(curr,mx); j+=1
        return mx","auto findMaxAverage(auto nums, auto k) {
    """"""
    :type nums: List[int]
    :type k: int
    :rtype: float
    """"""
    sm=sum(nums[:k])
    mx,j=sm/k, 0
    for i in range(k,len(nums)): sm+=nums[i]; sm-=nums[j]; curr=sm/k; mx=max(curr,mx); j+=1
    return mx
}"
644.py,"def findMaxAverage(self, nums: List[int], k: int) -> float:
        def sub(mid):
            sm = pre = mn = 0
            for i in range(k):
                sm += nums[i] - mid
            if sm >= 0:
                return True
            for i in range(k, len(nums)):
                sm += nums[i] - mid
                pre += nums[i - k] - mid
                mn = min(mn, pre)
                if sm >= mn:
                    return True
            return False
        l, r = min(nums), max(nums)
        while l + 1E-6 < r:
            mid = (l + r) / 2
            if sub(mid):
                l = mid
            else:
                r = mid
        return l","auto findMaxAverage(auto nums, auto k) {
    def sub(mid):
    sm = pre = mn = 0
    for i in range(k):
    sm += nums[i] - mid
    if sm >= 0:
    return true
    for i in range(k, len(nums)):
    sm += nums[i] - mid
    pre += nums[i - k] - mid
    mn = min(mn, pre)
    if sm >= mn:
    return true
    return false
    l, r = min(nums), max(nums)
    while l + 1E-6 < r:
    mid = (l + r) / 2
    if sub(mid):
    l = mid
    else:
    r = mid
    return l
}"
645.py,"def findErrorNums(self, nums: List[int]) -> List[int]:
        cnt = collections.Counter(nums)
        return [k for k in cnt if cnt[k] == 2] + [i for i in range(1, len(nums) + 1) if i not in cnt]","auto findErrorNums(auto nums) {
    cnt = collections.Counter(nums)
    return [k for k in cnt if cnt[k] == 2] + [i for i in range(1, len(nums) + 1) if i not in cnt]
}"
646.py,"def findLongestChain(self, pairs):
        pairs.sort(key = lambda x: x[1])
        res, pre = 1, pairs[0][1]
        for c, d in pairs[1:]:
            if pre < c:
                pre = d
                res += 1
        return res","auto findLongestChain(auto pairs) {
    pairs.sort(key = lambda x: x[1])
    res, pre = 1, pairs[0][1]
    for c, d in pairs[1:]:
    if pre < c:
    pre = d
    res += 1
    return res
}"
647.py,"def countSubstrings(self, s):       
        res = 0
        for k in range(len(s)):
            i = j = k
            while 0 <= i and j < len(s):
                if s[i] == s[j]: res += 1
                else: break
                i , j = i - 1, j + 1
            i , j =k , k + 1
            while 0 <= i and j < len(s):
                if s[i] == s[j]: res += 1
                else: break
                i , j = i - 1, j + 1
        return res","auto countSubstrings(auto s) {
    res = 0
    for k in range(len(s)):
    i = j = k
    while 0 <= i and j < len(s):
    if s[i] == s[j]: res += 1
    else: break
    i , j = i - 1, j + 1
    i , j =k , k + 1
    while 0 <= i and j < len(s):
    if s[i] == s[j]: res += 1
    else: break
    i , j = i - 1, j + 1
    return res
}"
648.py,"def replaceWords(self, dict, sentence):
        """"""
        :type dict: List[str]
        :type sentence: str
        :rtype: str
        """"""
        s = set(dict)
        sentence = sentence.split()
        for j, w in enumerate(sentence):
            for i in range(1, len(w)):
                if w[:i] in s: 
                    sentence[j] = w[:i]
                    break
        return "" "".join(sentence)                    ","auto replaceWords(auto dict, auto sentence) {
    """"""
    :type dict: List[str]
    :type sentence: str
    :rtype: str
    """"""
    s = set(dict)
    sentence = sentence.split()
    for j, w in enumerate(sentence):
    for i in range(1, len(w)):
    if w[:i] in s:
    sentence[j] = w[:i]
    break
    return "" "".join(sentence)
}"
649.py,"def predictPartyVictory(self, senate):
        ban_r = ban_d = 0
        while True:
            new = []
            r_cnt = d_cnt = 0
            for s in senate:
                if s == 'R': 
                    r_cnt += 1
                    if ban_r > 0: 
                        ban_r -= 1
                    else: 
                        ban_d += 1
                        d_cnt -= 1
                        new.append(s)
                elif s == 'D':
                    d_cnt += 1
                    if ban_d > 0: 
                        ban_d -= 1
                    else: 
                        ban_r += 1
                        r_cnt -= 1
                        new.append(s)
            if d_cnt < 0 < r_cnt:
                return ""Radiant""
            elif r_cnt < 0 < d_cnt:
                return ""Dire""
            senate = new","auto predictPartyVictory(auto senate) {
    ban_r = ban_d = 0
    while True:
    new = []
    r_cnt = d_cnt = 0
    for s in senate:
    if s == 'R':
    r_cnt += 1
    if ban_r > 0:
    ban_r -= 1
    else:
    ban_d += 1
    d_cnt -= 1
    new.append(s)
    elif s == 'D':
    d_cnt += 1
    if ban_d > 0:
    ban_d -= 1
    else:
    ban_r += 1
    r_cnt -= 1
    new.append(s)
    if d_cnt < 0 < r_cnt:
    return ""Radiant""
    elif r_cnt < 0 < d_cnt:
    return ""Dire""
    senate = new
}"
65.py,"def isNumber(self, s):
        s = s.strip()
        pointSeen = eSeen = numberSeen = False
        numberAfterE = True
        for i, c in enumerate(s):
            if ""0"" <= c <= ""9"":
                numberSeen = numberAfterE = True
            elif c == ""."":
                if eSeen or pointSeen:
                    return False
                pointSeen = True
            elif c == ""e"":
                if eSeen or not numberSeen:
                    return False
                numberAfterE = False
                eSeen = True
            elif c in ""-+"":
                if i and s[i - 1] != ""e"":
                    return False
            else:
                return False
        return numberSeen and numberAfterE","auto isNumber(auto s) {
    s = s.strip()
    pointSeen = eSeen = numberSeen = False
    numberAfterE = True
    for i, c in enumerate(s):
    if ""0"" <= c <= ""9"":
    numberSeen = numberAfterE = True
    elif c == ""."":
    if eSeen or pointSeen:
    return False
    pointSeen = True
    elif c == ""e"":
    if eSeen or not numberSeen:
    return False
    numberAfterE = False
    eSeen = True
    elif c in ""-+"":
    if i and s[i - 1] != ""e"":
    return False
    else:
    return False
    return numberSeen and numberAfterE
}"
650.py,"def minSteps(self, n):
        cur, copy, steps = 1, 0, 0
        while cur != n:
            if copy < cur and not (n - cur) % cur:
                copy = cur
            else:
                cur += copy
            steps += 1
        return steps","auto minSteps(auto n) {
    cur, copy, steps = 1, 0, 0
    while cur != n:
    if copy < cur and not (n - cur) % cur:
    copy = cur
    else:
    cur += copy
    steps += 1
    return steps
}"
651.py,"def maxA(self, N):
        dp = [0] * (N + 1)
        for i in range(N + 1):
            dp[i] = i
            for j in range(1, i - 2):
                dp[i] = max(dp[i], dp[j] * (i - j - 1))
        return dp[N]","auto maxA(auto N) {
    dp = [0] * (N + 1)
    for i in range(N + 1):
    dp[i] = i
    for j in range(1, i - 2):
    dp[i] = max(dp[i], dp[j] * (i - j - 1))
    return dp[N]
}"
652.py,"def findDuplicateSubtrees(self, root):
        def dfs(root):
            if not root: return ""null""
            struct = ""%s,%s,%s"" % (str(root.val), dfs(root.left), dfs(root.right))
            nodes[struct].append(root)
            return struct
        
        nodes = collections.defaultdict(list)
        dfs(root)
        return [nodes[struct][0] for struct in nodes if len(nodes[struct]) > 1]","auto findDuplicateSubtrees(auto root) {
    def dfs(root):
    if not root: return ""null""
    struct = ""%s,%s,%s"" % (str(root.val), dfs(root.left), dfs(root.right))
    nodes[struct].append(root)
    return struct
    
    nodes = collections.defaultdict(list)
    dfs(root)
    return [nodes[struct][0] for struct in nodes if len(nodes[struct]) > 1]
}"
653.py,"def findTarget(self, root, k):
        """"""
        :type root: TreeNode
        :type k: int
        :rtype: bool
        """"""
        def traverse(node):
            if not node: return False
            if not node.val in dic: dic[k-node.val]=1
            else: return True
            return traverse(node.left) or traverse(node.right)
        dic={}
        return traverse(root)","auto findTarget(auto root, auto k) {
    """"""
    :type root: TreeNode
    :type k: int
    :rtype: bool
    """"""
    def traverse(node):
    if not node: return False
    if not node.val in dic: dic[k-node.val]=1
    else: return True
    return traverse(node.left) or traverse(node.right)
    dic={}
    return traverse(root)
}"
654.py,"def constructMaximumBinaryTree(self, nums):
        """"""
        :type nums: List[int]
        :rtype: TreeNode
        """"""
        if nums:
            pos = nums.index(max(nums))
            root = TreeNode(nums[pos])
            root.left = self.constructMaximumBinaryTree(nums[:pos])
            root.right = self.constructMaximumBinaryTree(nums[pos+1:])
            return root","auto constructMaximumBinaryTree(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: TreeNode
    """"""
    if nums:
    pos = nums.index(max(nums))
    root = TreeNode(nums[pos])
    root.left = self.constructMaximumBinaryTree(nums[:pos])
    root.right = self.constructMaximumBinaryTree(nums[pos+1:])
    return root
}"
655.py,"def printTree(self, root):
        """"""
        :type root: TreeNode
        :rtype: List[List[str]]
        """"""
        def traverse(node):
            if not node: return 0
            return max(traverse(node.left), traverse(node.right)) * 2 + 1
        length = traverse(root)
        stack, dic, res, padding = [root], {root : length // 2}, [], length // 2
        while any(stack):
            out, tmp, padding = [""""] * length, [], padding // 2
            for i, node in enumerate(stack):
                out[dic[node]] = str(node.val)
                if node.left:
                    dic[node.left] = dic[node] - padding - 1
                    tmp.append(node.left)
                if node.right:
                    dic[node.right] = dic[node] + padding + 1
                    tmp.append(node.right)
            res.append(out)
            stack = tmp
        return res","auto printTree(auto root) {
    """"""
    :type root: TreeNode
    :rtype: List[List[str]]
    """"""
    def traverse(node):
    if not node: return 0
    return max(traverse(node.left), traverse(node.right)) * 2 + 1
    length = traverse(root)
    stack, dic, res, padding = [root], {root : length // 2}, [], length // 2
    while any(stack):
    out, tmp, padding = [""""] * length, [], padding // 2
    for i, node in enumerate(stack):
    out[dic[node]] = str(node.val)
    if node.left:
    dic[node.left] = dic[node] - padding - 1
    tmp.append(node.left)
    if node.right:
    dic[node.right] = dic[node] + padding + 1
    tmp.append(node.right)
    res.append(out)
    stack = tmp
    return res
}"
656.py,"def cheapestJump(self, A, B): 
        n = len(A)
        preMin = {n - 1:[n]}
        for i in range(n - 2, -1, -1):
            if A[i] == -1:
                continue
            mn, preIndex = float(""inf""), None
            for ind in range(i + 1, i + B + 1 <= n and i + B + 1 or n):
                if -1 < A[ind] < mn:
                    mn, preIndex = A[ind], ind
            if preIndex:
                A[i] += A[preIndex]
                preMin[i] = preMin[preIndex] + [i + 1]
            else:
                A[i] = -1
        return 0 in preMin and preMin[0][::-1] or []","auto cheapestJump(auto A, auto B) {
    n = len(A)
    preMin = {n - 1:[n]}
    for i in range(n - 2, -1, -1):
    if A[i] == -1:
    continue
    mn, preIndex = float(""inf""), None
    for ind in range(i + 1, i + B + 1 <= n and i + B + 1 or n):
    if -1 < A[ind] < mn:
    mn, preIndex = A[ind], ind
    if preIndex:
    A[i] += A[preIndex]
    preMin[i] = preMin[preIndex] + [i + 1]
    else:
    A[i] = -1
    return 0 in preMin and preMin[0][::-1] or []
}"
657.py,"def judgeCircle(self, moves):
        """"""
        :type moves: str
        :rtype: bool
        """"""
        x,y = 0, 0
        for char in moves:
            if char==""R"": x+=1
            if char==""L"": x-=1
            if char==""U"": y+=1
            if char==""D"": y-=1
        return True if x==0 and y==0 else False
        ","auto judgeCircle(auto moves) {
    """"""
    :type moves: str
    :rtype: bool
    """"""
    x,y = 0, 0
    for char in moves:
    if char==""R"": x+=1
    if char==""L"": x-=1
    if char==""U"": y+=1
    if char==""D"": y-=1
    return True if x==0 and y==0 else False
}"
658.py,"def findClosestElements(self, arr, k, x):
        ind, n = bisect.bisect_left(arr, x), len(arr)
        if ind > 0 and x - arr[ind - 1] < arr[ind] - x: ind -= 1
        l, r = ind, ind + 1
        for _ in range(k - 1):
            if r >= n or (l > 0 and x - arr[l - 1] <= arr[r] - x): l -= 1
            else: r += 1
        return arr[l:r]","auto findClosestElements(auto arr, auto k, auto x) {
    ind, n = bisect.bisect_left(arr, x), len(arr)
    if ind > 0 and x - arr[ind - 1] < arr[ind] - x: ind -= 1
    l, r = ind, ind + 1
    for _ in range(k - 1):
    if r >= n or (l > 0 and x - arr[l - 1] <= arr[r] - x): l -= 1
    else: r += 1
    return arr[l:r]
}"
659.py,"def isPossible(self, nums):
        heap, last = [], collections.defaultdict(int)
        for num in nums:
            last[num] += 1
            if heap and heap[0][0] <= num - 1:
                if heap[0][0] < num - 1:
                    return False
                else:
                    last[num - 1] -= 1
                    n, l = heapq.heappop(heap)
                    if l == -1:
                        heapq.heappush(heap, (num, -2))
            elif num - 1 not in last or not last[num - 1]:
                heapq.heappush(heap, (num, -1))
            else:
                last[num - 1] -= 1
        return not heap","auto isPossible(auto nums) {
    heap, last = [], collections.defaultdict(int)
    for num in nums:
    last[num] += 1
    if heap and heap[0][0] <= num - 1:
    if heap[0][0] < num - 1:
    return False
    else:
    last[num - 1] -= 1
    n, l = heapq.heappop(heap)
    if l == -1:
    heapq.heappush(heap, (num, -2))
    elif num - 1 not in last or not last[num - 1]:
    heapq.heappush(heap, (num, -1))
    else:
    last[num - 1] -= 1
    return not heap
}"
66.py,"def plusOne(self, digits, add = 1):
        return add and [1] or [] if not digits else self.plusOne(digits[:-1], +(digits[-1] + add > 9)) + [(digits[-1] + add) % 10]","auto plusOne(auto digits, auto add = 1) {
    return add and [1] or [] if not digits else self.plusOne(digits[:-1], +(digits[-1] + add > 9)) + [(digits[-1] + add) % 10]
}"
660.py,"def newInteger(self, n):
        base9 = """"
        while n:
            base9 += str(n % 9)
            n //= 9
        return int(base9[::-1])","auto newInteger(auto n) {
    base9 = """"
    while n:
    base9 += str(n % 9)
    n //= 9
    return int(base9[::-1])
}"
661.py,"def imageSmoother(self, M: List[List[int]]) -> List[List[int]]:
        m, n = len(M), len(M[0])
        grid = [[0] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                adj = [M[i + x][j + y] for x, y in ((0, 0), (-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, 1), (1, -1)) if 0 <= i + x < m and 0 <= j + y < n] 
                grid[i][j] = sum(adj) // len(adj)
        return grid
                    
        ","auto imageSmoother(auto M) {
    m, n = len(M), len(M[0])
    grid = [[0] * n for _ in range(m)]
    for i in range(m):
    for j in range(n):
    adj = [M[i + x][j + y] for x, y in ((0, 0), (-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, 1), (1, -1)) if 0 <= i + x < m and 0 <= j + y < n]
    grid[i][j] = sum(adj) // len(adj)
    return grid
}"
662.py,"def widthOfBinaryTree(self, root):
        """"""
        :type root: TreeNode
        :rtype: int
        """"""
        dic, stack, res = {root: 1}, [root], 0
        while any(stack):
            tmp, mn ,mx = [], float(""inf""), - float(""inf"")
            for node in stack:
                res = max(res, dic[stack[-1]] - dic[stack[0]] + 1) 
                if node.left: tmp, dic[node.left] = tmp + [node.left], dic[node] * 2 - 1 
                if node.right: tmp, dic[node.right] = tmp + [node.right], dic[node] * 2
            stack = tmp
        return res","auto widthOfBinaryTree(auto root) {
    """"""
    :type root: TreeNode
    :rtype: int
    """"""
    dic, stack, res = {root: 1}, [root], 0
    while any(stack):
    tmp, mn ,mx = [], float(""inf""), - float(""inf"")
    for node in stack:
    res = max(res, dic[stack[-1]] - dic[stack[0]] + 1)
    if node.left: tmp, dic[node.left] = tmp + [node.left], dic[node] * 2 - 1
    if node.right: tmp, dic[node.right] = tmp + [node.right], dic[node] * 2
    stack = tmp
    return res
}"
664.py,"def strangePrinter(self, s):
        memo = {}
        def dp(i, j):
            if i > j: return 0
            if (i, j) not in memo:
                ans = dp(i+1, j) + 1
                for k in range(i+1, j+1):
                    if s[k] == s[i]:
                        ans = min(ans, dp(i, k-1) + dp(k+1, j))
                memo[i, j] = ans
            return memo[i, j]
        return dp(0, len(s) - 1)","auto strangePrinter(auto s) {
    memo = {}
    def dp(i, j):
    if i > j: return 0
    if (i, j) not in memo:
    ans = dp(i+1, j) + 1
    for k in range(i+1, j+1):
    if s[k] == s[i]:
    ans = min(ans, dp(i, k-1) + dp(k+1, j))
    memo[i, j] = ans
    return memo[i, j]
    return dp(0, len(s) - 1)
}"
665.py,"def checkPossibility(self, nums):
        """"""
        :type nums: List[int]
        :rtype: bool
        """"""  
        for i in range(len(nums)-1):
            if nums[i]>nums[i+1]:
                mod1, mod2=list(nums), list(nums)
                mod1[i], mod2[i+1]=mod1[i+1], mod2[i]
                if mod1!=sorted(mod1) and mod2!=sorted(mod2): return False
        return True","auto checkPossibility(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: bool
    """"""
    for i in range(len(nums)-1):
    if nums[i]>nums[i+1]:
    mod1, mod2=list(nums), list(nums)
    mod1[i], mod2[i+1]=mod1[i+1], mod2[i]
    if mod1!=sorted(mod1) and mod2!=sorted(mod2): return False
    return True
}"
666.py,"def pathSum(self, nums):
        dp = {(0, 1) : 0}
        for num in nums:
            d, p, v = map(int, str(num))
            dp[(d, p)] = v + dp[(d - 1, (p + 1) // 2)]
        return sum(dp[k] for k in dp if (k[0] + 1, k[1] * 2) not in dp and (k[0] + 1, k[1] * 2 - 1) not in dp)","auto pathSum(auto nums) {
    dp = {(0, 1) : 0}
    for num in nums:
    d, p, v = map(int, str(num))
    dp[(d, p)] = v + dp[(d - 1, (p + 1) // 2)]
    return sum(dp[k] for k in dp if (k[0] + 1, k[1] * 2) not in dp and (k[0] + 1, k[1] * 2 - 1) not in dp)
}"
667.py,"def constructArray(self, n, k):
        """"""
        :type n: int
        :type k: int
        :rtype: List[int]
        """"""
        left, right, res = 0, n+1, [None]*n
        for i in range(n):
            if k == 1:
                if i%2 == 0:
                    while i<n: res[i], right, i = right - 1, right - 1, i + 1 
                else:
                    while i<n: res[i], left, i = left + 1, left + 1, i + 1
                return res
            else:
                if i%2 != 0: res[i], right = right - 1, right - 1
                else: res[i], left = left + 1, left + 1
                if i != 0: k -= 1","auto constructArray(auto n, auto k) {
    """"""
    :type n: int
    :type k: int
    :rtype: List[int]
    """"""
    left, right, res = 0, n+1, [None]*n
    for i in range(n):
    if k == 1:
    if i%2 == 0:
    while i<n: res[i], right, i = right - 1, right - 1, i + 1
    else:
    while i<n: res[i], left, i = left + 1, left + 1, i + 1
    return res
    else:
    if i%2 != 0: res[i], right = right - 1, right - 1
    else: res[i], left = left + 1, left + 1
    if i != 0: k -= 1
}"
668.py,"def findKthNumber(self, m, n, k):       
        l, r = 1, m * n
        while l < r:
            mid = (l + r) // 2
            if sum(min(mid // i, n) for i in range(1, m + 1)) < k:
                l = mid + 1
            else:
                r = mid
        return l","auto findKthNumber(auto m, auto n, auto k) {
    l, r = 1, m * n
    while l < r:
    mid = (l + r) // 2
    if sum(min(mid // i, n) for i in range(1, m + 1)) < k:
    l = mid + 1
    else:
    r = mid
    return l
}"
67.py,"def addBinary(self, a: str, b: str) -> str:
        return bin(int(a, 2) + int(b, 2))[2:]","auto addBinary(auto a, auto b) {
    return bin(int(a, 2) + int(b, 2))[2:]
}"
670.py,"def maximumSwap(self, num):
        res, num = num, list(str(num))
        for i in range(len(num) - 1):
            for j in range(i + 1, len(num)):
                if int(num[j]) > int(num[i]):
                    tmp = int("""".join(num[:i] + [num[j]] + num[i + 1:j] + [num[i]] + num[j + 1:]))
                    if tmp > res: res = tmp
        return res","auto maximumSwap(auto num) {
    res, num = num, list(str(num))
    for i in range(len(num) - 1):
    for j in range(i + 1, len(num)):
    if int(num[j]) > int(num[i]):
    tmp = int("""".join(num[:i] + [num[j]] + num[i + 1:j] + [num[i]] + num[j + 1:]))
    if tmp > res: res = tmp
    return res
}"
672.py,"def flipLights(self, n, m):
        n = min(n, 3)
        return min(1 << n, 1 + m * n)","auto flipLights(auto n, auto m) {
    n = min(n, 3)
    return min(1 << n, 1 + m * n)
}"
673.py,"def findNumberOfLIS(self, nums):
        dp = [[1, 1] for _ in range(len(nums))]
        for i in range(len(nums) - 1):
            for j in range(i + 1, len(nums)):
                if nums[j] > nums[i]:
                    if dp[i][0] >= dp[j][0]: dp[j] = [dp[i][0] + 1, dp[i][1]]
                    elif dp[i][0] == dp[j][0] - 1: dp[j][1] += dp[i][1]
        dp.sort()
        return dp and sum(d[1] for d in dp if d[0] == dp[-1][0]) or 0","auto findNumberOfLIS(auto nums) {
    dp = [[1, 1] for _ in range(len(nums))]
    for i in range(len(nums) - 1):
    for j in range(i + 1, len(nums)):
    if nums[j] > nums[i]:
    if dp[i][0] >= dp[j][0]: dp[j] = [dp[i][0] + 1, dp[i][1]]
    elif dp[i][0] == dp[j][0] - 1: dp[j][1] += dp[i][1]
    dp.sort()
    return dp and sum(d[1] for d in dp if d[0] == dp[-1][0]) or 0
}"
674.py,"def findLengthOfLCIS(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        if nums==[]: return 0
        curr, mx=1, 1
        for i in range(len(nums)-1):
            if nums[i+1]>nums[i]: curr+=1; mx=max(mx,curr)
            else: curr=1
        return mx","auto findLengthOfLCIS(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: int
    """"""
    if nums==[]: return 0
    curr, mx=1, 1
    for i in range(len(nums)-1):
    if nums[i+1]>nums[i]: curr+=1; mx=max(mx,curr)
    else: curr=1
    return mx
}"
675.py,"def cutOffTree(self, forest):
        def hadlocks(forest, sr, sc, tr, tc):
            R, C = len(forest), len(forest[0])
            processed = set()
            deque = collections.deque([(0, sr, sc)])
            while deque:
                detours, r, c = deque.popleft()
                if (r, c) not in processed:
                    processed.add((r, c))
                    if r == tr and c == tc:
                        return abs(sr-tr) + abs(sc-tc) + 2*detours
                    for nr, nc, closer in ((r-1, c, r > tr), (r+1, c, r < tr),
                                           (r, c-1, c > tc), (r, c+1, c < tc)):
                        if 0 <= nr < R and 0 <= nc < C and forest[nr][nc]:
                            if closer:
                                deque.appendleft((detours, nr, nc))
                            else:
                                deque.append((detours+1, nr, nc))
            return -1
        trees = sorted((v, r, c) for r, row in enumerate(forest)
                       for c, v in enumerate(row) if v > 1)
        sr = sc = ans = 0
        for _, tr, tc in trees:
            d = hadlocks(forest, sr, sc, tr, tc)
            if d < 0: return -1
            ans += d
            sr, sc = tr, tc
        return ans","auto cutOffTree(auto forest) {
    def hadlocks(forest, sr, sc, tr, tc):
    R, C = len(forest), len(forest[0])
    processed = set()
    deque = collections.deque([(0, sr, sc)])
    while deque:
    detours, r, c = deque.popleft()
    if (r, c) not in processed:
    processed.add((r, c))
    if r == tr and c == tc:
    return abs(sr-tr) + abs(sc-tc) + 2*detours
    for nr, nc, closer in ((r-1, c, r > tr), (r+1, c, r < tr),
    (r, c-1, c > tc), (r, c+1, c < tc)):
    if 0 <= nr < R and 0 <= nc < C and forest[nr][nc]:
    if closer:
    deque.appendleft((detours, nr, nc))
    else:
    deque.append((detours+1, nr, nc))
    return -1
    trees = sorted((v, r, c) for r, row in enumerate(forest)
    for c, v in enumerate(row) if v > 1)
    sr = sc = ans = 0
    for _, tr, tc in trees:
    d = hadlocks(forest, sr, sc, tr, tc)
    if d < 0: return -1
    ans += d
    sr, sc = tr, tc
    return ans
}"
678.py,"def checkValidString(self, s):
        """"""
        :type s: str
        :rtype: bool
        """"""
        left, left_star = [], []
        for i in range(len(s)):
            if s[i] == ""("": left.append([s[i], i])
            elif s[i] == ""*"": left_star.append([s[i], i])
            elif left and left[-1][0] == ""("": left.pop()
            elif left_star: left_star.pop()
            else: return False
        while left and left_star and left[-1][1]< left_star[-1][1]: left.pop(); left_star.pop()
        return not left   ","auto checkValidString(auto s) {
    """"""
    :type s: str
    :rtype: bool
    """"""
    left, left_star = [], []
    for i in range(len(s)):
    if s[i] == ""("": left.append([s[i], i])
    elif s[i] == ""*"": left_star.append([s[i], i])
    elif left and left[-1][0] == ""("": left.pop()
    elif left_star: left_star.pop()
    else: return False
    while left and left_star and left[-1][1]< left_star[-1][1]: left.pop(); left_star.pop()
    return not left
}"
679.py,"def judgePoint24(self, nums):
        q = [[None, nums[i]] + nums[:i] + nums[i + 1:] for i in range(len(nums))]
        while q:
            new = []
            for group1, group2, *rest in q:
                if not rest and group1:
                    for res in (group1 + group2, group1 - group2, group1 * group2, group2 and group1 / group2): 
                        if 23.999 <= res <= 24.0001: return True
                if not rest and not group1 and 23.999 <= group2 <= 24.0001: return True
                for i in range(len(rest)):
                    for newGroup2 in (group2 + rest[i], group2 - rest[i], rest[i] - group2, group2 * rest[i], group2 / rest[i]):
                        new.append([group1, newGroup2] + rest[:i] + rest[i + 1:])
                    if group2:
                        new.append([group1, rest[i] / group2] + rest[:i] + rest[i + 1:])
                    if group1 != None:
                        for newGroup1 in (group1 + group2, group1 - group2, group1 * group2):
                            new.append([newGroup1, rest[i]] + rest[:i] + rest[i + 1:])
                        if group2:
                            new.append([group1 / group2, rest[i]] + rest[:i] + rest[i + 1:])
                    else:
                        new.append([group2, rest[i]] + rest[:i] + rest[i + 1:])
            q = new
        return False","auto judgePoint24(auto nums) {
    q = [[None, nums[i]] + nums[:i] + nums[i + 1:] for i in range(len(nums))]
    while q:
    new = []
    for group1, group2, *rest in q:
    if not rest and group1:
    for res in (group1 + group2, group1 - group2, group1 * group2, group2 and group1 / group2):
    if 23.999 <= res <= 24.0001: return True
    if not rest and not group1 and 23.999 <= group2 <= 24.0001: return True
    for i in range(len(rest)):
    for newGroup2 in (group2 + rest[i], group2 - rest[i], rest[i] - group2, group2 * rest[i], group2 / rest[i]):
    new.append([group1, newGroup2] + rest[:i] + rest[i + 1:])
    if group2:
    new.append([group1, rest[i] / group2] + rest[:i] + rest[i + 1:])
    if group1 != None:
    for newGroup1 in (group1 + group2, group1 - group2, group1 * group2):
    new.append([newGroup1, rest[i]] + rest[:i] + rest[i + 1:])
    if group2:
    new.append([group1 / group2, rest[i]] + rest[:i] + rest[i + 1:])
    else:
    new.append([group2, rest[i]] + rest[:i] + rest[i + 1:])
    q = new
    return False
}"
68.py,"def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:
        res, used, s = [], 0, []
        for i, w in enumerate(words):
            if not s or len(w) + used + len(s) <= maxWidth:
                used += len(w)
                s += [w]
            else:
                if len(s) == 1:
                    res.append(s[0] + (maxWidth - used) * ' ')
                else:
                    br = (maxWidth - used) // (len(s) - 1)
                    res.append(''.join((br + (i <= (maxWidth - used) % (len(s) - 1))) * ' ' + c for i, c in enumerate(s)).lstrip())
                used, s = len(w), [w]
        return res + [' '.join(c for c in s) + (maxWidth - used - len(s) + 1) * ' ']","auto fullJustify(auto words, auto maxWidth) {
    res, used, s = [], 0, []
    for i, w in enumerate(words):
    if not s or len(w) + used + len(s) <= maxWidth:
    used += len(w)
    s += [w]
    else:
    if len(s) == 1:
    res.append(s[0] + (maxWidth - used) * ' ')
    else:
    br = (maxWidth - used) // (len(s) - 1)
    res.append(''.join((br + (i <= (maxWidth - used) % (len(s) - 1))) * ' ' + c for i, c in enumerate(s)).lstrip())
    used, s = len(w), [w]
    return res + [' '.join(c for c in s) + (maxWidth - used - len(s) + 1) * ' ']
}"
680.py,"def validPalindrome(self, s):
        """"""
        :type s: str
        :rtype: bool
        """"""
        memo = {}
        def dfs(l, r, cnt):
            if (l, r, cnt) in memo:
                return memo[(l, r, cnt)]
            if l >= r:
                return True
            elif s[l] != s[r]:
                cnt += 1
                if cnt > 1:
                    memo[(l, r, cnt)] = False
                    return False
                elif (s[l + 1] == s[r] and dfs(l + 1, r, cnt + 1)) or (s[l] == s[r - 1] and dfs(l, r - 1, cnt + 1)):
                    memo[(l, r, cnt)] = True
                    return True
                else:
                    memo[(l, r, cnt)] = False
                    return False
            else:
                memo[(l, r, cnt)] = dfs(l + 1, r - 1, cnt)
                return memo[(l, r, cnt)]
        return dfs(0, len(s) - 1, 0)","auto validPalindrome(auto s) {
    """"""
    :type s: str
    :rtype: bool
    """"""
    memo = {}
    def dfs(l, r, cnt):
    if (l, r, cnt) in memo:
    return memo[(l, r, cnt)]
    if l >= r:
    return True
    elif s[l] != s[r]:
    cnt += 1
    if cnt > 1:
    memo[(l, r, cnt)] = False
    return False
    elif (s[l + 1] == s[r] and dfs(l + 1, r, cnt + 1)) or (s[l] == s[r - 1] and dfs(l, r - 1, cnt + 1)):
    memo[(l, r, cnt)] = True
    return True
    else:
    memo[(l, r, cnt)] = False
    return False
    else:
    memo[(l, r, cnt)] = dfs(l + 1, r - 1, cnt)
    return memo[(l, r, cnt)]
    return dfs(0, len(s) - 1, 0)
}"
681.py,"def nextClosestTime(self, time):
        t = sorted(set(time))[:-1]  
        nex = {a: b for a, b in zip(t, t[1:])}
        for i, d in enumerate(time[::-1]):
            if d in nex:
                if i == 0:
                    return time[:4] + nex[d]
                elif i == 1 and nex[d] < '6':
                    return time[:3] + nex[d] + t[0]
                elif i == 3 and int(time[0] + nex[d]) < 24:
                    return time[0] + nex[d] + ':' + t[0] * 2
        return t[0] * 2 + ':' + t[0] * 2","auto nextClosestTime(auto time) {
    t = sorted(set(time))[:-1]
    nex = {a: b for a, b in zip(t, t[1:])}
    for i, d in enumerate(time[::-1]):
    if d in nex:
    if i == 0:
    return time[:4] + nex[d]
    elif i == 1 and nex[d] < '6':
    return time[:3] + nex[d] + t[0]
    elif i == 3 and int(time[0] + nex[d]) < 24:
    return time[0] + nex[d] + ':' + t[0] * 2
    return t[0] * 2 + ':' + t[0] * 2
}"
682.py,"def calPoints(self, ops: List[str]) -> int:
        arr = []
        for op in ops:
            #print(arr)
            if op.isdigit() or op[0] == '-':
                arr.append(int(op))
            elif op == 'C' and arr:
                arr.pop()
            elif op == 'D' and arr:
                arr.append(arr[-1] * 2)
            elif len(arr) >= 2:
                arr.append(arr[-1] + arr[-2])
        #print(arr)
        return sum(arr)","auto calPoints(auto ops) {
    arr = []
    for op in ops:
    #print(arr)
    if op.isdigit() or op[0] == '-':
    arr.append(int(op))
    elif op == 'C' and arr:
    arr.pop()
    elif op == 'D' and arr:
    arr.append(arr[-1] * 2)
    elif len(arr) >= 2:
    arr.append(arr[-1] + arr[-2])
    #print(arr)
    return sum(arr)
}"
684.py,"def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
      parent = [0] * len(edges)

      def find(x):
        if parent[x] == 0:
          return x
        parent[x] = find(parent[x])
        return parent[x]

      def union(x, y):
        rootX = find(x)
        rootY = find(y)
        if rootX == rootY:
          return False
        parent[rootX] = rootY
        return True
      
      res = [0, 0]
      for x, y in edges:
        if not union(x - 1, y - 1): 
          res =  [x, y]
      return res","auto findRedundantConnection(auto edges) {
    parent = [0] * len(edges)
    
    def find(x):
    if parent[x] == 0:
    return x
    parent[x] = find(parent[x])
    return parent[x]
    
    def union(x, y):
    rootX = find(x)
    rootY = find(y)
    if rootX == rootY:
    return false
    parent[rootX] = rootY
    return true
    
    res = [0, 0]
    for x, y in edges:
    if not union(x - 1, y - 1):
    res =  [x, y]
    return res
}"
685.py,"def findRedundantDirectedConnection(self, edges):
        def root(i):
            return parent[i] == i and i or root(parent[i])
        
        parent, a, b, c = [0] * (len(edges) + 1), None, None, None
        for i, edge in enumerate(edges):
            if parent[edge[1]]:
                a, b, c, edges[i][0]= parent[edge[1]], edge[0], edge[1], 0
            else:
                parent[edge[1]] = edge[0]
        
        parent = [i for i in range(len(edges) + 1)]
        for u, v in edges:
            if u:
                if root(u) == v: 
                    return a and [a, c] or [u, v]
                parent[v] = u   
        return [b, c]","auto findRedundantDirectedConnection(auto edges) {
    def root(i):
    return parent[i] == i and i or root(parent[i])
    
    parent, a, b, c = [0] * (len(edges) + 1), None, None, None
    for i, edge in enumerate(edges):
    if parent[edge[1]]:
    a, b, c, edges[i][0]= parent[edge[1]], edge[0], edge[1], 0
    else:
    parent[edge[1]] = edge[0]
    
    parent = [i for i in range(len(edges) + 1)]
    for u, v in edges:
    if u:
    if root(u) == v:
    return a and [a, c] or [u, v]
    parent[v] = u
    return [b, c]
}"
686.py,"def repeatedStringMatch(self, A: str, B: str) -> int:
        for i in range(1,2+len(B)//len(A)+1):
            if B in A*i: return i 
        return -1","auto repeatedStringMatch(auto A, auto B) {
    for i in range(1,2+len(B)//len(A)+1):
    if B in A*i: return i
    return -1
}"
688.py,"def knightProbability(self, N, K, r, c):
        memo = {}
        def dfs(i, j, p, k): 
            if 0 <= i < N and 0 <= j < N and k < K:
                sm = 0
                for x, y in ((-1, -2), (-2, -1), (-2, 1), (-1, 2), (1, 2), (2, 1), (2, -1), (1, -2)):
                    if (i + x, j + y, k) not in memo:
                        memo[(i + x, j + y, k)] = dfs(i + x, j + y, p / 8, k + 1)
                    sm += memo[(i + x, j + y, k)]
                return sm
            else:
                return 0 <= i < N and 0 <= j < N and p or 0
        return dfs(r, c, 1, 0)","auto knightProbability(auto N, auto K, auto r, auto c) {
    memo = {}
    def dfs(i, j, p, k):
    if 0 <= i < N and 0 <= j < N and k < K:
    sm = 0
    for x, y in ((-1, -2), (-2, -1), (-2, 1), (-1, 2), (1, 2), (2, 1), (2, -1), (1, -2)):
    if (i + x, j + y, k) not in memo:
    memo[(i + x, j + y, k)] = dfs(i + x, j + y, p / 8, k + 1)
    sm += memo[(i + x, j + y, k)]
    return sm
    else:
    return 0 <= i < N and 0 <= j < N and p or 0
    return dfs(r, c, 1, 0)
}"
689.py,"def maxSumOfThreeSubarrays(self, nums, k):
        single, double, sm, n, cur = {}, {}, 0, len(nums), sum(nums[:k - 1])
        for i in range(k - 1, n):
            cur += nums[i]
            single[i - k + 1] = cur
            cur -= nums[i - k + 1]
        cur = n - k, single[n - k]
        for i in range(n - k, k * 2 - 1, -1):
            if single[i] >= cur[1]:
                cur = i, single[i]
            double[i - k] = cur[1] + single[i - k], i - k, cur[0]
        cur = double[n - 2 * k]
        for i in range(n - 2 * k, k - 1, -1):
            if double[i][0] >= cur[0]:
                cur = double[i]
            if single[i - k] + cur[0] >= sm:
                sm, res = single[i - k] + cur[0], [i - k, cur[1], cur[2]]
        return res","auto maxSumOfThreeSubarrays(auto nums, auto k) {
    single, double, sm, n, cur = {}, {}, 0, len(nums), sum(nums[:k - 1])
    for i in range(k - 1, n):
    cur += nums[i]
    single[i - k + 1] = cur
    cur -= nums[i - k + 1]
    cur = n - k, single[n - k]
    for i in range(n - k, k * 2 - 1, -1):
    if single[i] >= cur[1]:
    cur = i, single[i]
    double[i - k] = cur[1] + single[i - k], i - k, cur[0]
    cur = double[n - 2 * k]
    for i in range(n - 2 * k, k - 1, -1):
    if double[i][0] >= cur[0]:
    cur = double[i]
    if single[i - k] + cur[0] >= sm:
    sm, res = single[i - k] + cur[0], [i - k, cur[1], cur[2]]
    return res
}"
69.py,"def mySqrt(self, x: int) -> int:
        l, r = 0, x
        while l <= r:
            mid = (l + r) // 2
            if mid * mid <= x:
                l = mid + 1
            else:
                r = mid - 1
        return l - 1","auto mySqrt(auto x) {
    l, r = 0, x
    while l <= r:
    mid = (l + r) // 2
    if mid * mid <= x:
    l = mid + 1
    else:
    r = mid - 1
    return l - 1
}"
691.py,"def minStickers(self, stickers, target):
        cnt, res, n = collections.Counter(target), [float(""inf"")], len(target)  
        def dfs(dic, used, i):
            if i == n:
                res[0] = min(res[0], used)
            elif dic[target[i]] >= cnt[target[i]]:
                dfs(dic, used, i + 1)
            elif used < res[0] - 1:
                for sticker in stickers:
                    if target[i] in sticker:
                        for s in sticker:
                            dic[s] += 1
                        dfs(dic, used + 1, i + 1)
                        for s in sticker:
                            dic[s] -= 1
        dfs(collections.defaultdict(int), 0, 0)
        return res[0] < float(""inf"") and res[0] or -1","auto minStickers(auto stickers, auto target) {
    cnt, res, n = collections.Counter(target), [float(""inf"")], len(target)
    def dfs(dic, used, i):
    if i == n:
    res[0] = min(res[0], used)
    elif dic[target[i]] >= cnt[target[i]]:
    dfs(dic, used, i + 1)
    elif used < res[0] - 1:
    for sticker in stickers:
    if target[i] in sticker:
    for s in sticker:
    dic[s] += 1
    dfs(dic, used + 1, i + 1)
    for s in sticker:
    dic[s] -= 1
    dfs(collections.defaultdict(int), 0, 0)
    return res[0] < float(""inf"") and res[0] or -1
}"
692.py,"def topKFrequent(self, words, k):
        return [w for w, v in sorted(collections.Counter(words).items(), key = lambda x: (-x[1], x[0])) [:k]]","auto topKFrequent(auto words, auto k) {
    return [w for w, v in sorted(collections.Counter(words).items(), key = lambda x: (-x[1], x[0])) [:k]]
}"
693.py,"def hasAlternatingBits(self, n: int) -> bool:
        return all(a != b for a, b in zip(bin(n)[2:], bin(n)[3:]))
            ","auto hasAlternatingBits(auto n) {
    return all(a != b for a, b in zip(bin(n)[2:], bin(n)[3:]))
}"
694.py,"def numDistinctIslands(self, grid):
        visited, pattern, m, n = set(), collections.defaultdict(str), len(grid), len(grid[0])
        def dfs(ri, rj, i, j, pi, pj):
            visited.add((i, j))
            pattern[(ri, rj)] += str(pi) + str(pj)
            for x, y in ((-1, 0), (1, 0), (0, -1), (0, 1)):
                if 0 <= i + x < m and 0 <= j + y < n and grid[i + x][j + y] and (i + x, j + y) not in visited:
                    dfs(ri, rj, i + x, j + y, pi + x, pj + y)
        
        for i in range(m):
            for j in range(n):
                if grid[i][j] and (i, j) not in visited:
                    dfs(i, j, i, j, 0, 0)
        return len(set(pattern.values()))","auto numDistinctIslands(auto grid) {
    visited, pattern, m, n = set(), collections.defaultdict(str), len(grid), len(grid[0])
    def dfs(ri, rj, i, j, pi, pj):
    visited.add((i, j))
    pattern[(ri, rj)] += str(pi) + str(pj)
    for x, y in ((-1, 0), (1, 0), (0, -1), (0, 1)):
    if 0 <= i + x < m and 0 <= j + y < n and grid[i + x][j + y] and (i + x, j + y) not in visited:
    dfs(ri, rj, i + x, j + y, pi + x, pj + y)
    
    for i in range(m):
    for j in range(n):
    if grid[i][j] and (i, j) not in visited:
    dfs(i, j, i, j, 0, 0)
    return len(set(pattern.values()))
}"
695.py,"def maxAreaOfIsland(self, grid):
        m, n = len(grid), len(grid and grid[0])
        def explore(i, j):
            grid[i][j] = 0
            return 1 + sum(explore(x,y) for x,y in ((i-1,j),(i+1,j),(i,j-1),(i,j+1)) if 0<=x<m and 0<=y<n and grid[x][y])
        return max(grid[i][j] and explore(i, j) or 0 for i in range(m) for j in range(n))","auto maxAreaOfIsland(auto grid) {
    m, n = len(grid), len(grid and grid[0])
    def explore(i, j):
    grid[i][j] = 0
    return 1 + sum(explore(x,y) for x,y in ((i-1,j),(i+1,j),(i,j-1),(i,j+1)) if 0<=x<m and 0<=y<n and grid[x][y])
    return max(grid[i][j] and explore(i, j) or 0 for i in range(m) for j in range(n))
}"
696.py,"def countBinarySubstrings(self, s):
        s = s.replace(""01"", ""0#1"").replace(""10"", ""1#0"").split(""#"")
        return sum(min(len(s[i]), len(s[i - 1])) for i in range(1, len(s)))","auto countBinarySubstrings(auto s) {
    s = s.replace(""01"", ""0#1"").replace(""10"", ""1#0"").split(""#"")
    return sum(min(len(s[i]), len(s[i - 1])) for i in range(1, len(s)))
}"
697.py,"def findShortestSubArray(self, nums):
        cnt, seen = collections.Counter(nums), collections.defaultdict(list)
        degree = max(cnt.values())
        for i, v in enumerate(nums): seen[v].append(i)
        return min(seen[v][-1] - seen[v][0] + 1 for v in cnt if cnt[v] == degree)","auto findShortestSubArray(auto nums) {
    cnt, seen = collections.Counter(nums), collections.defaultdict(list)
    degree = max(cnt.values())
    for i, v in enumerate(nums): seen[v].append(i)
    return min(seen[v][-1] - seen[v][0] + 1 for v in cnt if cnt[v] == degree)
}"
698.py,"def canPartitionKSubsets(self, nums, k):
        def dfs(i, sums):
            if i == n:
                return True
            for j in range(k):
                if sums[j] + nums[i] <= target:
                    sums[j] += nums[i]
                    if dfs(i + 1, sums):
                        return True
                    sums[j] -= nums[i]
            return False
        nums.sort(reverse = True)
        sm = sum(nums)
        if sm % k: return False
        target, n = sm // k, len(nums)
        return dfs(0, [0] * k)","auto canPartitionKSubsets(auto nums, auto k) {
    def dfs(i, sums):
    if i == n:
    return True
    for j in range(k):
    if sums[j] + nums[i] <= target:
    sums[j] += nums[i]
    if dfs(i + 1, sums):
    return True
    sums[j] -= nums[i]
    return False
    nums.sort(reverse = True)
    sm = sum(nums)
    if sm % k: return False
    target, n = sm // k, len(nums)
    return dfs(0, [0] * k)
}"
699.py,"def fallingSquares(self, positions: List[List[int]]) -> List[int]:
        height = [0]
        pos = [0]
        res = []
        max_h = 0
        for left, side in positions:
            i = bisect.bisect_right(pos, left)
            j = bisect.bisect_left(pos, left + side)
            high = max(height[i - 1:j] or [0]) + side
            pos[i:j] = [left, left + side]
            height[i:j] = [high, height[j - 1]]
            max_h = max(max_h, high)
            res.append(max_h)
        return res","auto fallingSquares(auto positions) {
    height = [0]
    pos = [0]
    res = []
    max_h = 0
    for left, side in positions:
    i = bisect.bisect_right(pos, left)
    j = bisect.bisect_left(pos, left + side)
    high = max(height[i - 1:j] or [0]) + side
    pos[i:j] = [left, left + side]
    height[i:j] = [high, height[j - 1]]
    max_h = max(max_h, high)
    res.append(max_h)
    return res
}"
7.py,"def reverse(self, x):
        x = int(str(x)[::-1]) if x >= 0 else int(""-"" + str(x)[::-1][:-1]); return -2 ** 31 <= x <= 2 ** 31 - 1 and x or 0","auto reverse(auto x) {
    x = int(str(x)[::-1]) if x >= 0 else int(""-"" + str(x)[::-1][:-1]); return -2 ** 31 <= x <= 2 ** 31 - 1 and x or 0
}"
70.py,"def climbStairs(self, n: int) -> int:
        memo = {}
        def dfs(i):
            if i >= n: return 1 if i == n else 0
            if i not in memo:
                memo[i] = dfs(i + 1) + dfs(i + 2)
            return memo[i]
        return dfs(0)","auto climbStairs(auto n) {
    memo = {}
    def dfs(i):
    if i >= n: return 1 if i == n else 0
    if i not in memo:
    memo[i] = dfs(i + 1) + dfs(i + 2)
    return memo[i]
    return dfs(0)
}"
700.py,"def searchBST(self, root, val):
        if root and val < root.val: return self.searchBST(root.left, val)
        elif root and val > root.val: return self.searchBST(root.right, val)
        return root","auto searchBST(auto root, auto val) {
    if root and val < root.val: return self.searchBST(root.left, val)
    elif root and val > root.val: return self.searchBST(root.right, val)
    return root
}"
701.py,"def insertIntoBST(self, root, val):
        if root and root.val > val and not self.insertIntoBST(root.left, val): root.left = TreeNode(val)
        elif root and root.val < val and not self.insertIntoBST(root.right, val): root.right = TreeNode(val)
        return root","auto insertIntoBST(auto root, auto val) {
    if root and root.val > val and not self.insertIntoBST(root.left, val): root.left = TreeNode(val)
    elif root and root.val < val and not self.insertIntoBST(root.right, val): root.right = TreeNode(val)
    return root
}"
704.py,"def search(self, nums: List[int], target: int) -> int:
        return bisect.bisect_left(nums, target) if target in nums else -1","auto search(auto nums, auto target) {
    return bisect.bisect_left(nums, target) if target in nums else -1
}"
709.py,"def toLowerCase(self, str): 
        return """".join(chr(ord(c) + 32) if 65 <= ord(c) <= 90 else c for c in str)","auto toLowerCase(auto str) {
    return """".join(chr(ord(c) + 32) if 65 <= ord(c) <= 90 else c for c in str)
}"
71.py,"def simplifyPath(self, path):
        stack = [] 
        for c in path.split(""/""):
            stack = stack[:-1] if c== "".."" else stack + [c] if c and c != ""."" else stack
        return ""/"" + ""/"".join(stack)","auto simplifyPath(auto path) {
    stack = []
    for c in path.split(""/""):
    stack = stack[:-1] if c== "".."" else stack + [c] if c and c != ""."" else stack
    return ""/"" + ""/"".join(stack)
}"
710.py,"def __init__(self, N, blacklist):
        self.forbidden, self.n, self.used, self.cur = set(blacklist), N, set(), 0
    def pick(self):
        while self.cur in self.forbidden: self.cur += 1
        if self.cur < self.n: num, self.cur = self.cur, self.cur + 1
        else: num = self.used.pop()
        self.used.add(num)
        return num","auto __init__(auto N, auto blacklist) {
    self.forbidden, self.n, self.used, self.cur = set(blacklist), N, set(), 0
    def pick(self):
    while self.cur in self.forbidden: self.cur += 1
    if self.cur < self.n: num, self.cur = self.cur, self.cur + 1
    else: num = self.used.pop()
    self.used.add(num)
    return num
}"
711.py,"def numDistinctIslands2(self, grid: List[List[int]]) -> int:
        if not grid or not grid[0]: return 0
        m,n=len(grid),len(grid[0])

        # augment matrix to void length check
        grid.append([0]*n)
        for row in grid: row.append(0)

        self.pool=set()
        self.res=0

        def bfs(i0,j0):
            grid[i0][j0]=-1
            q=[(i0,j0)]
            for i,j in q:
                for I,J in (i-1,j),(i+1,j),(i,j-1),(i,j+1):
                    if grid[I][J]==1:
                        grid[I][J]=-1
                        q.append([I,J])
            self.addisland(q)
       
        for i in range(m):
            for j in range(n):
                if grid[i][j]==1: bfs(i,j)

        return self.res

    def addisland(self,q):
            Imin=min(x for x,y in q)
            Jmin=min(y for x,y in q)
            island1=tuple(sorted((x-Imin,y-Jmin) for x,y in q)) # original island
           
            if island1 in self.pool: return None
            self.res+=1

            Imax=max(x for x,y in island1)
            Jmax=max(y for x,y in island1)

            island2=tuple(sorted((-x+Imax,y) for x,y in island1)) # x axis mirror
            island3=tuple(sorted((x,-y+Jmax) for x,y in island1)) # y axis mirror
            island4=tuple(sorted((-x+Imax,-y+Jmax) for x,y in island1)) # origin mirror

            island5=tuple(sorted((y,x) for x,y in island1)) # diagonal mirror
            island6=tuple(sorted((-x+Jmax,y) for x,y in island5))
            island7=tuple(sorted((x,-y+Imax) for x,y in island5))
            island8=tuple(sorted((-x+Jmax,-y+Imax) for x,y in island5))

            self.pool |= set([island1,island2,island3,island4,island5,island6,island7,island8])","auto numDistinctIslands2(auto grid) {
    if not grid or not grid[0]: return 0
    m,n=len(grid),len(grid[0])
    
    # augment matrix to void length check
    grid.append([0]*n)
    for row in grid: row.append(0)
    
    self.pool=set()
    self.res=0
    
    def bfs(i0,j0):
    grid[i0][j0]=-1
    q=[(i0,j0)]
    for i,j in q:
    for I,J in (i-1,j),(i+1,j),(i,j-1),(i,j+1):
    if grid[I][J]==1:
    grid[I][J]=-1
    q.append([I,J])
    self.addisland(q)
    
    for i in range(m):
    for j in range(n):
    if grid[i][j]==1: bfs(i,j)
    
    return self.res
    
    def addisland(self,q):
    Imin=min(x for x,y in q)
    Jmin=min(y for x,y in q)
    island1=tuple(sorted((x-Imin,y-Jmin) for x,y in q)) # original island
    
    if island1 in self.pool: return nullptr
    self.res+=1
    
    Imax=max(x for x,y in island1)
    Jmax=max(y for x,y in island1)
    
    island2=tuple(sorted((-x+Imax,y) for x,y in island1)) # x axis mirror
    island3=tuple(sorted((x,-y+Jmax) for x,y in island1)) # y axis mirror
    island4=tuple(sorted((-x+Imax,-y+Jmax) for x,y in island1)) # origin mirror
    
    island5=tuple(sorted((y,x) for x,y in island1)) # diagonal mirror
    island6=tuple(sorted((-x+Jmax,y) for x,y in island5))
    island7=tuple(sorted((x,-y+Imax) for x,y in island5))
    island8=tuple(sorted((-x+Jmax,-y+Imax) for x,y in island5))
    
    self.pool |= set([island1,island2,island3,island4,island5,island6,island7,island8])
}"
712.py,"def minimumDeleteSum(self, s1, s2):
        l1, l2 = len(s1) + 1, len(s2) + 1
        d = [[0] * l2 for i in range(l1)]
        for i in range(l1):
            for j in range(l2):
                c1, c2 = ord(s1[i - 1]), ord(s2[j - 1])
                if not i * j:
                    d[i][j] = d[i - 1][j] + c1 if i else d[i][j - 1] + c2 if j else 0
                elif s1[i - 1] == s2[j - 1]: 
                    d[i][j] = d[i - 1][j - 1]
                else: 
                    d[i][j] = min(d[i - 1][j] + c1, d[i][j - 1] + c2, d[i - 1][j - 1] + c1 + c2)
        return d[-1][-1]","auto minimumDeleteSum(auto s1, auto s2) {
    l1, l2 = len(s1) + 1, len(s2) + 1
    d = [[0] * l2 for i in range(l1)]
    for i in range(l1):
    for j in range(l2):
    c1, c2 = ord(s1[i - 1]), ord(s2[j - 1])
    if not i * j:
    d[i][j] = d[i - 1][j] + c1 if i else d[i][j - 1] + c2 if j else 0
    elif s1[i - 1] == s2[j - 1]:
    d[i][j] = d[i - 1][j - 1]
    else:
    d[i][j] = min(d[i - 1][j] + c1, d[i][j - 1] + c2, d[i - 1][j - 1] + c1 + c2)
    return d[-1][-1]
}"
713.py,"def numSubarrayProductLessThanK(self, nums, k):
        l, res, cur = 0, 0, 1
        for i in range(len(nums)):
            cur *= nums[i]
            while cur >= k and l < i: l, cur = l + 1, cur // nums[l]
            if cur < k: res += i - l + 1
        return res","auto numSubarrayProductLessThanK(auto nums, auto k) {
    l, res, cur = 0, 0, 1
    for i in range(len(nums)):
    cur *= nums[i]
    while cur >= k and l < i: l, cur = l + 1, cur // nums[l]
    if cur < k: res += i - l + 1
    return res
}"
714.py,"def maxProfit(self, prices, fee):
        pre = [0, -float(""inf"")]
        for p in prices:
            p0, p1 = pre[1] + p - fee, pre[0] - p
            if p0 > pre[0]: pre[0] = p0
            if p1 > pre[1]: pre[1] = p1
        return pre[0]","auto maxProfit(auto prices, auto fee) {
    pre = [0, -float(""inf"")]
    for p in prices:
    p0, p1 = pre[1] + p - fee, pre[0] - p
    if p0 > pre[0]: pre[0] = p0
    if p1 > pre[1]: pre[1] = p1
    return pre[0]
}"
717.py,"def isOneBitCharacter(self, bits):
        """"""
        :type bits: List[int]
        :rtype: bool
        """"""
        while bits:
            last=bits.pop(0)
            if last==1:bits.pop(0)
        return True if last==0 else False","auto isOneBitCharacter(auto bits) {
    """"""
    :type bits: List[int]
    :rtype: bool
    """"""
    while bits:
    last=bits.pop(0)
    if last==1:bits.pop(0)
    return True if last==0 else False
}"
718.py,"def findLength(self, A, B):
        A, res, sub = ""X%sX"" % ""X"".join(map(str, A)), 0, ""X""
        for num in B:
            sub += str(num) + ""X""
            if sub in A: res += 1
            else: sub = sub[sub[1:].index(""X"") + 1:]
        return res","auto findLength(auto A, auto B) {
    A, res, sub = ""X%sX"" % ""X"".join(map(str, A)), 0, ""X""
    for num in B:
    sub += str(num) + ""X""
    if sub in A: res += 1
    else: sub = sub[sub[1:].index(""X"") + 1:]
    return res
}"
72.py,"def minDistance(self, w1: str, w2: str) -> int:
        dp = [[0] * (len(w2) + 1) for i in range(len(w1) + 1)]
        for i in range(len(w1) + 1):
            for j in range(len(w2) + 1):
                if not (i and j):
                    dp[i][j] = i or j
                elif w1[i - 1] == w2[j - 1]:
                    dp[i][j] += dp[i - 1][j - 1]
                else:
                    dp[i][j] += min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
        return dp[-1][-1]","auto minDistance(auto w1, auto w2) {
    dp = [[0] * (len(w2) + 1) for i in range(len(w1) + 1)]
    for i in range(len(w1) + 1):
    for j in range(len(w2) + 1):
    if not (i and j):
    dp[i][j] = i or j
    elif w1[i - 1] == w2[j - 1]:
    dp[i][j] += dp[i - 1][j - 1]
    else:
    dp[i][j] += min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
    return dp[-1][-1]
}"
720.py,"def longestWord(self, words):
        """"""
        :type words: List[str]
        :rtype: str
        """"""
        for w in sorted(words, key = lambda x: (-len(x), x)):
            if all([True if w[:i] in set(words) - {w} else False for i in range(1, len(w))]): return w  
        return """"","auto longestWord(auto words) {
    """"""
    :type words: List[str]
    :rtype: str
    """"""
    for w in sorted(words, key = lambda x: (-len(x), x)):
    if all([True if w[:i] in set(words) - {w} else False for i in range(1, len(w))]): return w
    return """"
}"
721.py,"def accountsMerge(self, accounts):
        def explore(mail, q):
            q += mail,
            visited.add(mail)
            for v in edges[mail]:
                if v not in visited: explore(v, q)
            return q
        edges, owner, visited, res = collections.defaultdict(list), {}, set(), []
        for acc in accounts:
            owner[acc[1]] = acc[0]
            for i in range(1, len(acc) - 1): 
                if acc[i] != acc[i + 1]:
                    edges[acc[i]] += acc[i + 1],
                    edges[acc[i + 1]] += acc[i],
        for acc in accounts:
            if acc[1] not in visited: res += [acc[0]] + sorted(explore(acc[1], [])),
        return res","auto accountsMerge(auto accounts) {
    def explore(mail, q):
    q += mail,
    visited.add(mail)
    for v in edges[mail]:
    if v not in visited: explore(v, q)
    return q
    edges, owner, visited, res = collections.defaultdict(list), {}, set(), []
    for acc in accounts:
    owner[acc[1]] = acc[0]
    for i in range(1, len(acc) - 1):
    if acc[i] != acc[i + 1]:
    edges[acc[i]] += acc[i + 1],
    edges[acc[i + 1]] += acc[i],
    for acc in accounts:
    if acc[1] not in visited: res += [acc[0]] + sorted(explore(acc[1], [])),
    return res
}"
722.py,"def removeComments(self, source):
        res, block, cont, blockStart = [], False, False, -1
        for line in source:
            if not cont: cache = """"
            for i, c in enumerate(line):
                if not block: cache += c
                if cache[-2:] == ""//"":
                    cache = cache[:-2]
                    break
                elif cache[-2:] == ""/*"": blockStart, cache, block = i, cache[:-2], True
                elif line[i - 1:i + 1] == ""*/"" and blockStart < i - 1: block = False
            if not block:
                if cache: res += cache,
                cont = False
            else: cont, blockStart = True, -1
        return res","auto removeComments(auto source) {
    res, block, cont, blockStart = [], False, False, -1
    for line in source:
    if not cont: cache = """"
    for i, c in enumerate(line):
    if not block: cache += c
    if cache[-2:] == ""//"":
    cache = cache[:-2]
    break
    elif cache[-2:] == ""/*"": blockStart, cache, block = i, cache[:-2], True
    elif line[i - 1:i + 1] == ""*/"" and blockStart < i - 1: block = False
    if not block:
    if cache: res += cache,
    cont = False
    else: cont, blockStart = True, -1
    return res
}"
723.py,"def candyCrush(self, board):
        m, n = len(board), len(board[0])
        def gravity():
            for j in range(n):
                stack = [board[i][j] for i in range(m - 1, -1, -1) if board[i][j] > 0]
                stack += [0] *  (m - len(stack))
                for i in range(m): board[i][j] = stack.pop()
        def crush():
            crush = False
            for i in range(m):
                for j in range(n):
                    if j > 1 and board[i][j] > 0 and board[i][j] == abs(board[i][j - 1]) == abs(board[i][j - 2]):
                        board[i][j - 2:j + 1] = [-abs(board[i][j]) for _ in range(3)]
                        crush = True
                    if i > 1 and board[i][j] != 0 and abs(board[i][j]) == abs(board[i - 1][j]) == abs(board[i - 2][j]):
                        if board[i][j] > 0: board[i][j] *= -1
                        if board[i - 1][j] > 0: board[i - 1][j] *= -1
                        if board[i - 2][j] > 0: board[i - 2][j] *= -1
                        crush = True
            return crush  
        while crush(): gravity()
        return board","auto candyCrush(auto board) {
    m, n = len(board), len(board[0])
    def gravity():
    for j in range(n):
    stack = [board[i][j] for i in range(m - 1, -1, -1) if board[i][j] > 0]
    stack += [0] *  (m - len(stack))
    for i in range(m): board[i][j] = stack.pop()
    def crush():
    crush = False
    for i in range(m):
    for j in range(n):
    if j > 1 and board[i][j] > 0 and board[i][j] == abs(board[i][j - 1]) == abs(board[i][j - 2]):
    board[i][j - 2:j + 1] = [-abs(board[i][j]) for _ in range(3)]
    crush = True
    if i > 1 and board[i][j] != 0 and abs(board[i][j]) == abs(board[i - 1][j]) == abs(board[i - 2][j]):
    if board[i][j] > 0: board[i][j] *= -1
    if board[i - 1][j] > 0: board[i - 1][j] *= -1
    if board[i - 2][j] > 0: board[i - 2][j] *= -1
    crush = True
    return crush
    while crush(): gravity()
    return board
}"
724.py,"def pivotIndex(self, nums: List[int]) -> int:
        sm = sum(nums)
        cur = 0
        for i in range(len(nums)):
            if cur == sm - cur - nums[i]:
                return i
            cur += nums[i]
        return -1","auto pivotIndex(auto nums) {
    sm = sum(nums)
    cur = 0
    for i in range(len(nums)):
    if cur == sm - cur - nums[i]:
    return i
    cur += nums[i]
    return -1
}"
725.py,"def splitListToParts(self, root: ListNode, k: int) -> List[ListNode]:
        n = 0
        node = root
        while node:
            n += 1
            node = node.next
        count = n // k
        residual = n % k

        i = 0
        ret = [[] for _ in range(k)]
        prev = root
        while prev and k > 0:
            node = prev
            leftover = count
            ret[i] = node
            i += 1
            while node and leftover > 1:
                node = node.next
                leftover -= 1
            if node and count != 0 and residual:
                node = node.next
                residual -= 1
            prev = node.next if node else None
            if node:
                node.next = None
            k -= 1
        return ret
","auto splitListToParts(auto root, auto k) {
    n = 0
    node = root
    while node:
    n += 1
    node = node.next
    count = n // k
    residual = n % k
    
    i = 0
    ret = [[] for _ in range(k)]
    prev = root
    while prev and k > 0:
    node = prev
    leftover = count
    ret[i] = node
    i += 1
    while node and leftover > 1:
    node = node.next
    leftover -= 1
    if node and count != 0 and residual:
    node = node.next
    residual -= 1
    prev = node.next if node else nullptr
    if node:
    node.next = nullptr
    k -= 1
    return ret
}"
726.py,"def countOfAtoms(self, formula):
        dic, coeff, stack, elem, cnt, i = collections.defaultdict(int), 1, [], """", 0, 0  
        for c in formula[::-1]:
            if c.isdigit():
                cnt += int(c) * (10 ** i)
                i += 1
            elif c == "")"":
                stack.append(cnt)
                coeff *= cnt
                i = cnt = 0
            elif c == ""("":
                coeff //= stack.pop()
                i = cnt = 0
            elif c.isupper():
                elem += c
                dic[elem[::-1]] += (cnt or 1) * coeff
                elem = """"
                i = cnt = 0
            elif c.islower():
                elem += c
        return """".join(k + str(v > 1 and v or """") for k, v in sorted(dic.items()))","auto countOfAtoms(auto formula) {
    dic, coeff, stack, elem, cnt, i = collections.defaultdict(int), 1, [], """", 0, 0
    for c in formula[::-1]:
    if c.isdigit():
    cnt += int(c) * (10 ** i)
    i += 1
    elif c == "")"":
    stack.append(cnt)
    coeff *= cnt
    i = cnt = 0
    elif c == ""("":
    coeff //= stack.pop()
    i = cnt = 0
    elif c.isupper():
    elem += c
    dic[elem[::-1]] += (cnt or 1) * coeff
    elem = """"
    i = cnt = 0
    elif c.islower():
    elem += c
    return """".join(k + str(v > 1 and v or """") for k, v in sorted(dic.items()))
}"
727.py,"def minWindow(self, S: str, T: str) -> str:
        def dfs(i, j):
            if j == len(T): return i
            if (i, j) not in memo:
                ind = S.find(T[j], i + 1)
                memo[(i, j)] = float('inf') if ind == -1 else dfs(ind, j + 1)
            return memo[(i, j)]
            
        l, res, memo = float('inf'), '', {}
        for i, s in enumerate(S):
            if s == T[0]:
                j = dfs(i, 1)
                if j - i < l:
                    l, res = j - i, S[i:j + 1]
        return res","auto minWindow(auto S, auto T) {
    def dfs(i, j):
    if j == len(T): return i
    if (i, j) not in memo:
    ind = S.find(T[j], i + 1)
    memo[(i, j)] = float('inf') if ind == -1 else dfs(ind, j + 1)
    return memo[(i, j)]
    
    l, res, memo = float('inf'), '', {}
    for i, s in enumerate(S):
    if s == T[0]:
    j = dfs(i, 1)
    if j - i < l:
    l, res = j - i, S[i:j + 1]
    return res
}"
728.py,"def selfDividingNumbers(self, left, right):
        """"""
        :type left: int
        :type right: int
        :rtype: List[int]
        """"""
        return [num for num in range(left,right+1) if len([char for char in str(num) if int(char)!=0 and num%int(char)==0])==len(str(num)) ]","auto selfDividingNumbers(auto left, auto right) {
    """"""
    :type left: int
    :type right: int
    :rtype: List[int]
    """"""
    return [num for num in range(left,right+1) if len([char for char in str(num) if int(char)!=0 and num%int(char)==0])==len(str(num)) ]
}"
730.py,"def countPalindromicSubsequences(self, S):
        mod, memo = 10 ** 9 + 7, {}
        def dfs(i, j):
            if (i, j) not in memo:
                cnt = 0
                for x in ""abcd"":
                    try: l, r = S[i:j + 1].index(x) + i, S[i:j + 1].rindex(x) + i
                    except: continue  
                    cnt += l != r and dfs(l + 1, r - 1) + 2 or 1
                memo[(i, j)] = cnt % mod
            return memo[(i, j)]
        return dfs(0, len(S) - 1)","auto countPalindromicSubsequences(auto S) {
    mod, memo = 10 ** 9 + 7, {}
    def dfs(i, j):
    if (i, j) not in memo:
    cnt = 0
    for x in ""abcd"":
    try: l, r = S[i:j + 1].index(x) + i, S[i:j + 1].rindex(x) + i
    except: continue
    cnt += l != r and dfs(l + 1, r - 1) + 2 or 1
    memo[(i, j)] = cnt % mod
    return memo[(i, j)]
    return dfs(0, len(S) - 1)
}"
733.py,"def floodFill(self, image, sr, sc, newColor):
        old, m, n = image[sr][sc], len(image), len(image[0])
        if old != newColor: 
            q = collections.deque([(sr, sc)])
            while q:
                i, j = q.popleft()
                image[i][j] = newColor
                for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
                    if 0 <= x < m and 0 <= y < n and image[x][y] == old: 
                        q.append((x, y))
        return image","auto floodFill(auto image, auto sr, auto sc, auto newColor) {
    old, m, n = image[sr][sc], len(image), len(image[0])
    if old != newColor:
    q = collections.deque([(sr, sc)])
    while q:
    i, j = q.popleft()
    image[i][j] = newColor
    for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
    if 0 <= x < m and 0 <= y < n and image[x][y] == old:
    q.append((x, y))
    return image
}"
734.py,"def areSentencesSimilar(self, words1: List[str], words2: List[str], pairs: List[List[str]]) -> bool:
        sim = collections.defaultdict(set)
        for a, b in pairs:
            sim[a].add(b)
            sim[b].add(a)
        return len(words1) == len(words2) and all(w1 == w2 or w2 in sim[w1] for w1, w2 in zip(words1, words2))","auto areSentencesSimilar(auto words1, auto words2, auto pairs) {
    sim = collections.defaultdict(set)
    for a, b in pairs:
    sim[a].add(b)
    sim[b].add(a)
    return len(words1) == len(words2) and all(w1 == w2 or w2 in sim[w1] for w1, w2 in zip(words1, words2))
}"
735.py,"def asteroidCollision(self, asteroids):
        """"""
        :type asteroids: List[int]
        :rtype: List[int]
        """"""
        stack = []
        for asteroid in asteroids:
            stack.append(asteroid)
            while len(stack) > 1 and stack[-2] > 0 and stack[-1] < 0:
                if stack[-2] < abs(stack[-1]): stack[-2] = stack[-1]
                elif stack[-2] == abs(stack[-1]): stack.pop()
                stack.pop()
        return stack            ","auto asteroidCollision(auto asteroids) {
    """"""
    :type asteroids: List[int]
    :rtype: List[int]
    """"""
    stack = []
    for asteroid in asteroids:
    stack.append(asteroid)
    while len(stack) > 1 and stack[-2] > 0 and stack[-1] < 0:
    if stack[-2] < abs(stack[-1]): stack[-2] = stack[-1]
    elif stack[-2] == abs(stack[-1]): stack.pop()
    stack.pop()
    return stack
}"
736.py,"def evaluate(self, expression):
        scopes, items = [{}], [[""root""]]
        for item in expression.replace("")"", "" )"").split():
            if item[0] == ""("":
                items.append([item[1:]])
                if item[1:] == ""let"":
                    scopes.append(dict(scopes[-1]))
                continue
            elif item == "")"": 
                if items[-1][0] == ""add"":
                    item = str(int(items[-1][1]) + int(items[-1][-1]))
                elif items[-1][0] == ""mult"":
                    item = str(int(items[-1][1]) * int(items[-1][-1]))
                else:
                    item = items[-1][-1]
                    if item in scopes[-1]:
                        item = scopes[-1][item]
                    scopes.pop()
                items.pop()
            if item in scopes[-1] and (items[-1][0] != ""let"" or len(items[-1]) % 2 == 0):
                item = scopes[-1][item]
            if items[-1][0] == ""let"" and item.lstrip(""-"").isdigit():
                scopes[-1][items[-1][-1]] = item
            items[-1].append(item)
        return int(items[-1][-1])","auto evaluate(auto expression) {
    scopes, items = [{}], [[""root""]]
    for item in expression.replace("")"", "" )"").split():
    if item[0] == ""("":
    items.append([item[1:]])
    if item[1:] == ""let"":
    scopes.append(dict(scopes[-1]))
    continue
    elif item == "")"":
    if items[-1][0] == ""add"":
    item = str(int(items[-1][1]) + int(items[-1][-1]))
    elif items[-1][0] == ""mult"":
    item = str(int(items[-1][1]) * int(items[-1][-1]))
    else:
    item = items[-1][-1]
    if item in scopes[-1]:
    item = scopes[-1][item]
    scopes.pop()
    items.pop()
    if item in scopes[-1] and (items[-1][0] != ""let"" or len(items[-1]) % 2 == 0):
    item = scopes[-1][item]
    if items[-1][0] == ""let"" and item.lstrip(""-"").isdigit():
    scopes[-1][items[-1][-1]] = item
    items[-1].append(item)
    return int(items[-1][-1])
}"
737.py,"def areSentencesSimilarTwo(self, words1, words2, pairs):
        def dfs(node, Id):
            cc[node] = Id
            for v in adj[node]:
                if v not in cc:
                    dfs(v, Id)
        l1, l2, adj, cc = len(words1), len(words2), collections.defaultdict(set), {}
        if l1 != l2:
            return False
        for a, b in pairs:
            adj[a].add(b)
            adj[b].add(a)
        for Id, k in enumerate(adj):
            if k not in cc:
                dfs(k, Id)
        for w1, w2 in zip(words1, words2):
            if w1 not in cc or w2 not in cc:
                if w1 != w2:
                    return False
            elif cc[w1] != cc[w2]:
                return False
        return True","auto areSentencesSimilarTwo(auto words1, auto words2, auto pairs) {
    def dfs(node, Id):
    cc[node] = Id
    for v in adj[node]:
    if v not in cc:
    dfs(v, Id)
    l1, l2, adj, cc = len(words1), len(words2), collections.defaultdict(set), {}
    if l1 != l2:
    return False
    for a, b in pairs:
    adj[a].add(b)
    adj[b].add(a)
    for Id, k in enumerate(adj):
    if k not in cc:
    dfs(k, Id)
    for w1, w2 in zip(words1, words2):
    if w1 not in cc or w2 not in cc:
    if w1 != w2:
    return False
    elif cc[w1] != cc[w2]:
    return False
    return True
}"
738.py,"def monotoneIncreasingDigits(self, N):
        """"""
        :type N: int
        :rtype: int
        """"""
        n, pos = str(N), 0
        for i, char in enumerate(n):
            if i>0 and int(n[i])<int(n[i-1]): return int("""".join(n[:pos])+str(int(n[pos])-1)+""9""*(len(n)-1-pos)) if int(n[pos])>1 else int(""9""*(len(n)-1-pos))
            elif i>0 and n[i] != n[i-1]: pos = i
        return N","auto monotoneIncreasingDigits(auto N) {
    """"""
    :type N: int
    :rtype: int
    """"""
    n, pos = str(N), 0
    for i, char in enumerate(n):
    if i>0 and int(n[i])<int(n[i-1]): return int("""".join(n[:pos])+str(int(n[pos])-1)+""9""*(len(n)-1-pos)) if int(n[pos])>1 else int(""9""*(len(n)-1-pos))
    elif i>0 and n[i] != n[i-1]: pos = i
    return N
}"
739.py,"def dailyTemperatures(self, T: List[int]) -> List[int]:
        res = [0] * len(T)
        heap = []
        for j, t in enumerate(T):
            while heap and heap[0][0] < t:
                temp, i = heapq.heappop(heap)
                res[i] = j - i
            heapq.heappush(heap, (t, j))
        return res
        ","auto dailyTemperatures(auto T) {
    res = [0] * len(T)
    heap = []
    for j, t in enumerate(T):
    while heap and heap[0][0] < t:
    temp, i = heapq.heappop(heap)
    res[i] = j - i
    heapq.heappush(heap, (t, j))
    return res
}"
74.py,"def searchMatrix(self, matrix, target):
        ls = list(itertools.chain(*matrix))
        return ls and ls[bisect.bisect(ls, target) - 1] == target or False","auto searchMatrix(auto matrix, auto target) {
    ls = list(itertools.chain(*matrix))
    return ls and ls[bisect.bisect(ls, target) - 1] == target or False
}"
740.py,"def deleteAndEarn(self, nums):
        cnt, dp, maxs = collections.Counter(nums), {}, {}
        nums = sorted(set(nums))
        if len(nums) < 2:
            return nums and nums[0] * cnt[nums[0]] or 0
        for i in range(len(nums)):
            dp[i] = nums[i] * cnt[nums[i]]
            if i >= 2:
                if nums[i - 1] < nums[i] - 1:
                    dp[i] += maxs[i - 1]
                else:
                    dp[i] += maxs[i - 2]
                maxs[i] = max(dp[i], maxs[i - 1])
            elif i:
                if nums[i - 1] < nums[i] - 1:
                    dp[i] += dp[i - 1]
                maxs[i] = max(dp[i], dp[i - 1])
            else:
                maxs[i] = dp[i]
        return max(dp[len(nums) - 1], dp[len(nums) - 2])","auto deleteAndEarn(auto nums) {
    cnt, dp, maxs = collections.Counter(nums), {}, {}
    nums = sorted(set(nums))
    if len(nums) < 2:
    return nums and nums[0] * cnt[nums[0]] or 0
    for i in range(len(nums)):
    dp[i] = nums[i] * cnt[nums[i]]
    if i >= 2:
    if nums[i - 1] < nums[i] - 1:
    dp[i] += maxs[i - 1]
    else:
    dp[i] += maxs[i - 2]
    maxs[i] = max(dp[i], maxs[i - 1])
    elif i:
    if nums[i - 1] < nums[i] - 1:
    dp[i] += dp[i - 1]
    maxs[i] = max(dp[i], dp[i - 1])
    else:
    maxs[i] = dp[i]
    return max(dp[len(nums) - 1], dp[len(nums) - 2])
}"
743.py,"def networkDelayTime(self, times, N, K):
        q, t, adj = [(0, K)], {}, collections.defaultdict(list)
        for u, v, w in times:
            adj[u].append((v, w))
        while q:
            time, node = heapq.heappop(q)
            if node not in t:
                t[node] = time
                for v, w in adj[node]:
                    heapq.heappush(q, (time + w, v))
        return max(t.values()) if len(t) == N else -1","auto networkDelayTime(auto times, auto N, auto K) {
    q, t, adj = [(0, K)], {}, collections.defaultdict(list)
    for u, v, w in times:
    adj[u].append((v, w))
    while q:
    time, node = heapq.heappop(q)
    if node not in t:
    t[node] = time
    for v, w in adj[node]:
    heapq.heappush(q, (time + w, v))
    return max(t.values()) if len(t) == N else -1
}"
744.py,"def nextGreatestLetter(self, letters, target):
        return letters[bisect.bisect(letters, target) % len(letters)]","auto nextGreatestLetter(auto letters, auto target) {
    return letters[bisect.bisect(letters, target) % len(letters)]
}"
746.py,"def minCostClimbingStairs(self, cost):
        """"""
        :type cost: List[int]
        :rtype: int
        """"""
        for i in range(2,len(cost)): cost[i]+=min(cost[i-1],cost[i-2])
        return min(cost[-1],cost[-2])","auto minCostClimbingStairs(auto cost) {
    """"""
    :type cost: List[int]
    :rtype: int
    """"""
    for i in range(2,len(cost)): cost[i]+=min(cost[i-1],cost[i-2])
    return min(cost[-1],cost[-2])
}"
747.py,"def dominantIndex(self, nums: List[int]) -> int:
        mx = max(nums)
        return nums.index(mx) if all(num * 2 <= mx for num in nums if num < mx) else -1","auto dominantIndex(auto nums) {
    mx = max(nums)
    return nums.index(mx) if all(num * 2 <= mx for num in nums if num < mx) else -1
}"
748.py,"def shortestCompletingWord(self, lp, words):
        cntr_lp, res = {k: v for k, v in collections.Counter(lp.lower()).items() if k.isalpha()}, [None, None]
        for word in words:
            check = collections.Counter(word.lower())
            if all(True if k in check and v <= check[k] else False for k, v in cntr_lp.items()):
                if not any(res) or len(word) < res[1]: res = [word, len(word)]
        return res[0]   ","auto shortestCompletingWord(auto lp, auto words) {
    cntr_lp, res = {k: v for k, v in collections.Counter(lp.lower()).items() if k.isalpha()}, [None, None]
    for word in words:
    check = collections.Counter(word.lower())
    if all(True if k in check and v <= check[k] else False for k, v in cntr_lp.items()):
    if not any(res) or len(word) < res[1]: res = [word, len(word)]
    return res[0]
}"
75.py,"def sortColors(self, nums):
        """"""
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """"""
        red, white, blue = 0, 0, len(nums)-1
        while white <= blue:
            if nums[white] == 0:
                nums[red], nums[white] = nums[white], nums[red]
                white += 1
                red += 1
            elif nums[white] == 1:
                white += 1
            else:
                nums[white], nums[blue] = nums[blue], nums[white]
                blue -= 1","auto sortColors(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: void Do not return anything, modify nums in-place instead.
    """"""
    red, white, blue = 0, 0, len(nums)-1
    while white <= blue:
    if nums[white] == 0:
    nums[red], nums[white] = nums[white], nums[red]
    white += 1
    red += 1
    elif nums[white] == 1:
    white += 1
    else:
    nums[white], nums[blue] = nums[blue], nums[white]
    blue -= 1
}"
750.py,"def countCornerRectangles(self, grid):
        ends, res = collections.defaultdict(int), 0
        for row in grid:
            for i in range(len(row) - 1):
                for j in range(i + 1, len(row)):
                    if row[i] and row[j]:
                        ends[(i, j)] = ends.get((i, j), 0) + 1
                        res += ends[(i, j)] - 1
        return res","auto countCornerRectangles(auto grid) {
    ends, res = collections.defaultdict(int), 0
    for row in grid:
    for i in range(len(row) - 1):
    for j in range(i + 1, len(row)):
    if row[i] and row[j]:
    ends[(i, j)] = ends.get((i, j), 0) + 1
    res += ends[(i, j)] - 1
    return res
}"
751.py,"def ipToCIDR(self, ip: str, n: int) -> List[str]:
        s = ''.join(bin(int(num))[2:].zfill(8) for num in ip.split('.'))
        res = []
        while n:
            for i in range(31 - s.rindex('1'), -1, -1):
                if 2 ** i <= n:
                    res.append('.'.join(str(int(s[i:i + 8], 2)) for i in range(0, 32, 8)) + '/' + str(32 - i))
                    n -= 2 ** i
                    s = bin(int(s, 2) + 2 ** i)[2:].zfill(32)
                    break
        return res
        ","auto ipToCIDR(auto ip, auto n) {
    s = ''.join(bin(int(num))[2:].zfill(8) for num in ip.split('.'))
    res = []
    while n:
    for i in range(31 - s.rindex('1'), -1, -1):
    if 2 ** i <= n:
    res.append('.'.join(str(int(s[i:i + 8], 2)) for i in range(0, 32, 8)) + '/' + str(32 - i))
    n -= 2 ** i
    s = bin(int(s, 2) + 2 ** i)[2:].zfill(32)
    break
    return res
}"
752.py,"def openLock(self, deadends, target):
        moved, q, cnt, move = set(deadends), [""0000""], 0, {str(i): [str((i + 1) % 10), str((i - 1) % 10)] for i in range(10)}
        if ""0000"" in moved:
            return -1
        while q:
            new = []
            cnt += 1
            for s in q:
                for i, c in enumerate(s):
                    for cur in (s[:i] + move[c][0] + s[i + 1:], s[:i] + move[c][1] + s[i + 1:]):
                        if cur not in moved:
                            if cur == target:
                                return cnt
                            new.append(cur)
                            moved.add(cur)
            q = new
        return -1","auto openLock(auto deadends, auto target) {
    moved, q, cnt, move = set(deadends), [""0000""], 0, {str(i): [str((i + 1) % 10), str((i - 1) % 10)] for i in range(10)}
    if ""0000"" in moved:
    return -1
    while q:
    new = []
    cnt += 1
    for s in q:
    for i, c in enumerate(s):
    for cur in (s[:i] + move[c][0] + s[i + 1:], s[:i] + move[c][1] + s[i + 1:]):
    if cur not in moved:
    if cur == target:
    return cnt
    new.append(cur)
    moved.add(cur)
    q = new
    return -1
}"
753.py,"def crackSafe(self, n, k):
        s = '0' * (n - 1)
        D = '9876543210'[-k:]
        for _ in range(k**n):
            s += next(d for d in D if (s + d)[-n:] not in s)
        return s","auto crackSafe(auto n, auto k) {
    s = '0' * (n - 1)
    D = '9876543210'[-k:]
    for _ in range(k**n):
    s += next(d for d in D if (s + d)[-n:] not in s)
    return s
}"
754.py,"def reachNumber(self, target):
        pos, step, target = 0, 0, abs(target)
        while pos < target or (pos - target) % 2:
            step += 1
            pos += step
        return step","auto reachNumber(auto target) {
    pos, step, target = 0, 0, abs(target)
    while pos < target or (pos - target) % 2:
    step += 1
    pos += step
    return step
}"
755.py,"def pourWater(self, heights, V, K):
        for drop in range(V):
            l = r = K
            for i in range(K - 1, -1, -1):
                if heights[i] > heights[l]:
                    break
                elif heights[i] < heights[l]:
                    l = i
            if l < K:
                heights[l] += 1
            else:
                for j in range(K + 1, len(heights)):
                    if heights[j] > heights[r]:
                        break
                    elif heights[j] < heights[r]:
                        r = j
            if l == r == K:
                heights[K] += 1
            elif r > K:
                heights[r] += 1
        return heights","auto pourWater(auto heights, auto V, auto K) {
    for drop in range(V):
    l = r = K
    for i in range(K - 1, -1, -1):
    if heights[i] > heights[l]:
    break
    elif heights[i] < heights[l]:
    l = i
    if l < K:
    heights[l] += 1
    else:
    for j in range(K + 1, len(heights)):
    if heights[j] > heights[r]:
    break
    elif heights[j] < heights[r]:
    r = j
    if l == r == K:
    heights[K] += 1
    elif r > K:
    heights[r] += 1
    return heights
}"
756.py,"def pyramidTransition(self, bottom, allowed):
        chars, allowed = 'ABCDEFG', set(allowed)
        def dfs(r, q, i):
            if len(r) == 1: 
                return True
            for c in chars:
                if r[i:i+2]+c in allowed and (i==len(r)-2 and dfs(q+c,"""",0) or dfs(r,q+c,i+1)): return True
            return False
        return dfs(bottom, """", 0) ","auto pyramidTransition(auto bottom, auto allowed) {
    chars, allowed = 'ABCDEFG', set(allowed)
    def dfs(r, q, i):
    if len(r) == 1:
    return True
    for c in chars:
    if r[i:i+2]+c in allowed and (i==len(r)-2 and dfs(q+c,"""",0) or dfs(r,q+c,i+1)): return True
    return False
    return dfs(bottom, """", 0)
}"
758.py,"def boldWords(self, words, S):
        trie, n, mask, res = {}, len(S), set(), """"
        for w in words:
            cur = trie
            for c in w:
                if c not in cur:
                    cur[c] = {}
                cur = cur[c]
            cur[""#""] = cur.get(""#"", set()) | {w}
        for i in range(n):
            cur, j = trie, i
            while j < n and S[j] in cur:
                cur = cur[S[j]]
                if ""#"" in cur:
                    mask |= {ind for ind in range(i, j + 1)}
                j += 1
        for i in range(n):
            if i in mask and (not i or i - 1 not in mask):
                res += ""<b>""
            res += S[i]
            if i in mask and (i == n - 1 or i + 1 not in mask):
                res += ""</b>""
        return res","auto boldWords(auto words, auto S) {
    trie, n, mask, res = {}, len(S), set(), """"
    for w in words:
    cur = trie
    for c in w:
    if c not in cur:
    cur[c] = {}
    cur = cur[c]
    cur[""#""] = cur.get(""#"", set()) | {w}
    for i in range(n):
    cur, j = trie, i
    while j < n and S[j] in cur:
    cur = cur[S[j]]
    if ""#"" in cur:
    mask |= {ind for ind in range(i, j + 1)}
    j += 1
    for i in range(n):
    if i in mask and (not i or i - 1 not in mask):
    res += ""<b>""
    res += S[i]
    if i in mask and (i == n - 1 or i + 1 not in mask):
    res += ""</b>""
    return res
}"
76.py,"def minWindow(self, s, t):
        cnt_s, cnt_t, n, left, r = {}, {}, len(s), set(t), -1
        for c in t:
            cnt_t[c] = cnt_t.get(c, 0) + 1
        L = l = 0
        while left:
            r += 1
            if r >= n:
                return """"
            cnt_s[s[r]] = cnt_s.get(s[r], 0) + 1
            if s[r] in cnt_t and cnt_s[s[r]] == cnt_t[s[r]]:
                left.discard(s[r])
        R = r
        cnt_s[s[r]] -= 1
        while l < r < n:
            cnt_s[s[r]] = cnt_s.get(s[r], 0) + 1
            while s[l] not in cnt_t or cnt_s[s[l]] > cnt_t[s[l]]:
                cnt_s[s[l]] -= 1
                l += 1
            if r - l < R - L:
                L, R = l, r
            r += 1   
        return s[L: R + 1]","auto minWindow(auto s, auto t) {
    cnt_s, cnt_t, n, left, r = {}, {}, len(s), set(t), -1
    for c in t:
    cnt_t[c] = cnt_t.get(c, 0) + 1
    L = l = 0
    while left:
    r += 1
    if r >= n:
    return """"
    cnt_s[s[r]] = cnt_s.get(s[r], 0) + 1
    if s[r] in cnt_t and cnt_s[s[r]] == cnt_t[s[r]]:
    left.discard(s[r])
    R = r
    cnt_s[s[r]] -= 1
    while l < r < n:
    cnt_s[s[r]] = cnt_s.get(s[r], 0) + 1
    while s[l] not in cnt_t or cnt_s[s[l]] > cnt_t[s[l]]:
    cnt_s[s[l]] -= 1
    l += 1
    if r - l < R - L:
    L, R = l, r
    r += 1
    return s[L: R + 1]
}"
760.py,"def anagramMappings(self, A, B):
        ind = {num: j for j, num in enumerate(B)}
        return [ind[num] for num in A] ","auto anagramMappings(auto A, auto B) {
    ind = {num: j for j, num in enumerate(B)}
    return [ind[num] for num in A]
}"
761.py,"def makeLargestSpecial(self, S: str) -> str:
        count = i = 0
        res = []
        for j, v in enumerate(S):
            count = count + 1 if v=='1' else count - 1
            if count == 0:
                res.append('1' + self.makeLargestSpecial(S[i + 1:j]) + '0')
                i = j + 1
        return ''.join(sorted(res)[::-1])","auto makeLargestSpecial(auto S) {
    count = i = 0
    res = []
    for j, v in enumerate(S):
    count = count + 1 if v=='1' else count - 1
    if count == 0:
    res.append('1' + self.makeLargestSpecial(S[i + 1:j]) + '0')
    i = j + 1
    return ''.join(sorted(res)[::-1])
}"
762.py,"def countPrimeSetBits(self, L, R):
        """"""
        :type L: int
        :type R: int
        :rtype: int
        """"""
        count=0
        while L<=R:
            if str(bin(L)[2:]).count(""1"") in [2,3,5,7,11,13,17,19]: count+=1
            if str(bin(R)[2:]).count(""1"") in [2,3,5,7,11,13,17,19]:
                count+=1
                if L==R: count-=1
            L+=1
            R-=1
        return count","auto countPrimeSetBits(auto L, auto R) {
    """"""
    :type L: int
    :type R: int
    :rtype: int
    """"""
    count=0
    while L<=R:
    if str(bin(L)[2:]).count(""1"") in [2,3,5,7,11,13,17,19]: count+=1
    if str(bin(R)[2:]).count(""1"") in [2,3,5,7,11,13,17,19]:
    count+=1
    if L==R: count-=1
    L+=1
    R-=1
    return count
}"
763.py,"def partitionLabels(self, S):
        """"""
        :type S: str
        :rtype: List[int]
        """"""
        sizes = []
        while S:
            i = 1
            while set(S[:i]) & set(S[i:]):
                i += 1
            sizes.append(i)
            S = S[i:]
        return sizes","auto partitionLabels(auto S) {
    """"""
    :type S: str
    :rtype: List[int]
    """"""
    sizes = []
    while S:
    i = 1
    while set(S[:i]) & set(S[i:]):
    i += 1
    sizes.append(i)
    S = S[i:]
    return sizes
}"
764.py,"def orderOfLargestPlusSign(self, N, mines):
        #up, left, down, right
        dp, res, mines = [[[0, 0, 0, 0] for j in range(N)] for i in range(N)], 0, {(i, j) for i, j in mines}
        for i in range(N):
            for j in range(N):
                if (i, j) not in mines:
                    try:
                        dp[i][j][0] = dp[i - 1][j][0] + 1
                    except:
                        dp[i][j][0] = 1
                    try:
                        dp[i][j][1] = dp[i][j - 1][1] + 1
                    except:
                        dp[i][j][1] = 1
        for i in range(N - 1, -1, -1):
            for j in range(N - 1, -1, -1):
                if (i, j) not in mines:
                    try:
                        dp[i][j][2] = dp[i + 1][j][2] + 1
                    except:
                        dp[i][j][2] = 1
                    try:
                        dp[i][j][3] = dp[i][j + 1][3] + 1
                    except:
                        dp[i][j][3] = 1
                    res = max(res, min(dp[i][j]))
        return res","auto orderOfLargestPlusSign(auto N, auto mines) {
    #up, left, down, right
    dp, res, mines = [[[0, 0, 0, 0] for j in range(N)] for i in range(N)], 0, {(i, j) for i, j in mines}
    for i in range(N):
    for j in range(N):
    if (i, j) not in mines:
    try:
    dp[i][j][0] = dp[i - 1][j][0] + 1
    except:
    dp[i][j][0] = 1
    try:
    dp[i][j][1] = dp[i][j - 1][1] + 1
    except:
    dp[i][j][1] = 1
    for i in range(N - 1, -1, -1):
    for j in range(N - 1, -1, -1):
    if (i, j) not in mines:
    try:
    dp[i][j][2] = dp[i + 1][j][2] + 1
    except:
    dp[i][j][2] = 1
    try:
    dp[i][j][3] = dp[i][j + 1][3] + 1
    except:
    dp[i][j][3] = 1
    res = max(res, min(dp[i][j]))
    return res
}"
765.py,"def minSwapsCouples(self, row):
        res, index = 0, {num: i for i, num in enumerate(row)}
        for i in range(0, len(row), 2):
            if row[i] % 2 == 0 and row[i + 1] != row[i] + 1: 
                f = row[i + 1]
                row[i + 1], row[index[row[i] + 1]] = row[i] + 1, row[i + 1]
                index[row[i] + 1], index[f] = i + 1, index[row[i] + 1]
                res += 1
            elif row[i] % 2 != 0 and row[i + 1] != row[i] - 1:
                f = row[i + 1]
                row[i + 1], row[index[row[i] - 1]], index[row[i + 1]] = row[i] - 1, row[i + 1], index[row[i] - 1]
                index[row[i] - 1], index[f] = i + 1, index[row[i] - 1]
                res += 1
        return res","auto minSwapsCouples(auto row) {
    res, index = 0, {num: i for i, num in enumerate(row)}
    for i in range(0, len(row), 2):
    if row[i] % 2 == 0 and row[i + 1] != row[i] + 1:
    f = row[i + 1]
    row[i + 1], row[index[row[i] + 1]] = row[i] + 1, row[i + 1]
    index[row[i] + 1], index[f] = i + 1, index[row[i] + 1]
    res += 1
    elif row[i] % 2 != 0 and row[i + 1] != row[i] - 1:
    f = row[i + 1]
    row[i + 1], row[index[row[i] - 1]], index[row[i + 1]] = row[i] - 1, row[i + 1], index[row[i] - 1]
    index[row[i] - 1], index[f] = i + 1, index[row[i] - 1]
    res += 1
    return res
}"
766.py,"def isToeplitzMatrix(self, matrix):
        return all(matrix[i][j] == matrix[i - 1][j - 1] for i in range(1, len(matrix)) for j in range(1, len(matrix[0])))","auto isToeplitzMatrix(auto matrix) {
    return all(matrix[i][j] == matrix[i - 1][j - 1] for i in range(1, len(matrix)) for j in range(1, len(matrix[0])))
}"
767.py,"def reorganizeString(self, S):
        cnt, res = collections.Counter(S), """"
        while len(res) < len(S):
            c, i = cnt.most_common()[0], 0
            while i + 1 < len(cnt) and (res and res[-1] == c[0] or cnt[c[0]] == 0): c, i = cnt.most_common()[i + 1], i + 1
            if not cnt[c[0]] or res and res[-1] == c[0]: return """"
            else: res, cnt[c[0]] = res + c[0], cnt[c[0]] - 1
        return res","auto reorganizeString(auto S) {
    cnt, res = collections.Counter(S), """"
    while len(res) < len(S):
    c, i = cnt.most_common()[0], 0
    while i + 1 < len(cnt) and (res and res[-1] == c[0] or cnt[c[0]] == 0): c, i = cnt.most_common()[i + 1], i + 1
    if not cnt[c[0]] or res and res[-1] == c[0]: return """"
    else: res, cnt[c[0]] = res + c[0], cnt[c[0]] - 1
    return res
}"
768.py,"def maxChunksToSorted(self, arr):
        mx, mn, res, check = 0, 10 ** 9, 0, [[0, 0] for _ in range(len(arr))]
        for i in range(len(arr)):
            if arr[i] > mx: mx = arr[i]
            check[i][0] = mx
        for i in range(len(arr) -1, -1, -1):
            check[i][1] = mn
            if arr[i] < mn: mn = arr[i]
        for c in check:
            if c[0] <= c[1]: res += 1
        return res","auto maxChunksToSorted(auto arr) {
    mx, mn, res, check = 0, 10 ** 9, 0, [[0, 0] for _ in range(len(arr))]
    for i in range(len(arr)):
    if arr[i] > mx: mx = arr[i]
    check[i][0] = mx
    for i in range(len(arr) -1, -1, -1):
    check[i][1] = mn
    if arr[i] < mn: mn = arr[i]
    for c in check:
    if c[0] <= c[1]: res += 1
    return res
}"
769.py,"def maxChunksToSorted(self, arr):
        """"""
        :type arr: List[int]
        :rtype: int
        """"""
        max_seen, total_seen, res_count = 0, 0, 0
        for num in arr:
            max_seen = max(max_seen, num)
            total_seen += 1
            if max_seen == total_seen - 1:
                res_count += 1
        return res_count","auto maxChunksToSorted(auto arr) {
    """"""
    :type arr: List[int]
    :rtype: int
    """"""
    max_seen, total_seen, res_count = 0, 0, 0
    for num in arr:
    max_seen = max(max_seen, num)
    total_seen += 1
    if max_seen == total_seen - 1:
    res_count += 1
    return res_count
}"
77.py,"def combine(self, n: int, k: int) -> List[List[int]]:
        bfs = [[]]
        for num in range(1, n + 1):
            bfs += [arr + [num] for arr in bfs if len(arr) < k]
        return [arr for arr in bfs if len(arr) == k]","auto combine(auto n, auto k) {
    bfs = [[]]
    for num in range(1, n + 1):
    bfs += [arr + [num] for arr in bfs if len(arr) < k]
    return [arr for arr in bfs if len(arr) == k]
}"
771.py,"def numJewelsInStones(self, J, S):
        sj = set(J)
        return sum(s in sj for s in S)","auto numJewelsInStones(auto J, auto S) {
    sj = set(J)
    return sum(s in sj for s in S)
}"
772.py,"def calculate(self, s: str) -> int:
        def calc(n2, op, n1): 
            return n1 * n2 if op == '*' else n1 // n2 if op == '/' else n1 + n2 if op == '+' else n1 - n2
        def calc2(arr):
            if len(arr) == 1:
                return arr.pop()
            res = arr[0]
            for j in range(2, len(arr), 2):
                res = calc(arr[j], arr[j - 1], res)
            return res
        stack, i, num = [], 0, 0
        while i < len(s):
            j = i
            while j < len(s) and s[j].isdigit():
                num, j = num * 10 + int(s[j]), j + 1
            if i != j:
                stack.append(calc(num, stack.pop(), stack.pop()) if stack and stack[-1] in ""*/"" else num)
                num, j = 0, j - 1
            elif s[i] == "")"":
                ind = len(stack) - stack[::-1].index('(') - 1
                stack[ind:] = [calc2(stack[ind + 1:])]
                if len(stack) > 1 and stack[-2] in '*/':
                    stack.append(calc(stack.pop(), stack.pop(), stack.pop()))
            elif s[i] != ' ':
                stack.append(s[i])
            i = j + 1
        return calc2(stack)","auto calculate(auto s) {
    def calc(n2, op, n1):
    return n1 * n2 if op == '*' else n1 // n2 if op == '/' else n1 + n2 if op == '+' else n1 - n2
    def calc2(arr):
    if len(arr) == 1:
    return arr.pop()
    res = arr[0]
    for j in range(2, len(arr), 2):
    res = calc(arr[j], arr[j - 1], res)
    return res
    stack, i, num = [], 0, 0
    while i < len(s):
    j = i
    while j < len(s) and s[j].isdigit():
    num, j = num * 10 + int(s[j]), j + 1
    if i != j:
    stack.append(calc(num, stack.pop(), stack.pop()) if stack and stack[-1] in ""*/"" else num)
    num, j = 0, j - 1
    elif s[i] == "")"":
    ind = len(stack) - stack[::-1].index('(') - 1
    stack[ind:] = [calc2(stack[ind + 1:])]
    if len(stack) > 1 and stack[-2] in '*/':
    stack.append(calc(stack.pop(), stack.pop(), stack.pop()))
    elif s[i] != ' ':
    stack.append(s[i])
    i = j + 1
    return calc2(stack)
}"
773.py,"def slidingPuzzle(self, board):
        moves, used, cnt = {0: {1, 3}, 1:{0, 2, 4}, 2:{1, 5}, 3:{0, 4}, 4:{1, 3, 5}, 5:{2, 4}}, set(), 0
        s = """".join(str(c) for row in board for c in row)
        q = [(s, s.index(""0""))]
        while q:
            new = []
            for s, i in q:
                used.add(s)
                if s == ""123450"":
                    return cnt
                arr = [c for c in s]
                for move in moves[i]:
                    new_arr = arr[:]
                    new_arr[i], new_arr[move] = new_arr[move], new_arr[i]
                    new_s = """".join(new_arr)
                    if new_s not in used:
                        new.append((new_s, move))
            cnt += 1
            q = new
        return -1","auto slidingPuzzle(auto board) {
    moves, used, cnt = {0: {1, 3}, 1:{0, 2, 4}, 2:{1, 5}, 3:{0, 4}, 4:{1, 3, 5}, 5:{2, 4}}, set(), 0
    s = """".join(str(c) for row in board for c in row)
    q = [(s, s.index(""0""))]
    while q:
    new = []
    for s, i in q:
    used.add(s)
    if s == ""123450"":
    return cnt
    arr = [c for c in s]
    for move in moves[i]:
    new_arr = arr[:]
    new_arr[i], new_arr[move] = new_arr[move], new_arr[i]
    new_s = """".join(new_arr)
    if new_s not in used:
    new.append((new_s, move))
    cnt += 1
    q = new
    return -1
}"
774.py,"def minmaxGasDist(self, st, K):
        left, right = 1e-6, st[-1] - st[0]
        while left + 1e-6 < right:
            mid = (left + right) / 2
            count = 0
            for a, b in zip(st, st[1:]):
                count += math.ceil((b - a) / mid) - 1
            if count > K:
                left = mid
            else:
                right = mid
        return right","auto minmaxGasDist(auto st, auto K) {
    left, right = 1e-6, st[-1] - st[0]
    while left + 1e-6 < right:
    mid = (left + right) / 2
    count = 0
    for a, b in zip(st, st[1:]):
    count += math.ceil((b - a) / mid) - 1
    if count > K:
    left = mid
    else:
    right = mid
    return right
}"
775.py,"def isIdealPermutation(self, A):
        for i, num in enumerate(A):
            if not (i - 1 <= num <= i + 1): return False
        return True","auto isIdealPermutation(auto A) {
    for i, num in enumerate(A):
    if not (i - 1 <= num <= i + 1): return False
    return True
}"
776.py,"def splitBST(self, root, V):
        if not root:
            return [None, None]
        if root.val == V:
            a = root.right
            root.right = None
            return [root, a]
        elif root.val < V:
            small, large = self.splitBST(root.right, V)
            root.right = small
            return [root, large]
        else:
            small, large = self.splitBST(root.left, V)
            root.left = large
            return [small, root]","auto splitBST(auto root, auto V) {
    if not root:
    return [None, None]
    if root.val == V:
    a = root.right
    root.right = None
    return [root, a]
    elif root.val < V:
    small, large = self.splitBST(root.right, V)
    root.right = small
    return [root, large]
    else:
    small, large = self.splitBST(root.left, V)
    root.left = large
    return [small, root]
}"
777.py,"def canTransform(self, start, end):
        s, e = collections.defaultdict(list), collections.defaultdict(list)
        newS, newE = [c for c in start if c != ""X""], [c for c in end if c != ""X""]
        for i in range(len(start)):
            if start[i] != ""X"":
                s[start[i]].append(i)
            if end[i] != ""X"":
                e[end[i]].append(i)
        if newS == newE and len(s[""L""]) == len(e[""L""]) and len(s[""R""]) == len(e[""R""]):
            if all(s[""R""][i] <= e[""R""][i] for i in range(len(s[""R""]))) and all(s[""L""][i] >= e[""L""][i] for i in range(len(s[""L""]))):
                return True
        return False","auto canTransform(auto start, auto end) {
    s, e = collections.defaultdict(list), collections.defaultdict(list)
    newS, newE = [c for c in start if c != ""X""], [c for c in end if c != ""X""]
    for i in range(len(start)):
    if start[i] != ""X"":
    s[start[i]].append(i)
    if end[i] != ""X"":
    e[end[i]].append(i)
    if newS == newE and len(s[""L""]) == len(e[""L""]) and len(s[""R""]) == len(e[""R""]):
    if all(s[""R""][i] <= e[""R""][i] for i in range(len(s[""R""]))) and all(s[""L""][i] >= e[""L""][i] for i in range(len(s[""L""]))):
    return True
    return False
}"
778.py,"def swimInWater(self, grid):
        heap, res, n, visited = [(grid[0][0], 0, 0)], 0, len(grid), set()
        while True:
            d, i, j = heapq.heappop(heap)
            if d > res: res = d
            if i == j == n - 1: return res
            for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
                if 0 <= x < n and 0 <= y < n and (x, y) not in visited: 
                    visited.add((x, y))
                    heapq.heappush(heap, (grid[x][y], x, y))","auto swimInWater(auto grid) {
    heap, res, n, visited = [(grid[0][0], 0, 0)], 0, len(grid), set()
    while True:
    d, i, j = heapq.heappop(heap)
    if d > res: res = d
    if i == j == n - 1: return res
    for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
    if 0 <= x < n and 0 <= y < n and (x, y) not in visited:
    visited.add((x, y))
    heapq.heappush(heap, (grid[x][y], x, y))
}"
779.py,"def kthGrammar(self, N: int, K: int) -> int:
        return N > 1 and self.kthGrammar(N - 1, (K + 1) // 2) ^ ((K -1) % 2) or 0","auto kthGrammar(auto N, auto K) {
    return N > 1 and self.kthGrammar(N - 1, (K + 1) // 2) ^ ((K -1) % 2) or 0
}"
78.py,"def subsets(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[List[int]]
        """"""
        res = [[]]
        for num in nums: 
            res += [item+[num] for item in res]
        return res","auto subsets(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: List[List[int]]
    """"""
    res = [[]]
    for num in nums:
    res += [item+[num] for item in res]
    return res
}"
780.py,"def reachingPoints(self, sx, sy, tx, ty):
        while sx<tx and sy<ty: tx,ty = tx%ty,ty%tx
        return sx==tx and (ty-sy)%sx==0 or sy==ty and (tx-sx)%sy==0","auto reachingPoints(auto sx, auto sy, auto tx, auto ty) {
    while sx<tx and sy<ty: tx,ty = tx%ty,ty%tx
    return sx==tx and (ty-sy)%sx==0 or sy==ty and (tx-sx)%sy==0
}"
781.py,"def numRabbits(self, answers):
        dic, res = {}, 0
        for ans in answers:
            (dic[ans], res) = (1, res + ans + 1) if ans not in dic or dic[ans] > ans else (dic[ans] + 1, res)
        return res","auto numRabbits(auto answers) {
    dic, res = {}, 0
    for ans in answers:
    (dic[ans], res) = (1, res + ans + 1) if ans not in dic or dic[ans] > ans else (dic[ans] + 1, res)
    return res
}"
782.py,"def movesToChessboard(self, b):
        N = len(b)
        if any(b[0][0] ^ b[i][0] ^ b[0][j] ^ b[i][j] for i in range(N) for j in range(N)): return -1
        if not N // 2 <= sum(b[0]) <= (N + 1) // 2: return -1
        if not N // 2 <= sum(b[i][0] for i in range(N)) <= (N + 1) // 2: return -1
        col = sum(b[0][i] == i % 2 for i in range(N))
        row = sum(b[i][0] == i % 2 for i in range(N))
        if N % 2:
            if col % 2: col = [col, N - col][col % 2]
            if row % 2: row = N - row
        else:
            col = min(N - col, col)
            row = min(N - row, row)
        return (col + row) // 2","auto movesToChessboard(auto b) {
    N = len(b)
    if any(b[0][0] ^ b[i][0] ^ b[0][j] ^ b[i][j] for i in range(N) for j in range(N)): return -1
    if not N // 2 <= sum(b[0]) <= (N + 1) // 2: return -1
    if not N // 2 <= sum(b[i][0] for i in range(N)) <= (N + 1) // 2: return -1
    col = sum(b[0][i] == i % 2 for i in range(N))
    row = sum(b[i][0] == i % 2 for i in range(N))
    if N % 2:
    if col % 2: col = [col, N - col][col % 2]
    if row % 2: row = N - row
    else:
    col = min(N - col, col)
    row = min(N - row, row)
    return (col + row) // 2
}"
783.py,"def minDiffInBST(self, root):
        def dfs(node):
            if not node: return float(""inf""), float(""inf""), -float(""inf"")
            l, lMn, lMx = dfs(node.left)
            r, rMn, rMx = dfs(node.right)
            return min(l, node.val - lMx, r, rMn - node.val), min(lMn, node.val), max(rMx, node.val)
        return dfs(root)[0]","auto minDiffInBST(auto root) {
    def dfs(node):
    if not node: return float(""inf""), float(""inf""), -float(""inf"")
    l, lMn, lMx = dfs(node.left)
    r, rMn, rMx = dfs(node.right)
    return min(l, node.val - lMx, r, rMn - node.val), min(lMn, node.val), max(rMx, node.val)
    return dfs(root)[0]
}"
784.py,"def letterCasePermutation(self, S: str) -> List[str]:
        bfs = ['']
        for c in S:
            if c.isdigit():
                bfs = [s + c for s in bfs]
            else:
                bfs = [s + c.lower() for s in bfs] + [s + c.upper() for s in bfs]
        return bfs","auto letterCasePermutation(auto S) {
    bfs = ['']
    for c in S:
    if c.isdigit():
    bfs = [s + c for s in bfs]
    else:
    bfs = [s + c.lower() for s in bfs] + [s + c.upper() for s in bfs]
    return bfs
}"
785.py,"def isBipartite(self, graph):
        side = [0] * len(graph)
        def dfs(node):
            for v in graph[node]:
                if side[v] == 0: 
                    side[v] = -side[node]
                    if not dfs(v): return False
                elif side[v] == side[node]: return False
            return True
        for i in range(len(graph)):
            if side[i] == 0: 
                side[i] = 1
            if not dfs(i): return False
        return True","auto isBipartite(auto graph) {
    side = [0] * len(graph)
    def dfs(node):
    for v in graph[node]:
    if side[v] == 0:
    side[v] = -side[node]
    if not dfs(v): return False
    elif side[v] == side[node]: return False
    return True
    for i in range(len(graph)):
    if side[i] == 0:
    side[i] = 1
    if not dfs(i): return False
    return True
}"
786.py,"def kthSmallestPrimeFraction(self, A, K):
        heap, used = [(A[0] / A[-1], 0, len(A) - 1)], {(0, len(A) - 1)}
        for i in range(K):
            try:
                cur, l, r = heapq.heappop(heap)
                used.add((l, r))
                if (l + 1, r) not in used:
                    heapq.heappush(heap, (A[l + 1] / A[r], l + 1, r))
                    used.add((l + 1, r))
                if (l, r - 1) not in used:
                    heapq.heappush(heap, (A[l] / A[r - 1], l, r - 1))
                    used.add((l, r - 1))
            except:
                break
        return [A[l], A[r]]","auto kthSmallestPrimeFraction(auto A, auto K) {
    heap, used = [(A[0] / A[-1], 0, len(A) - 1)], {(0, len(A) - 1)}
    for i in range(K):
    try:
    cur, l, r = heapq.heappop(heap)
    used.add((l, r))
    if (l + 1, r) not in used:
    heapq.heappush(heap, (A[l + 1] / A[r], l + 1, r))
    used.add((l + 1, r))
    if (l, r - 1) not in used:
    heapq.heappush(heap, (A[l] / A[r - 1], l, r - 1))
    used.add((l, r - 1))
    except:
    break
    return [A[l], A[r]]
}"
787.py,"def findCheapestPrice(self, n, flights, src, dst, K):
        flight = collections.defaultdict(list)
        for s, e, p in flights:
            flight[s].append((e, p))
        heap = [(0, src, K + 1)]
        while heap:
            price, city, stop = heapq.heappop(heap)
            if city == dst:
                return price
            elif stop > 0:
                for c, p in flight[city]:
                    heapq.heappush(heap, (price + p, c, stop - 1))
        return -1","auto findCheapestPrice(auto n, auto flights, auto src, auto dst, auto K) {
    flight = collections.defaultdict(list)
    for s, e, p in flights:
    flight[s].append((e, p))
    heap = [(0, src, K + 1)]
    while heap:
    price, city, stop = heapq.heappop(heap)
    if city == dst:
    return price
    elif stop > 0:
    for c, p in flight[city]:
    heapq.heappush(heap, (price + p, c, stop - 1))
    return -1
}"
788.py,"def rotatedDigits(self, N):
        """"""
        :type N: int
        :rtype: int
        """"""
        res = 0
        for i in range(1, N + 1):
            i = str(i)
            tmp = []
            check = True
            for char in i:
                if char in (""3"", ""4"", ""7""):
                    check = False
                    break
                if char in (""0"", ""1"", ""8""):
                    tmp.append(char)
                if char == ""2"":
                    tmp.append(""5"")
                if char == ""5"":
                    tmp.append(""2"")
                if char == ""6"":
                    tmp.append(""9"")
                if char == ""9"":
                    tmp.append(""6"")
            if check and i != """".join(tmp): res += 1
        return res","auto rotatedDigits(auto N) {
    """"""
    :type N: int
    :rtype: int
    """"""
    res = 0
    for i in range(1, N + 1):
    i = str(i)
    tmp = []
    check = True
    for char in i:
    if char in (""3"", ""4"", ""7""):
    check = False
    break
    if char in (""0"", ""1"", ""8""):
    tmp.append(char)
    if char == ""2"":
    tmp.append(""5"")
    if char == ""5"":
    tmp.append(""2"")
    if char == ""6"":
    tmp.append(""9"")
    if char == ""9"":
    tmp.append(""6"")
    if check and i != """".join(tmp): res += 1
    return res
}"
789.py,"def escapeGhosts(self, ghosts, target):
        d = abs(target[0]) + abs(target[1])
        for ghost in ghosts:
            if abs(ghost[0] - target[0]) + abs(ghost[1] - target[1]) <= d: return False
        return True","auto escapeGhosts(auto ghosts, auto target) {
    d = abs(target[0]) + abs(target[1])
    for ghost in ghosts:
    if abs(ghost[0] - target[0]) + abs(ghost[1] - target[1]) <= d: return False
    return True
}"
79.py,"def exist(self, board, word):
        m, n, o = len(board), len(board and board[0]), len(word)
        def explore(i, j, k, q):
            for x, y in ((i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)):
                if k>=o or (0<=x<m and 0<=y<n and board[x][y]==word[k] and (x,y) not in q and explore(x,y,k+1,q|{(x,y)})): return True
            return False
        for i in range(m):
            for j in range(n):
                if board[i][j] == word[0] and explore(i, j, 1, {(i, j)}): return True
        return False","auto exist(auto board, auto word) {
    m, n, o = len(board), len(board and board[0]), len(word)
    def explore(i, j, k, q):
    for x, y in ((i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)):
    if k>=o or (0<=x<m and 0<=y<n and board[x][y]==word[k] and (x,y) not in q and explore(x,y,k+1,q|{(x,y)})): return True
    return False
    for i in range(m):
    for j in range(n):
    if board[i][j] == word[0] and explore(i, j, 1, {(i, j)}): return True
    return False
}"
791.py,"def customSortString(self, S, T):
        """"""
        :type S: str
        :type T: str
        :rtype: str
        """"""
        t = set(T)
        t2 = set(S)
        from collections import Counter as ct
        c = ct(T)
        s = [char * c[char] for char in S if char in t]
        add = [char * c[char] for char in t - t2]
        return """".join(s + add)","auto customSortString(auto S, auto T) {
    """"""
    :type S: str
    :type T: str
    :rtype: str
    """"""
    t = set(T)
    t2 = set(S)
    from collections import Counter as ct
    c = ct(T)
    s = [char * c[char] for char in S if char in t]
    add = [char * c[char] for char in t - t2]
    return """".join(s + add)
}"
792.py,"def numMatchingSubseq(self, S, words):
        def check(s, i):
            for c in s:
                i = S.find(c, i) + 1
                if not i: return False
            return True
        return sum((check(word, 0) for word in words))","auto numMatchingSubseq(auto S, auto words) {
    def check(s, i):
    for c in s:
    i = S.find(c, i) + 1
    if not i: return False
    return True
    return sum((check(word, 0) for word in words))
}"
793.py,"def count(self, num):
        cnt = 0
        while num:
            cnt += num // 5
            num //= 5
        return cnt 
    
    def preimageSizeFZF(self, K):
        l, r = 0, 2 ** 63 - 1
        while l < r:
            mid = (l + r) // 2
            if self.count(mid) < K:
                l = mid + 1
            else:
                r = mid
        return 5 - (l % 5) if self.count(l) == K else 0","auto count(auto num) {
    cnt = 0
    while num:
    cnt += num // 5
    num //= 5
    return cnt
    
    def preimageSizeFZF(self, K):
    l, r = 0, 2 ** 63 - 1
    while l < r:
    mid = (l + r) // 2
    if self.count(mid) < K:
    l = mid + 1
    else:
    r = mid
    return 5 - (l % 5) if self.count(l) == K else 0
}"
795.py,"def numSubarrayBoundedMax(self, A, L, R):
        """"""
        :type A: List[int]
        :type L: int
        :type R: int
        :rtype: int
        """"""
        res, start, diff = 0, -1, 0
        for i in range (len(A)):
            if L <= A[i] <= R: diff, res = i - start, res + i - start
            elif A[i] > R: diff, start = 0, i
            else: res += diff
        return res","auto numSubarrayBoundedMax(auto A, auto L, auto R) {
    """"""
    :type A: List[int]
    :type L: int
    :type R: int
    :rtype: int
    """"""
    res, start, diff = 0, -1, 0
    for i in range (len(A)):
    if L <= A[i] <= R: diff, res = i - start, res + i - start
    elif A[i] > R: diff, start = 0, i
    else: res += diff
    return res
}"
797.py,"def allPathsSourceTarget(self, graph, i = 0, q = [0]):
        if i == 0: 
            global res
            res = []
        if i == len(graph) - 1: 
            res.append(q)
        for index in graph[i]: 
            self.allPathsSourceTarget(graph, index, q + [index])
        return res","auto allPathsSourceTarget(auto graph, auto i = 0, auto q = [0]) {
    if i == 0:
    global res
    res = []
    if i == len(graph) - 1:
    res.append(q)
    for index in graph[i]:
    self.allPathsSourceTarget(graph, index, q + [index])
    return res
}"
798.py,"def bestRotation(self, A):
        N = len(A)
        change = [1] * N
        for i in range(N): change[(i - A[i] + 1) % N] -= 1
        for i in range(1, N): change[i] += change[i - 1]
        return change.index(max(change))","auto bestRotation(auto A) {
    N = len(A)
    change = [1] * N
    for i in range(N): change[(i - A[i] + 1) % N] -= 1
    for i in range(1, N): change[i] += change[i - 1]
    return change.index(max(change))
}"
799.py,"def champagneTower(self, poured, query_row, query_glass):
        """"""
        :type poured: int
        :type query_row: int
        :type query_glass: int
        :rtype: float
        """"""
        glasses=[[poured if i==0 and j==0 else 0 for i in range(j+1)] for j in range(query_row+1)]
        for i in range(1,len(glasses)):
            for j in range(len(glasses[i])):
                if j-1>=0 and glasses[i-1][j-1]>1: glasses[i][j]+=(glasses[i-1][j-1]-1)/2
                if j<=i-1 and glasses[i-1][j]>1: glasses[i][j]+=(glasses[i-1][j]-1)/2
        return glasses[query_row][query_glass] if glasses[query_row][query_glass]<=1 else 1","auto champagneTower(auto poured, auto query_row, auto query_glass) {
    """"""
    :type poured: int
    :type query_row: int
    :type query_glass: int
    :rtype: float
    """"""
    glasses=[[poured if i==0 and j==0 else 0 for i in range(j+1)] for j in range(query_row+1)]
    for i in range(1,len(glasses)):
    for j in range(len(glasses[i])):
    if j-1>=0 and glasses[i-1][j-1]>1: glasses[i][j]+=(glasses[i-1][j-1]-1)/2
    if j<=i-1 and glasses[i-1][j]>1: glasses[i][j]+=(glasses[i-1][j]-1)/2
    return glasses[query_row][query_glass] if glasses[query_row][query_glass]<=1 else 1
}"
8.py,"def myAtoi(self, str):
        r = [int(c) for c in re.findall(r""^[-+]?\u005Cd+"", str.lstrip())]
        return (r and 2 ** 31 - 1 < r[0] and 2 ** 31 - 1) or (r and r[0] < -2 ** 31 and -2 ** 31) or (r and r[0]) or 0","auto myAtoi(auto str) {
    r = [int(c) for c in re.findall(r""^[-+]?\u005Cd+"", str.lstrip())]
    return (r and 2 ** 31 - 1 < r[0] and 2 ** 31 - 1) or (r and r[0] < -2 ** 31 and -2 ** 31) or (r and r[0]) or 0
}"
80.py,"def removeDuplicates(self, nums: List[int]) -> int:
        i = 2
        for j in range(2, len(nums)):
            if nums[i - 2] != nums[j]:
                nums[i] = nums[j]
                i += 1
        return min(i, len(nums))","auto removeDuplicates(auto nums) {
    i = 2
    for j in range(2, len(nums)):
    if nums[i - 2] != nums[j]:
    nums[i] = nums[j]
    i += 1
    return min(i, len(nums))
}"
800.py,"def similarRGB(self, color):
        """"""
        :type color: str
        :rtype: str
        """"""
        import math
        num1, num2, num3 = int(color[1:3],16), int(color[3:5],16), int(color[5:7],16)
        letters = [""0"",""1"",""2"",""3"",""4"",""5"",""6"",""7"",""8"",""9"",""a"",""b"",""c"",""d"",""e"",""f""]
        min1, min2, min3, res = math.inf, math.inf, math.inf, [""#"","""","""",""""]
        for letter in letters:
            min1, min2, min3 = min(min1,(num1-int(letter*2,16))**2), min(min2,(num2-int(letter*2,16))**2), min(min3,(num3-int(letter*2,16))**2) 
            if min1 == (num1-int(letter*2,16))**2: res[1] = letter*2 
            if min2 == (num2-int(letter*2,16))**2: res[2] = letter*2 
            if min3 == (num3-int(letter*2,16))**2: res[3] = letter*2
        return """".join(res)","auto similarRGB(auto color) {
    """"""
    :type color: str
    :rtype: str
    """"""
    import math
    num1, num2, num3 = int(color[1:3],16), int(color[3:5],16), int(color[5:7],16)
    letters = [""0"",""1"",""2"",""3"",""4"",""5"",""6"",""7"",""8"",""9"",""a"",""b"",""c"",""d"",""e"",""f""]
    min1, min2, min3, res = math.inf, math.inf, math.inf, [""#"","""","""",""""]
    for letter in letters:
    min1, min2, min3 = min(min1,(num1-int(letter*2,16))**2), min(min2,(num2-int(letter*2,16))**2), min(min3,(num3-int(letter*2,16))**2)
    if min1 == (num1-int(letter*2,16))**2: res[1] = letter*2
    if min2 == (num2-int(letter*2,16))**2: res[2] = letter*2
    if min3 == (num3-int(letter*2,16))**2: res[3] = letter*2
    return """".join(res)
}"
802.py,"def eventualSafeNodes(self, graph):
        def explore(i):
            visited[i] = 0
            for v in graph[i]:
                if visited[v] == 0 or (visited[v] == -1 and explore(v)): return True
            visited[i] = 1
            res.append(i)
            return False
        visited, res = [-1] * len(graph), []
        for i in range(len(graph)):
            if visited[i] == -1: explore(i)
        return sorted(res)","auto eventualSafeNodes(auto graph) {
    def explore(i):
    visited[i] = 0
    for v in graph[i]:
    if visited[v] == 0 or (visited[v] == -1 and explore(v)): return True
    visited[i] = 1
    res.append(i)
    return False
    visited, res = [-1] * len(graph), []
    for i in range(len(graph)):
    if visited[i] == -1: explore(i)
    return sorted(res)
}"
803.py,"def hitBricks(self, grid, hits):
        m, n, ret = len(grid), len(grid[0]), [0]*len(hits)
        # Connect unconnected bricks and 
        def dfs(i, j):
            if not (0 <= i <m and 0 <= j <n) or grid[i][j] != 1:
                return 0
            grid[i][j] = 2
            return 1 + sum(dfs(x, y) for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)))
        # Check whether (i, j) is connected to Not Falling Bricks
        def is_connected(i, j):
            return not i or any(0 <= x < m and 0 <= y < n and grid[x][y] == 2 for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)))
        # Mark whether there is a brick at the each hit
        for i, j in hits:
            grid[i][j] -= 1      
        # Get grid after all hits
        for i in range(n):
            dfs(0, i)
        # Reversely add the block of each hits and get count of newly add bricks
        for k in reversed(range(len(hits))):
            i, j = hits[k]
            grid[i][j] += 1
            if grid[i][j] and is_connected(i, j):
                ret[k] = dfs(i, j) - 1
        return ret","auto hitBricks(auto grid, auto hits) {
    m, n, ret = len(grid), len(grid[0]), [0]*len(hits)
    # Connect unconnected bricks and
    def dfs(i, j):
    if not (0 <= i <m and 0 <= j <n) or grid[i][j] != 1:
    return 0
    grid[i][j] = 2
    return 1 + sum(dfs(x, y) for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)))
    # Check whether (i, j) is connected to Not Falling Bricks
    def is_connected(i, j):
    return not i or any(0 <= x < m and 0 <= y < n and grid[x][y] == 2 for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)))
    # Mark whether there is a brick at the each hit
    for i, j in hits:
    grid[i][j] -= 1
    # Get grid after all hits
    for i in range(n):
    dfs(0, i)
    # Reversely add the block of each hits and get count of newly add bricks
    for k in reversed(range(len(hits))):
    i, j = hits[k]
    grid[i][j] += 1
    if grid[i][j] and is_connected(i, j):
    ret[k] = dfs(i, j) - 1
    return ret
}"
804.py,"def uniqueMorseRepresentations(self, words):
        """"""
        :type words: List[str]
        :rtype: int
        """"""
        dic=set()
        letters=["".-"",""-..."",""-.-."",""-.."",""."",""..-."",""--."",""...."","".."","".---"",""-.-"","".-.."",""--"",""-."",""---"","".--."",""--.-"","".-."",""..."",""-"",""..-"",""...-"","".--"",""-..-"",""-.--"",""--..""]
        for word in words:
            code=[]
            for letter in word: code.append(letters[ord(letter)-ord(""a"")])
            code= """".join(code)
            if not code in dic: dic.add(code)
        return len(dic)","auto uniqueMorseRepresentations(auto words) {
    """"""
    :type words: List[str]
    :rtype: int
    """"""
    dic=set()
    letters=["".-"",""-..."",""-.-."",""-.."",""."",""..-."",""--."",""...."","".."","".---"",""-.-"","".-.."",""--"",""-."",""---"","".--."",""--.-"","".-."",""..."",""-"",""..-"",""...-"","".--"",""-..-"",""-.--"",""--..""]
    for word in words:
    code=[]
    for letter in word: code.append(letters[ord(letter)-ord(""a"")])
    code= """".join(code)
    if not code in dic: dic.add(code)
    return len(dic)
}"
805.py,"def splitArraySameAverage(self, A):
        def find(target, k, i):
            if (target,k) in not_found and not_found[(target,k)] <= i: return False
            if k == 0: return target == 0
            if k + i > len(A): return False
            res = find(target - A[i], k - 1, i + 1) or find(target, k, i + 1)
            if not res: not_found[(target, k)] = min(not_found.get((target, k), n), i)
            return res
        not_found = dict()
        n, s = len(A), sum(A)
        return any(find(s * i / n, i, 0) for i in range(1, n // 2 + 1) if s * i % n == 0)","auto splitArraySameAverage(auto A) {
    def find(target, k, i):
    if (target,k) in not_found and not_found[(target,k)] <= i: return False
    if k == 0: return target == 0
    if k + i > len(A): return False
    res = find(target - A[i], k - 1, i + 1) or find(target, k, i + 1)
    if not res: not_found[(target, k)] = min(not_found.get((target, k), n), i)
    return res
    not_found = dict()
    n, s = len(A), sum(A)
    return any(find(s * i / n, i, 0) for i in range(1, n // 2 + 1) if s * i % n == 0)
}"
807.py,"def maxIncreaseKeepingSkyline(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: int
        """"""
        n=len(grid)
        m=len(grid[0])
        mx_i = [max(grid[i]) for i in range(n)]
        mx_j=[-float(""inf"")]*m
        for i in range(n): 
            for j in range(m): mx_j[j]=max(mx_j[j],grid[i][j])
        res=0
        for i in range(n):
            for j in range(m):
                prev=grid[i][j]
                grid[i][j]=min(mx_i[i],mx_j[j])
                res+=grid[i][j]-prev
        return res","auto maxIncreaseKeepingSkyline(auto grid) {
    """"""
    :type grid: List[List[int]]
    :rtype: int
    """"""
    n=len(grid)
    m=len(grid[0])
    mx_i = [max(grid[i]) for i in range(n)]
    mx_j=[-float(""inf"")]*m
    for i in range(n):
    for j in range(m): mx_j[j]=max(mx_j[j],grid[i][j])
    res=0
    for i in range(n):
    for j in range(m):
    prev=grid[i][j]
    grid[i][j]=min(mx_i[i],mx_j[j])
    res+=grid[i][j]-prev
    return res
}"
808.py,"def soupServings(self, N):
        visited = {}
        def dfs(a, b):
            if (a, b) in visited: return visited[(a, b)]
            elif a <= 0 or b <= 0: return (a < b and 1) or (a == b and 0.5) or (b < a and 0)
            visited[(a, b)] = 0.25 * (dfs(a - 100, b) + dfs(a - 75, b - 25) + dfs(a - 50, b -50) + dfs(a - 25, b - 75))
            return visited[(a, b)] 
        return N > 4800 and 1 or round(dfs(N, N), 5)","auto soupServings(auto N) {
    visited = {}
    def dfs(a, b):
    if (a, b) in visited: return visited[(a, b)]
    elif a <= 0 or b <= 0: return (a < b and 1) or (a == b and 0.5) or (b < a and 0)
    visited[(a, b)] = 0.25 * (dfs(a - 100, b) + dfs(a - 75, b - 25) + dfs(a - 50, b -50) + dfs(a - 25, b - 75))
    return visited[(a, b)]
    return N > 4800 and 1 or round(dfs(N, N), 5)
}"
809.py,"def expressiveWords(self, S, words):
        if not S: return 0
        guide, i, j, res = [], 0, 0, 0
        while i < len(S):
            while j + 1 <len(S) and S[j + 1] == S[j]: j += 1
            guide.append((S[i], j - i + 1))
            i = j = j + 1
        for word in words:
            i = j = g = 0
            while i < len(word):
                while j + 1 < len(word) and word[j + 1] == word[j]: j += 1
                if guide[g][0] != word[i] or (guide[g][1] == 2 and j - i + 1 == 1) or guide[g][1] < j - i + 1: break
                i, j, g = j + 1, j + 1, g + 1
            if g == len(guide): res += 1
        return res","auto expressiveWords(auto S, auto words) {
    if not S: return 0
    guide, i, j, res = [], 0, 0, 0
    while i < len(S):
    while j + 1 <len(S) and S[j + 1] == S[j]: j += 1
    guide.append((S[i], j - i + 1))
    i = j = j + 1
    for word in words:
    i = j = g = 0
    while i < len(word):
    while j + 1 < len(word) and word[j + 1] == word[j]: j += 1
    if guide[g][0] != word[i] or (guide[g][1] == 2 and j - i + 1 == 1) or guide[g][1] < j - i + 1: break
    i, j, g = j + 1, j + 1, g + 1
    if g == len(guide): res += 1
    return res
}"
81.py,"def search(self, nums, target):
        l, r, n = 0, len(nums) - 1, len(nums)
        while l <= r:
            while l + 1 < n and nums[l + 1] == nums[l]: 
                l += 1
            while r > 0 and nums[r] == nums[r - 1]: 
                r -= 1
            mid = (l + r) // 2
            if nums[mid] == target: 
                return True
            elif sum((target < nums[l], nums[l] <= nums[mid], nums[mid] < target)) == 2: 
                l = mid + 1
            else: 
                r = mid - 1
        return False","auto search(auto nums, auto target) {
    l, r, n = 0, len(nums) - 1, len(nums)
    while l <= r:
    while l + 1 < n and nums[l + 1] == nums[l]:
    l += 1
    while r > 0 and nums[r] == nums[r - 1]:
    r -= 1
    mid = (l + r) // 2
    if nums[mid] == target:
    return True
    elif sum((target < nums[l], nums[l] <= nums[mid], nums[mid] < target)) == 2:
    l = mid + 1
    else:
    r = mid - 1
    return False
}"
810.py,"def xorGame(self, nums):
        xor = 0
        for i in nums: xor ^= i
        return xor == 0 or len(nums) % 2 == 0","auto xorGame(auto nums) {
    xor = 0
    for i in nums: xor ^= i
    return xor == 0 or len(nums) % 2 == 0
}"
811.py,"def subdomainVisits(self, cpdomains):
        counter = collections.Counter()
        for cpdomain in cpdomains:
            count, *domains = cpdomain.replace("" "",""."").split(""."")
            for i in range(len(domains)):
                counter[""."".join(domains[i:])] += int(count)
        return ["" "".join((str(v), k)) for k, v in counter.items()]","auto subdomainVisits(auto cpdomains) {
    counter = collections.Counter()
    for cpdomain in cpdomains:
    count, *domains = cpdomain.replace("" "",""."").split(""."")
    for i in range(len(domains)):
    counter[""."".join(domains[i:])] += int(count)
    return ["" "".join((str(v), k)) for k, v in counter.items()]
}"
812.py,"def largestTriangleArea(self, p):
        """"""
        :type points: List[List[int]]
        :rtype: float
        """"""
        from itertools import combinations as cb
        def f(p1, p2, p3):
            (x1, y1), (x2, y2), (x3, y3) = p1,p2,p3
            return 0.5 * abs(x2 * y3 + x1 * y2 + x3 * y1 - x3 * y2 - x2 * y1 - x1 * y3)
        return max(f(a, b, c) for a, b, c in cb(p, 3))","auto largestTriangleArea(auto p) {
    """"""
    :type points: List[List[int]]
    :rtype: float
    """"""
    from itertools import combinations as cb
    def f(p1, p2, p3):
    (x1, y1), (x2, y2), (x3, y3) = p1,p2,p3
    return 0.5 * abs(x2 * y3 + x1 * y2 + x3 * y1 - x3 * y2 - x2 * y1 - x1 * y3)
    return max(f(a, b, c) for a, b, c in cb(p, 3))
}"
813.py,"def largestSumOfAverages(self, A, K):
        memo = {}
        def search(n, k):
            if n < k: return 0
            if (n, k) not in memo:
                if k == 1: memo[n, k] = sum(A[:n]) / float(n)
                else:
                    cur = memo[n, k] = 0
                    for i in range(n - 1, 0, -1):
                        cur += A[i]
                        memo[n, k] = max(memo[n, k], search(i, k - 1) + cur / float(n - i))
            return memo[n, k]
        return search(len(A), K)","auto largestSumOfAverages(auto A, auto K) {
    memo = {}
    def search(n, k):
    if n < k: return 0
    if (n, k) not in memo:
    if k == 1: memo[n, k] = sum(A[:n]) / float(n)
    else:
    cur = memo[n, k] = 0
    for i in range(n - 1, 0, -1):
    cur += A[i]
    memo[n, k] = max(memo[n, k], search(i, k - 1) + cur / float(n - i))
    return memo[n, k]
    return search(len(A), K)
}"
815.py,"def numBusesToDestination(self, routes, starterBus, targetBus):
        path, travel, travelTaken, used = collections.defaultdict(set), [starterBus], 0, set()
        for i, route in enumerate(routes):
            for bus in route:
                path[bus].add(i)
        while travel:
            new = []
            for bus in travel:
                if bus == targetBus:
                    return travelTaken
                for route in path[bus]:
                    if route not in used:
                        used.add(route)
                        for nextBus in routes[route]:
                            if nextBus != bus:
                                new.append(nextBus)
            travelTaken += 1
            travel = new
        return -1","auto numBusesToDestination(auto routes, auto starterBus, auto targetBus) {
    path, travel, travelTaken, used = collections.defaultdict(set), [starterBus], 0, set()
    for i, route in enumerate(routes):
    for bus in route:
    path[bus].add(i)
    while travel:
    new = []
    for bus in travel:
    if bus == targetBus:
    return travelTaken
    for route in path[bus]:
    if route not in used:
    used.add(route)
    for nextBus in routes[route]:
    if nextBus != bus:
    new.append(nextBus)
    travelTaken += 1
    travel = new
    return -1
}"
816.py,"def ambiguousCoordinates(self, S):
        def properInt(s):
            return len(s) > 1 and s[0] != ""0"" or len(s) == 1
        
        def properFloat(s, i):
            return s[-1] not in "".0"" and properInt(s[:i])
        
        s, res = S[1:-1], set()
        for i in range(len(s)):
            n1, n2 = s[:i + 1], s[i + 1:]
            p1, p2 = properInt(n1), properInt(n2)
            if p1 and p2:
                res.add(""({}, {})"".format(n1, n2))
            for j in range(len(n1)):
                for k in range(len(n2)):
                    n1f = n1[:j + 1] + ""."" + n1[j + 1:]
                    n2f = n2[:k + 1] + ""."" + n2[k + 1:]
                    p1f = properFloat(n1f, j + 1)
                    p2f = properFloat(n2f, k + 1)
                    if p1f and p2f:
                        res.add(""({}, {})"".format(n1f, n2f))
                    if p1f and p2:
                        res.add(""({}, {})"".format(n1f, n2))
                    if p1 and p2f:
                        res.add(""({}, {})"".format(n1, n2f))
        return list(res)","auto ambiguousCoordinates(auto S) {
    def properInt(s):
    return len(s) > 1 and s[0] != ""0"" or len(s) == 1
    
    def properFloat(s, i):
    return s[-1] not in "".0"" and properInt(s[:i])
    
    s, res = S[1:-1], set()
    for i in range(len(s)):
    n1, n2 = s[:i + 1], s[i + 1:]
    p1, p2 = properInt(n1), properInt(n2)
    if p1 and p2:
    res.add(""({}, {})"".format(n1, n2))
    for j in range(len(n1)):
    for k in range(len(n2)):
    n1f = n1[:j + 1] + ""."" + n1[j + 1:]
    n2f = n2[:k + 1] + ""."" + n2[k + 1:]
    p1f = properFloat(n1f, j + 1)
    p2f = properFloat(n2f, k + 1)
    if p1f and p2f:
    res.add(""({}, {})"".format(n1f, n2f))
    if p1f and p2:
    res.add(""({}, {})"".format(n1f, n2))
    if p1 and p2f:
    res.add(""({}, {})"".format(n1, n2f))
    return list(res)
}"
818.py,"def racecar(self, target):
        q, cnt, used = [(0, 1)], 0, {(0, 1)}
        while q:
            new = []
            for pos, speed in q:
                if pos == target:
                    return cnt
                elif pos > 20000 or -20000 > pos:
                    continue
                if (pos + speed, speed * 2) not in used:
                    new.append((pos + speed, speed * 2))
                    used.add((pos + speed, speed * 2))
                if speed > 0 and (pos, -1) not in used:
                    new.append((pos, -1))
                    used.add((pos, -1))
                elif speed < 0 and (pos, 1) not in used:
                    new.append((pos, 1))
                    used.add((pos, 1))
            q = new
            cnt += 1","auto racecar(auto target) {
    q, cnt, used = [(0, 1)], 0, {(0, 1)}
    while q:
    new = []
    for pos, speed in q:
    if pos == target:
    return cnt
    elif pos > 20000 or -20000 > pos:
    continue
    if (pos + speed, speed * 2) not in used:
    new.append((pos + speed, speed * 2))
    used.add((pos + speed, speed * 2))
    if speed > 0 and (pos, -1) not in used:
    new.append((pos, -1))
    used.add((pos, -1))
    elif speed < 0 and (pos, 1) not in used:
    new.append((pos, 1))
    used.add((pos, 1))
    q = new
    cnt += 1
}"
819.py,"def mostCommonWord(self, paragraph, banned):
        """"""
        :type paragraph: str
        :type banned: List[str]
        :rtype: str
        """"""
        paragraph = re.findall(r""\u005Cw+"", paragraph)
        dic = {}
        mx = [0, 0]
        for char in paragraph:
            char = char.lower()
            if char not in banned:
                if char not in dic: dic[char] = 1
                else: dic[char] += 1
                mx[0] = max(mx[0], dic[char])
                if mx[0] == dic[char]: mx[1] = char
        return mx[1]
        ","auto mostCommonWord(auto paragraph, auto banned) {
    """"""
    :type paragraph: str
    :type banned: List[str]
    :rtype: str
    """"""
    paragraph = re.findall(r""\u005Cw+"", paragraph)
    dic = {}
    mx = [0, 0]
    for char in paragraph:
    char = char.lower()
    if char not in banned:
    if char not in dic: dic[char] = 1
    else: dic[char] += 1
    mx[0] = max(mx[0], dic[char])
    if mx[0] == dic[char]: mx[1] = char
    return mx[1]
}"
820.py,"def minimumLengthEncoding(self, words):
        """"""
        :type words: List[str]
        :rtype: int
        """"""
        s = set(words)
        for word in words: 
            for i in range(1, len(word)): s.discard(word[i:])
        return sum(len(w) + 1 for w in s)","auto minimumLengthEncoding(auto words) {
    """"""
    :type words: List[str]
    :rtype: int
    """"""
    s = set(words)
    for word in words:
    for i in range(1, len(word)): s.discard(word[i:])
    return sum(len(w) + 1 for w in s)
}"
821.py,"def shortestToChar(self, S, C):
        """"""
        :type S: str
        :type C: str
        :rtype: List[int]
        """"""
        char1, char2, diff1, diff2, res = False, False, 0, 0, [None]* len(S)
        for i in range(len(S)):
            if char1: res[i], diff1 = min(res[i], diff1 + 1) if res[i] else diff1 + 1, diff1 + 1
            if S[i] == C: diff1, res[i], char1 = 0, 0, True  
            if char2: res[len(S) - 1 - i], diff2 = min(res[len(S) - 1 - i], diff2 + 1) if res[len(S) - 1 - i] else diff2 + 1, diff2 + 1
            if S[len(S) - 1 - i] == C: diff2, res[len(S) - 1 - i], char2 = 0, 0, True
        return res","auto shortestToChar(auto S, auto C) {
    """"""
    :type S: str
    :type C: str
    :rtype: List[int]
    """"""
    char1, char2, diff1, diff2, res = False, False, 0, 0, [None]* len(S)
    for i in range(len(S)):
    if char1: res[i], diff1 = min(res[i], diff1 + 1) if res[i] else diff1 + 1, diff1 + 1
    if S[i] == C: diff1, res[i], char1 = 0, 0, True
    if char2: res[len(S) - 1 - i], diff2 = min(res[len(S) - 1 - i], diff2 + 1) if res[len(S) - 1 - i] else diff2 + 1, diff2 + 1
    if S[len(S) - 1 - i] == C: diff2, res[len(S) - 1 - i], char2 = 0, 0, True
    return res
}"
822.py,"def flipgame(self, fronts, backs):
        """"""
        :type fronts: List[int]
        :type backs: List[int]
        :rtype: int
        """"""
        return min((set(fronts) | set(backs)) - set(fronts[i] for i in range(len(fronts)) if fronts[i] == backs[i]), default = 0)","auto flipgame(auto fronts, auto backs) {
    """"""
    :type fronts: List[int]
    :type backs: List[int]
    :rtype: int
    """"""
    return min((set(fronts) | set(backs)) - set(fronts[i] for i in range(len(fronts)) if fronts[i] == backs[i]), default = 0)
}"
823.py,"def numFactoredBinaryTrees(self, A):
        """"""
        :type A: List[int]
        :rtype: int
        """"""
        A.sort()
        nums, res, trees, factors = set(A), 0, {}, collections.defaultdict(set)
        for i, num in enumerate(A):
            for n in A[:i]:
                if num % n == 0 and num // n in nums: factors[num].add(n)
        for root in A:
            trees[root] = 1
            for fac in factors[root]: trees[root] += trees[fac] * trees[root // fac]
        return sum(trees.values()) % ((10 ** 9) + 7)","auto numFactoredBinaryTrees(auto A) {
    """"""
    :type A: List[int]
    :rtype: int
    """"""
    A.sort()
    nums, res, trees, factors = set(A), 0, {}, collections.defaultdict(set)
    for i, num in enumerate(A):
    for n in A[:i]:
    if num % n == 0 and num // n in nums: factors[num].add(n)
    for root in A:
    trees[root] = 1
    for fac in factors[root]: trees[root] += trees[fac] * trees[root // fac]
    return sum(trees.values()) % ((10 ** 9) + 7)
}"
824.py,"def toGoatLatin(self, S):
        s, vowels = S.split(), {""a"", ""e"", ""i"", ""o"", ""u""} 
        return "" "".join([(s[i][0].lower() in vowels and s[i] or s[i][1:] + s[i][0]) + ""m"" + ""a"" * (i + 2) for i in range(len(s))])","auto toGoatLatin(auto S) {
    s, vowels = S.split(), {""a"", ""e"", ""i"", ""o"", ""u""}
    return "" "".join([(s[i][0].lower() in vowels and s[i] or s[i][1:] + s[i][0]) + ""m"" + ""a"" * (i + 2) for i in range(len(s))])
}"
825.py,"def numFriendRequests(self, ages):
        """"""
        :type ages: List[int]
        :rtype: int
        """"""
        cntr, res = collections.Counter(ages), 0
        for A in cntr:
            for B in cntr:
                if B <= 0.5 * A + 7 or B > A: continue
                if A == B: res += cntr[A]  *(cntr[A] - 1)
                else: res += cntr[A] * cntr[B]
        return res","auto numFriendRequests(auto ages) {
    """"""
    :type ages: List[int]
    :rtype: int
    """"""
    cntr, res = collections.Counter(ages), 0
    for A in cntr:
    for B in cntr:
    if B <= 0.5 * A + 7 or B > A: continue
    if A == B: res += cntr[A]  *(cntr[A] - 1)
    else: res += cntr[A] * cntr[B]
    return res
}"
826.py,"def maxProfitAssignment(self, difficulty, profit, worker):
        """"""
        :type difficulty: List[int]
        :type profit: List[int]
        :type worker: List[int]
        :rtype: int
        """"""
        jobs = sorted([a, b] for a, b in zip(difficulty, profit))
        res = i = maxp = 0
        for ability in sorted(worker):
            while i < len(jobs) and ability >= jobs[i][0]:
                maxp = max(jobs[i][1], maxp)
                i += 1
            res += maxp
        return res      ","auto maxProfitAssignment(auto difficulty, auto profit, auto worker) {
    """"""
    :type difficulty: List[int]
    :type profit: List[int]
    :type worker: List[int]
    :rtype: int
    """"""
    jobs = sorted([a, b] for a, b in zip(difficulty, profit))
    res = i = maxp = 0
    for ability in sorted(worker):
    while i < len(jobs) and ability >= jobs[i][0]:
    maxp = max(jobs[i][1], maxp)
    i += 1
    res += maxp
    return res
}"
827.py,"def largestIsland(self, grid):
        def explore(i, j):
            dic[(i, j)], count[curr] = curr, count[curr] + 1
            if i > 0 and grid[i - 1][j] == 1 and (i - 1, j) not in dic: explore(i - 1, j)
            if j > 0 and grid[i][j - 1] == 1 and (i, j - 1) not in dic: explore(i, j - 1)
            if i + 1 < len(grid) and grid[i + 1][j] ==1 and (i + 1, j) not in dic: explore(i + 1, j)
            if j + 1 < len(grid) and grid[i][j + 1] == 1 and (i, j + 1) not in dic: explore(i, j + 1)
        def neighbours(i, j, adj):
            if i > 0 and grid[i - 1][j] == 1 and dic[(i - 1, j)] not in adj: adj.add(dic[(i - 1, j)])
            if j > 0 and grid[i][j - 1] == 1 and dic[(i, j - 1)] not in adj: adj.add(dic[(i, j - 1)])
            if i + 1 < len(grid) and grid[i + 1][j] ==1 and dic[(i + 1, j)] not in adj: adj.add(dic[(i + 1, j)])
            if j + 1 < len(grid) and grid[i][j + 1] == 1 and dic[(i, j + 1)] not in adj: adj.add(dic[(i, j + 1)])
            return adj
        curr, dic, count, res = 0, {}, collections.defaultdict(int), 0
        for i in range(len(grid)):
            for j in range(len(grid)):
                if grid[i][j] == 1 and (i, j) not in dic: curr += 1; explore(i, j)
        for i in range(len(grid)):
            for j in range(len(grid)):
                if grid[i][j] == 1: res = max(res, count[dic[(i, j)]])
                else: res = max(res, sum(count[r] for r in neighbours(i, j, set())) + 1)
        return res","auto largestIsland(auto grid) {
    def explore(i, j):
    dic[(i, j)], count[curr] = curr, count[curr] + 1
    if i > 0 and grid[i - 1][j] == 1 and (i - 1, j) not in dic: explore(i - 1, j)
    if j > 0 and grid[i][j - 1] == 1 and (i, j - 1) not in dic: explore(i, j - 1)
    if i + 1 < len(grid) and grid[i + 1][j] ==1 and (i + 1, j) not in dic: explore(i + 1, j)
    if j + 1 < len(grid) and grid[i][j + 1] == 1 and (i, j + 1) not in dic: explore(i, j + 1)
    def neighbours(i, j, adj):
    if i > 0 and grid[i - 1][j] == 1 and dic[(i - 1, j)] not in adj: adj.add(dic[(i - 1, j)])
    if j > 0 and grid[i][j - 1] == 1 and dic[(i, j - 1)] not in adj: adj.add(dic[(i, j - 1)])
    if i + 1 < len(grid) and grid[i + 1][j] ==1 and dic[(i + 1, j)] not in adj: adj.add(dic[(i + 1, j)])
    if j + 1 < len(grid) and grid[i][j + 1] == 1 and dic[(i, j + 1)] not in adj: adj.add(dic[(i, j + 1)])
    return adj
    curr, dic, count, res = 0, {}, collections.defaultdict(int), 0
    for i in range(len(grid)):
    for j in range(len(grid)):
    if grid[i][j] == 1 and (i, j) not in dic: curr += 1; explore(i, j)
    for i in range(len(grid)):
    for j in range(len(grid)):
    if grid[i][j] == 1: res = max(res, count[dic[(i, j)]])
    else: res = max(res, sum(count[r] for r in neighbours(i, j, set())) + 1)
    return res
}"
828.py,"def uniqueLetterString(self, S):
        index = {c: [-1, -1] for c in string.ascii_uppercase}
        res = 0
        for i, c in enumerate(S):
            k, j = index[c]
            res += (i - j) * (j - k)
            index[c] = [j, i]
        for c in index:
            k, j = index[c]
            res += (len(S) - j) * (j - k)
        return res % (10**9 + 7)","auto uniqueLetterString(auto S) {
    index = {c: [-1, -1] for c in string.ascii_uppercase}
    res = 0
    for i, c in enumerate(S):
    k, j = index[c]
    res += (i - j) * (j - k)
    index[c] = [j, i]
    for c in index:
    k, j = index[c]
    res += (len(S) - j) * (j - k)
    return res % (10**9 + 7)
}"
829.py,"def consecutiveNumbersSum(self, N):
        cnt=0
        for d in range(1, N+1):
            diff=d*(d-1)//2
            nd = N - diff
            if nd<=0: break
            if nd%d==0:
                cnt+=1
        return cnt","auto consecutiveNumbersSum(auto N) {
    cnt=0
    for d in range(1, N+1):
    diff=d*(d-1)//2
    nd = N - diff
    if nd<=0: break
    if nd%d==0:
    cnt+=1
    return cnt
}"
83.py,"def deleteDuplicates(self, head):
        cur = root = head
        while head:
            if head.val != cur.val:
                cur.next = cur = head
            head = cur.next = head.next
        return root","auto deleteDuplicates(auto head) {
    cur = root = head
    while head:
    if head.val != cur.val:
    cur.next = cur = head
    head = cur.next = head.next
    return root
}"
830.py,"def largeGroupPositions(self, S):
        res = []
        l = r = 0
        for i in range(1, len(S)):
            if S[i] == S[i - 1]: r += 1
            if r - l >= 2 and (S[i] != S[i - 1] or i == len(S) - 1): res.append([l, r])
            if S[i] != S[i - 1]: l = r = i
        return res","auto largeGroupPositions(auto S) {
    res = []
    l = r = 0
    for i in range(1, len(S)):
    if S[i] == S[i - 1]: r += 1
    if r - l >= 2 and (S[i] != S[i - 1] or i == len(S) - 1): res.append([l, r])
    if S[i] != S[i - 1]: l = r = i
    return res
}"
831.py,"def maskPII(self, S):
        if ""@"" in S:
            s = S.lower().split(""@"")
            return s[0][0] + ""*"" * 5 + s[0][-1] + ""@"" + s[1]
        else:
            nums, tmp = {""0"",""1"",""2"",""3"",""4"",""5"",""6"",""7"",""8"",""9""}, """"
            for c in S:
                if c in nums: tmp += c
            return ""+"" + ""*"" * (len(tmp) - 10) + ""-***-***-"" + tmp[-4:] if len(tmp) > 10 else ""***-***-"" + tmp[-4:]","auto maskPII(auto S) {
    if ""@"" in S:
    s = S.lower().split(""@"")
    return s[0][0] + ""*"" * 5 + s[0][-1] + ""@"" + s[1]
    else:
    nums, tmp = {""0"",""1"",""2"",""3"",""4"",""5"",""6"",""7"",""8"",""9""}, """"
    for c in S:
    if c in nums: tmp += c
    return ""+"" + ""*"" * (len(tmp) - 10) + ""-***-***-"" + tmp[-4:] if len(tmp) > 10 else ""***-***-"" + tmp[-4:]
}"
833.py,"def findReplaceString(self, s, indexes, sources, targets):
        res, dic, j = """", {}, 0
        for i in range(len(sources)):
            if s.find(sources[i], indexes[i]) == indexes[i]: dic[indexes[i]] = (sources[i], targets[i])
        while j < len(s):
            res += j in dic and dic[j][1] or s[j]
            j += j in dic and len(dic[j][0]) or 1
        return res","auto findReplaceString(auto s, auto indexes, auto sources, auto targets) {
    res, dic, j = """", {}, 0
    for i in range(len(sources)):
    if s.find(sources[i], indexes[i]) == indexes[i]: dic[indexes[i]] = (sources[i], targets[i])
    while j < len(s):
    res += j in dic and dic[j][1] or s[j]
    j += j in dic and len(dic[j][0]) or 1
    return res
}"
834.py,"def sumOfDistancesInTree(self, N, edges):
        tree = collections.defaultdict(set)
        res = [0] * N
        count = [1] * N
        for i, j in edges:
            tree[i].add(j)
            tree[j].add(i)

        def dfs(root, pre):
            for i in tree[root]:
                if i != pre:
                    dfs(i, root)
                    count[root] += count[i]
                    res[root] += res[i] + count[i]

        def dfs2(root, pre):
            for i in tree[root]:
                if i != pre:
                    res[i] = res[root] - count[i] + N - count[i]
                    dfs2(i, root)
        dfs(0, -1)
        dfs2(0, -1)
        return res","auto sumOfDistancesInTree(auto N, auto edges) {
    tree = collections.defaultdict(set)
    res = [0] * N
    count = [1] * N
    for i, j in edges:
    tree[i].add(j)
    tree[j].add(i)
    
    def dfs(root, pre):
    for i in tree[root]:
    if i != pre:
    dfs(i, root)
    count[root] += count[i]
    res[root] += res[i] + count[i]
    
    def dfs2(root, pre):
    for i in tree[root]:
    if i != pre:
    res[i] = res[root] - count[i] + N - count[i]
    dfs2(i, root)
    dfs(0, -1)
    dfs2(0, -1)
    return res
}"
835.py,"def largestOverlap(self, A, B):
        n, shift, rn = len(A), range(-1 * len(A) + 1, len(A)), range(len(A))
        return max(sum(A[i][j] and B[i + v][j + h] for i in rn for j in rn if 0 <= i + v < n > j + h >= 0) for h in shift for v in shift)   ","auto largestOverlap(auto A, auto B) {
    n, shift, rn = len(A), range(-1 * len(A) + 1, len(A)), range(len(A))
    return max(sum(A[i][j] and B[i + v][j + h] for i in rn for j in rn if 0 <= i + v < n > j + h >= 0) for h in shift for v in shift)
}"
836.py,"def isRectangleOverlap(self, rec1, rec2):
        x = (rec1[2] - rec1[0] + rec2[2] - rec2[0]) > (max(rec1[2], rec2[2]) - min(rec1[0], rec2[0]))
        y = (rec1[3] - rec1[1] + rec2[3] - rec2[1]) > (max(rec1[3], rec2[3]) - min(rec1[1], rec2[1]))
        return x and y","auto isRectangleOverlap(auto rec1, auto rec2) {
    x = (rec1[2] - rec1[0] + rec2[2] - rec2[0]) > (max(rec1[2], rec2[2]) - min(rec1[0], rec2[0]))
    y = (rec1[3] - rec1[1] + rec2[3] - rec2[1]) > (max(rec1[3], rec2[3]) - min(rec1[1], rec2[1]))
    return x and y
}"
837.py,"def new21Game(self, N, K, W):
        if K == 0 or N >= K + W: return 1
        dp = [1.0] + [0.0] * N
        Wsum, res = 1.0, 0.0
        for i in range(1, N + 1):
            dp[i] += Wsum / W
            if i < K: Wsum += dp[i]
            else: res += dp[i]
            if i - W >= 0: Wsum -= dp[i - W]
        return res","auto new21Game(auto N, auto K, auto W) {
    if K == 0 or N >= K + W: return 1
    dp = [1.0] + [0.0] * N
    Wsum, res = 1.0, 0.0
    for i in range(1, N + 1):
    dp[i] += Wsum / W
    if i < K: Wsum += dp[i]
    else: res += dp[i]
    if i - W >= 0: Wsum -= dp[i - W]
    return res
}"
838.py,"def pushDominoes(self, dominoes):
        res, l, r , pre_l, pre_r = """", {}, {}, None, None,
        for i, s in enumerate(dominoes):
            if s == ""."" and pre_r != None: r[i] = i - pre_r
            elif s == ""R"": pre_r = i
            elif s == ""L"": pre_r = None
        for i in range(len(dominoes) - 1, -1, -1):
            if dominoes[i] == ""."" and pre_l != None: l[i] = pre_l - i
            elif dominoes[i] == ""L"": pre_l = i
            elif dominoes[i] == ""R"": pre_l = None
        for i, s in enumerate(dominoes):
            if s == ""L"" or s == ""R"": res += s
            elif i in l and i in r:
                if l[i] < r[i]: res += ""L""
                elif r[i] < l[i]: res += ""R""
                else: res += s
            elif i in l: res += ""L""
            elif i in r: res += ""R""
            else: res += s
        return res","auto pushDominoes(auto dominoes) {
    res, l, r , pre_l, pre_r = """", {}, {}, None, None,
    for i, s in enumerate(dominoes):
    if s == ""."" and pre_r != None: r[i] = i - pre_r
    elif s == ""R"": pre_r = i
    elif s == ""L"": pre_r = None
    for i in range(len(dominoes) - 1, -1, -1):
    if dominoes[i] == ""."" and pre_l != None: l[i] = pre_l - i
    elif dominoes[i] == ""L"": pre_l = i
    elif dominoes[i] == ""R"": pre_l = None
    for i, s in enumerate(dominoes):
    if s == ""L"" or s == ""R"": res += s
    elif i in l and i in r:
    if l[i] < r[i]: res += ""L""
    elif r[i] < l[i]: res += ""R""
    else: res += s
    elif i in l: res += ""L""
    elif i in r: res += ""R""
    else: res += s
    return res
}"
839.py,"def numSimilarGroups(self, A):
        def explore(s):
            visited.add(s)
            for v in edges[s]:
                if v not in visited: explore(v)
        res, edges, visited = 0, {}, set()
        if len(A) >= 2 * len(A[0]):
            strs = set(A)
            for s in A:
                if s not in edges: edges[s] = set()
                for i in range(len(s) - 1):
                    for j in range(i + 1, len(s)):
                        new = s[:i] + s[j] + s[i + 1:j] + s[i] + s[j + 1:]
                        if new in strs:
                            edges[s].add(new)
                            if new in edges: edges[new].add(s)
                            else: edges[new] = {s}
        else:
            for s in A:
                if s not in edges: edges[s] = set()
                for t in A:
                    if s != t:
                        same = 0
                        for i, c in enumerate(t):
                            if c == s[i]: same += 1
                        if same == len(s) - 2: 
                            edges[s].add(t)
                            if t in edges: edges[t].add(s)
                            else: edges[t] = {s}
        for s in A:
            if s not in visited:
                res += 1
                explore(s)
        return res              ","auto numSimilarGroups(auto A) {
    def explore(s):
    visited.add(s)
    for v in edges[s]:
    if v not in visited: explore(v)
    res, edges, visited = 0, {}, set()
    if len(A) >= 2 * len(A[0]):
    strs = set(A)
    for s in A:
    if s not in edges: edges[s] = set()
    for i in range(len(s) - 1):
    for j in range(i + 1, len(s)):
    new = s[:i] + s[j] + s[i + 1:j] + s[i] + s[j + 1:]
    if new in strs:
    edges[s].add(new)
    if new in edges: edges[new].add(s)
    else: edges[new] = {s}
    else:
    for s in A:
    if s not in edges: edges[s] = set()
    for t in A:
    if s != t:
    same = 0
    for i, c in enumerate(t):
    if c == s[i]: same += 1
    if same == len(s) - 2:
    edges[s].add(t)
    if t in edges: edges[t].add(s)
    else: edges[t] = {s}
    for s in A:
    if s not in visited:
    res += 1
    explore(s)
    return res
}"
84.py,"def largestRectangleArea(self, heights):
        heights.append(0)
        stack = [-1]
        ans = 0
        for i in range(len(heights)):
            while heights[i] < heights[stack[-1]]:
                h = heights[stack.pop()]
                w = i - stack[-1] - 1
                ans = max(ans, h * w)
            stack.append(i)
        heights.pop()
        return ans","auto largestRectangleArea(auto heights) {
    heights.append(0)
    stack = [-1]
    ans = 0
    for i in range(len(heights)):
    while heights[i] < heights[stack[-1]]:
    h = heights[stack.pop()]
    w = i - stack[-1] - 1
    ans = max(ans, h * w)
    stack.append(i)
    heights.pop()
    return ans
}"
840.py,"def numMagicSquaresInside(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: int
        """"""
        res = 0
        for i in range(len(grid)-2):
            for j in range(len(grid)-2):
                if sum(grid[i][j: j + 3]) == sum(grid[i + 1][j : j +3]) == sum(grid[i + 2][j:j + 3]) == sum(grid[k][j] for k in range(i, i + 3)) == sum(grid[k][j + 1] for k in range(i, i + 3)) == sum(grid[k][j + 2] for k in range(i, i + 3)) == (grid[i][j] + grid[i + 1][j + 1] + grid[i + 2][j + 2]) == (grid[i+2][j]+ grid[i + 1][j + 1] + grid[i][j + 2]): 
                    if set(grid[i][j: j + 3] + grid[i + 1][j: j +3] + grid[i + 2][j:j + 3]) == {1,2,3,4,5,6,7,8,9}: res += 1
        return res
                ","auto numMagicSquaresInside(auto grid) {
    """"""
    :type grid: List[List[int]]
    :rtype: int
    """"""
    res = 0
    for i in range(len(grid)-2):
    for j in range(len(grid)-2):
    if sum(grid[i][j: j + 3]) == sum(grid[i + 1][j : j +3]) == sum(grid[i + 2][j:j + 3]) == sum(grid[k][j] for k in range(i, i + 3)) == sum(grid[k][j + 1] for k in range(i, i + 3)) == sum(grid[k][j + 2] for k in range(i, i + 3)) == (grid[i][j] + grid[i + 1][j + 1] + grid[i + 2][j + 2]) == (grid[i+2][j]+ grid[i + 1][j + 1] + grid[i][j + 2]):
    if set(grid[i][j: j + 3] + grid[i + 1][j: j +3] + grid[i + 2][j:j + 3]) == {1,2,3,4,5,6,7,8,9}: res += 1
    return res
}"
841.py,"def canVisitAllRooms(self, rooms):
        pool, stack = set(range(len(rooms))), [0]
        while stack: 
            pool.discard(stack[-1])
            for nex in rooms[stack.pop()]:
                if nex in pool: 
                    stack.append(nex)
        return not pool","auto canVisitAllRooms(auto rooms) {
    pool, stack = set(range(len(rooms))), [0]
    while stack:
    pool.discard(stack[-1])
    for nex in rooms[stack.pop()]:
    if nex in pool:
    stack.append(nex)
    return not pool
}"
842.py,"def splitIntoFibonacci(self, S):
        def getStarter():
            arr = []
            for i in range(1, len(S) - 1):
                for j in range(i + 1, len(S)):
                    s1, s2 = S[:i], S[i:j]
                    if (s1[0] == ""0"" and len(s1) > 1) or (s2[0] == ""0"" and len(s2) > 1): 
                        continue
                    arr.append((int(s1), int(s2), j))
            return arr                 
        def dfs(arr, i):
            if i == len(S):
                return arr
            sm = arr[-2] + arr[-1]
            l = len(str(sm))
            new = int(S[i:i + l])
            return new == sm and 0 <= sm <= mx and dfs(arr + [new], i + l)
        q, mx = getStarter(), 2 ** 31 - 1
        for p1, p2, i in q:
            seq = dfs([p1, p2], i)
            if seq:
                return seq
        return []","auto splitIntoFibonacci(auto S) {
    def getStarter():
    arr = []
    for i in range(1, len(S) - 1):
    for j in range(i + 1, len(S)):
    s1, s2 = S[:i], S[i:j]
    if (s1[0] == ""0"" and len(s1) > 1) or (s2[0] == ""0"" and len(s2) > 1):
    continue
    arr.append((int(s1), int(s2), j))
    return arr
    def dfs(arr, i):
    if i == len(S):
    return arr
    sm = arr[-2] + arr[-1]
    l = len(str(sm))
    new = int(S[i:i + l])
    return new == sm and 0 <= sm <= mx and dfs(arr + [new], i + l)
    q, mx = getStarter(), 2 ** 31 - 1
    for p1, p2, i in q:
    seq = dfs([p1, p2], i)
    if seq:
    return seq
    return []
}"
844.py,"def backspaceCompare(self, S, T):
        def construct(s):
            new_s = []
            for c in s:
                if c == ""#"" and len(new_s) > 0:
                    new_s.pop()
                elif c != ""#"":
                    new_s.append(c)
            return new_s
        s, t = construct(S), construct(T)
        return s == t","auto backspaceCompare(auto S, auto T) {
    def construct(s):
    new_s = []
    for c in s:
    if c == ""#"" and len(new_s) > 0:
    new_s.pop()
    elif c != ""#"":
    new_s.append(c)
    return new_s
    s, t = construct(S), construct(T)
    return s == t
}"
845.py,"def longestMountain(self, A, res = 0):
        for i in range(1, len(A) - 1):
            if A[i + 1] < A[i] > A[i - 1]:
                l = r = i
                while l and A[l] > A[l - 1]: l -= 1
                while r + 1 < len(A) and A[r] > A[r + 1]: r += 1
                if r - l + 1 > res: res = r - l + 1
        return res","auto longestMountain(auto A, auto res = 0) {
    for i in range(1, len(A) - 1):
    if A[i + 1] < A[i] > A[i - 1]:
    l = r = i
    while l and A[l] > A[l - 1]: l -= 1
    while r + 1 < len(A) and A[r] > A[r + 1]: r += 1
    if r - l + 1 > res: res = r - l + 1
    return res
}"
846.py,"def isNStraightHand(self, hand, W):
        hand.sort()
        while hand:
            try:
                base = hand[0]
                for i in range(W):
                    hand.remove(base+i)
            except:
                return False
        return True","auto isNStraightHand(auto hand, auto W) {
    hand.sort()
    while hand:
    try:
    base = hand[0]
    for i in range(W):
    hand.remove(base+i)
    except:
    return False
    return True
}"
847.py,"def shortestPathLength(self, graph):
        memo, final, q = set(), (1 << len(graph)) - 1, collections.deque([(i, 0, 1 << i) for i in range(len(graph))])
        while q:
            node, steps, state = q.popleft()
            if state == final: return steps
            for v in graph[node]:
                if (state | 1 << v, v) not in memo:
                    q.append((v, steps + 1, state | 1 << v))
                    memo.add((state | 1 << v, v))","auto shortestPathLength(auto graph) {
    memo, final, q = set(), (1 << len(graph)) - 1, collections.deque([(i, 0, 1 << i) for i in range(len(graph))])
    while q:
    node, steps, state = q.popleft()
    if state == final: return steps
    for v in graph[node]:
    if (state | 1 << v, v) not in memo:
    q.append((v, steps + 1, state | 1 << v))
    memo.add((state | 1 << v, v))
}"
848.py,"def shiftingLetters(self, S, shifts):
        sm, res = sum(shift % 26 for shift in shifts) % 26, """"
        for i, s in enumerate(shifts):
            move, sm = ord(S[i]) + sm % 26, sm - s
            res += chr(move > 122 and move - 26 or move)
        return res","auto shiftingLetters(auto S, auto shifts) {
    sm, res = sum(shift % 26 for shift in shifts) % 26, """"
    for i, s in enumerate(shifts):
    move, sm = ord(S[i]) + sm % 26, sm - s
    res += chr(move > 122 and move - 26 or move)
    return res
}"
849.py,"def maxDistToClosest(self, seats):
        d = {}
        res = l = left = r = right = 0
        for i, s in enumerate(seats):
            if not s and left: d[i] = l = l + 1
            elif s: l, left = 0, 1
        for i in range(len(seats) - 1, -1, -1):
            if not seats[i] and right and (i not in d or d[i] > r): d[i] = r = r + 1 
            elif seats[i]: r, right = 0, 1
        return max(d.values())","auto maxDistToClosest(auto seats) {
    d = {}
    res = l = left = r = right = 0
    for i, s in enumerate(seats):
    if not s and left: d[i] = l = l + 1
    elif s: l, left = 0, 1
    for i in range(len(seats) - 1, -1, -1):
    if not seats[i] and right and (i not in d or d[i] > r): d[i] = r = r + 1
    elif seats[i]: r, right = 0, 1
    return max(d.values())
}"
85.py,"def maximalRectangle(self, matrix):
        res, m, n = 0, len(matrix), len(matrix and matrix[0])
        for i in range(m):
            for j in range(n):
                if matrix[i][j] != ""0"":
                    if j > 0 and matrix[i][j - 1] != ""0"":
                        matrix[i][j] = matrix[i][j - 1] + 1
                    else:
                        matrix[i][j] = 1
                    mn, sm, k = matrix[i][j], 0, i + 1
                    while k > 0 and matrix[k - 1][j] != ""0"":
                        if matrix[k - 1][j] < mn:
                            sm, mn = (i - k + 2) * matrix[k - 1][j], matrix[k - 1][j]
                        else:
                            sm += mn
                        if sm > res:
                            res = sm
                        k -= 1
        return res","auto maximalRectangle(auto matrix) {
    res, m, n = 0, len(matrix), len(matrix and matrix[0])
    for i in range(m):
    for j in range(n):
    if matrix[i][j] != ""0"":
    if j > 0 and matrix[i][j - 1] != ""0"":
    matrix[i][j] = matrix[i][j - 1] + 1
    else:
    matrix[i][j] = 1
    mn, sm, k = matrix[i][j], 0, i + 1
    while k > 0 and matrix[k - 1][j] != ""0"":
    if matrix[k - 1][j] < mn:
    sm, mn = (i - k + 2) * matrix[k - 1][j], matrix[k - 1][j]
    else:
    sm += mn
    if sm > res:
    res = sm
    k -= 1
    return res
}"
850.py,"def rectangleArea(self, rectangles):
        xs = sorted(set([x for x1, y1, x2, y2 in rectangles for x in [x1, x2]] + [0]))
        x_i = {v: i for i, v in enumerate(xs)}
        count = [0] * len(x_i)
        L = []
        for x1, y1, x2, y2 in rectangles:
            L.append([y1, x1, x2, 1])
            L.append([y2, x1, x2, -1])
        L.sort()
        cur_y = cur_x_sum = area = 0
        for y, x1, x2, sig in L:
            area += (y - cur_y) * cur_x_sum
            cur_y = y
            for i in range(x_i[x1], x_i[x2]):
                count[i] += sig
            cur_x_sum = sum(x2 - x1 if c else 0 for x1, x2, c in zip(xs, xs[1:], count))
        return area % (10 ** 9 + 7)","auto rectangleArea(auto rectangles) {
    xs = sorted(set([x for x1, y1, x2, y2 in rectangles for x in [x1, x2]] + [0]))
    x_i = {v: i for i, v in enumerate(xs)}
    count = [0] * len(x_i)
    L = []
    for x1, y1, x2, y2 in rectangles:
    L.append([y1, x1, x2, 1])
    L.append([y2, x1, x2, -1])
    L.sort()
    cur_y = cur_x_sum = area = 0
    for y, x1, x2, sig in L:
    area += (y - cur_y) * cur_x_sum
    cur_y = y
    for i in range(x_i[x1], x_i[x2]):
    count[i] += sig
    cur_x_sum = sum(x2 - x1 if c else 0 for x1, x2, c in zip(xs, xs[1:], count))
    return area % (10 ** 9 + 7)
}"
851.py,"def loudAndRich(self, richer, quiet):
        edges, memo, res = collections.defaultdict(list), {}, [i for i in range(len(quiet))]
        for r, p in richer: edges[p].append(r)
        def explore(i):
            if i in memo: return memo[i]
            cur_min = i
            for v in edges[i]:
                cur = explore(v)
                if quiet[cur] < quiet[cur_min]: cur_min = cur
            res[i] = memo[i] = cur_min
            return cur_min
        for i in range(len(quiet)): explore(i)
        return res","auto loudAndRich(auto richer, auto quiet) {
    edges, memo, res = collections.defaultdict(list), {}, [i for i in range(len(quiet))]
    for r, p in richer: edges[p].append(r)
    def explore(i):
    if i in memo: return memo[i]
    cur_min = i
    for v in edges[i]:
    cur = explore(v)
    if quiet[cur] < quiet[cur_min]: cur_min = cur
    res[i] = memo[i] = cur_min
    return cur_min
    for i in range(len(quiet)): explore(i)
    return res
}"
852.py,"def peakIndexInMountainArray(self, A):
        """"""
        :type A: List[int]
        :rtype: int
        """"""
        mx = max(A)
        return A.index(mx)","auto peakIndexInMountainArray(auto A) {
    """"""
    :type A: List[int]
    :rtype: int
    """"""
    mx = max(A)
    return A.index(mx)
}"
853.py,"def carFleet(self, target, position, speed):
        res, s = 0, {position[i]: speed[i] for i in range(len(position))}
        position.sort()
        while position:
            cur = position.pop()
            res += 1
            while position and (s[position[-1]] - s[cur]) * (target - cur) / s[cur] >= cur - position[-1]:
                position.pop()
        return res","auto carFleet(auto target, auto position, auto speed) {
    res, s = 0, {position[i]: speed[i] for i in range(len(position))}
    position.sort()
    while position:
    cur = position.pop()
    res += 1
    while position and (s[position[-1]] - s[cur]) * (target - cur) / s[cur] >= cur - position[-1]:
    position.pop()
    return res
}"
854.py,"def kSimilarity(self, A, B):
        b, n, k, stack = [c for c in B], len(A), float(""inf""), [(0, 0, [c for c in A])]
        while stack:
            i, cnt, s = stack.pop()
            while i < n and s[i] == b[i]:
                i += 1
            if i == n:
                if cnt < k:
                    k = cnt
            else:
                for j in range(i + 1, n):
                    if s[j] == b[i] and s[j] != b[j]:
                        ls = s[:]
                        ls[i], ls[j] = ls[j], ls[i]
                        stack.append((i + 1, cnt + 1, ls))
        return k","auto kSimilarity(auto A, auto B) {
    b, n, k, stack = [c for c in B], len(A), float(""inf""), [(0, 0, [c for c in A])]
    while stack:
    i, cnt, s = stack.pop()
    while i < n and s[i] == b[i]:
    i += 1
    if i == n:
    if cnt < k:
    k = cnt
    else:
    for j in range(i + 1, n):
    if s[j] == b[i] and s[j] != b[j]:
    ls = s[:]
    ls[i], ls[j] = ls[j], ls[i]
    stack.append((i + 1, cnt + 1, ls))
    return k
}"
856.py,"def scoreOfParentheses(self, S):
        stack, res = [], 0
        for c in S:
            if c == ""("":
                stack.append(0)
            else:
                add = 2 * stack.pop() or 1
                if stack:
                    stack[-1] += add
                else:
                    res += add
        return res","auto scoreOfParentheses(auto S) {
    stack, res = [], 0
    for c in S:
    if c == ""("":
    stack.append(0)
    else:
    add = 2 * stack.pop() or 1
    if stack:
    stack[-1] += add
    else:
    res += add
    return res
}"
857.py,"def mincostToHireWorkers(self, quality, wage, K):
        workers, res, heap, sumq = sorted((w / q, q, w) for q, w in zip(quality, wage)), float(""inf""), [], 0
        for ratio, q, w in workers:
            heapq.heappush(heap, -q)
            sumq += q
            if len(heap) > K:
                sumq += heapq.heappop(heap)
            if len(heap) == K:
                res = min(res, ratio * sumq)
        return res","auto mincostToHireWorkers(auto quality, auto wage, auto K) {
    workers, res, heap, sumq = sorted((w / q, q, w) for q, w in zip(quality, wage)), float(""inf""), [], 0
    for ratio, q, w in workers:
    heapq.heappush(heap, -q)
    sumq += q
    if len(heap) > K:
    sumq += heapq.heappop(heap)
    if len(heap) == K:
    res = min(res, ratio * sumq)
    return res
}"
858.py,"def mirrorReflection(self, p, q):
        side, up, h = 2, 1, 0
        while True:
            h += q * up
            side = (side + 1) % 2
            if side == 0:
                side += 2
            if h < 0:
                h *= -1
                up *= -1
            elif h > p:
                h = p - (h - p)
                up *= -1
            if h % p == 0:
                return h and side or 0","auto mirrorReflection(auto p, auto q) {
    side, up, h = 2, 1, 0
    while True:
    h += q * up
    side = (side + 1) % 2
    if side == 0:
    side += 2
    if h < 0:
    h *= -1
    up *= -1
    elif h > p:
    h = p - (h - p)
    up *= -1
    if h % p == 0:
    return h and side or 0
}"
859.py,"def buddyStrings(self, A, B):
        if len(A) != len(B):
            return False
        dif, dup = [[s1, B[i]] for i, s1 in enumerate(A) if s1 != B[i]], len(A) != len(set(A))
        return len(dif) == 2 and dif[0] == dif[1][::-1] or (not dif and dup)","auto buddyStrings(auto A, auto B) {
    if len(A) != len(B):
    return False
    dif, dup = [[s1, B[i]] for i, s1 in enumerate(A) if s1 != B[i]], len(A) != len(set(A))
    return len(dif) == 2 and dif[0] == dif[1][::-1] or (not dif and dup)
}"
86.py,"def partition(self, head, x):
        lessHead = less = ListNode(-1)
        greatHead = great = ListNode(-1)
        while head:
            if head.val < x:
                less.next = less = head
            else:
                great.next = great = head
            head = head.next
        less.next, great.next = greatHead.next, None
        return lessHead.next","auto partition(auto head, auto x) {
    lessHead = less = ListNode(-1)
    greatHead = great = ListNode(-1)
    while head:
    if head.val < x:
    less.next = less = head
    else:
    great.next = great = head
    head = head.next
    less.next, great.next = greatHead.next, None
    return lessHead.next
}"
860.py,"def lemonadeChange(self, bills):
        five = ten = 0
        for num in bills:
            if num == 5:
                five += 1
            elif num == 10 and five:
                ten += 1
                five -= 1
            elif num == 20 and five and ten:
                five -= 1
                ten -= 1
            elif num == 20 and five >= 3:
                five -= 3
            else:
                return False
        return True","auto lemonadeChange(auto bills) {
    five = ten = 0
    for num in bills:
    if num == 5:
    five += 1
    elif num == 10 and five:
    ten += 1
    five -= 1
    elif num == 20 and five and ten:
    five -= 1
    ten -= 1
    elif num == 20 and five >= 3:
    five -= 3
    else:
    return False
    return True
}"
861.py,"def matrixScore(self, A):
        for i, row in enumerate(A):
            if not row[0]:
                A[i] = [1 - num for num in row]
        m, n, sm = len(A), len(A and A[0]), 0
        for c in range(n):
            cnt = sum(A[r][c] for r in range(m))
            sm += max(cnt, m - cnt) * 2 ** (n - c - 1)
        return sm","auto matrixScore(auto A) {
    for i, row in enumerate(A):
    if not row[0]:
    A[i] = [1 - num for num in row]
    m, n, sm = len(A), len(A and A[0]), 0
    for c in range(n):
    cnt = sum(A[r][c] for r in range(m))
    sm += max(cnt, m - cnt) * 2 ** (n - c - 1)
    return sm
}"
862.py,"def shortestSubarray(self, A, K):
        heap, l, sm = [], float(""inf""), 0
        heapq.heappush(heap, (0, -1))
        for i, num in enumerate(A):
            sm += num
            dif = sm - K
            while heap and (heap[0][0] <= dif or i - heap[0][1] >= l):
                preSum, preIndex = heapq.heappop(heap)
                if i - preIndex < l:
                    l = i - preIndex
            heapq.heappush(heap, (sm, i))
        return l < float(""inf"") and l or -1","auto shortestSubarray(auto A, auto K) {
    heap, l, sm = [], float(""inf""), 0
    heapq.heappush(heap, (0, -1))
    for i, num in enumerate(A):
    sm += num
    dif = sm - K
    while heap and (heap[0][0] <= dif or i - heap[0][1] >= l):
    preSum, preIndex = heapq.heappop(heap)
    if i - preIndex < l:
    l = i - preIndex
    heapq.heappush(heap, (sm, i))
    return l < float(""inf"") and l or -1
}"
863.py,"def distanceK(self, root, target, K):
        adj, res, visited = collections.defaultdict(list), [], collections.defaultdict(int)
        def dfs(node):
            if node.left:
                adj[node].append(node.left)
                adj[node.left].append(node)
                dfs(node.left)
            if node.right:
                adj[node].append(node.right)
                adj[node.right].append(node)
                dfs(node.right)
        dfs(root)
        def dfs2(node, d):
            if d < K:
                visited[node] = 1
                for v in adj[node]:
                    if not visited[v]:
                        dfs2(v, d + 1)
                visited[node] = 0
            else:
                res.append(node.val)
        dfs2(target, 0)
        return res","auto distanceK(auto root, auto target, auto K) {
    adj, res, visited = collections.defaultdict(list), [], collections.defaultdict(int)
    def dfs(node):
    if node.left:
    adj[node].append(node.left)
    adj[node.left].append(node)
    dfs(node.left)
    if node.right:
    adj[node].append(node.right)
    adj[node.right].append(node)
    dfs(node.right)
    dfs(root)
    def dfs2(node, d):
    if d < K:
    visited[node] = 1
    for v in adj[node]:
    if not visited[v]:
    dfs2(v, d + 1)
    visited[node] = 0
    else:
    res.append(node.val)
    dfs2(target, 0)
    return res
}"
864.py,"def shortestPathAllKeys(self, grid):
        final, m, n, si, sj = 0, len(grid), len(grid[0]), 0, 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] in ""abcdef"":
                    final |= 1 << ord(grid[i][j]) - ord(""a"")
                elif grid[i][j] == ""@"":
                    si, sj = i, j
        q, memo = [(0, si, sj, 0)], set()
        while q:
            moves, i, j, state = heapq.heappop(q)
            if state == final: return moves
            for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
                if 0 <= x < m and 0 <= y < n and grid[x][y] != ""#"":
                    if grid[x][y].isupper() and not state & 1 << (ord(grid[x][y].lower()) - ord(""a"")): continue
                    newState = ord(grid[x][y]) >= ord(""a"") and state | 1 << (ord(grid[x][y]) - ord(""a"")) or state
                    if (newState, x, y) not in memo:
                        memo.add((newState, x, y))
                        heapq.heappush(q, (moves + 1, x, y, newState))
        return -1","auto shortestPathAllKeys(auto grid) {
    final, m, n, si, sj = 0, len(grid), len(grid[0]), 0, 0
    for i in range(m):
    for j in range(n):
    if grid[i][j] in ""abcdef"":
    final |= 1 << ord(grid[i][j]) - ord(""a"")
    elif grid[i][j] == ""@"":
    si, sj = i, j
    q, memo = [(0, si, sj, 0)], set()
    while q:
    moves, i, j, state = heapq.heappop(q)
    if state == final: return moves
    for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
    if 0 <= x < m and 0 <= y < n and grid[x][y] != ""#"":
    if grid[x][y].isupper() and not state & 1 << (ord(grid[x][y].lower()) - ord(""a"")): continue
    newState = ord(grid[x][y]) >= ord(""a"") and state | 1 << (ord(grid[x][y]) - ord(""a"")) or state
    if (newState, x, y) not in memo:
    memo.add((newState, x, y))
    heapq.heappush(q, (moves + 1, x, y, newState))
    return -1
}"
866.py,"def primePalindrome(self, N):
        def isPrime(x):
            if x < 2 or x % 2 == 0: return x == 2
            for i in range(3, int(x**0.5) + 1, 2):
                if x % i == 0: return False
            return True
        if 8 <= N <= 11: return 11
        for x in range(10 ** (len(str(N)) // 2), 10**5):
            y = int(str(x) + str(x)[-2::-1])
            if y >= N and isPrime(y): return y","auto primePalindrome(auto N) {
    def isPrime(x):
    if x < 2 or x % 2 == 0: return x == 2
    for i in range(3, int(x**0.5) + 1, 2):
    if x % i == 0: return False
    return True
    if 8 <= N <= 11: return 11
    for x in range(10 ** (len(str(N)) // 2), 10**5):
    y = int(str(x) + str(x)[-2::-1])
    if y >= N and isPrime(y): return y
}"
867.py,"def transpose(self, A):
        return [[A[i][j] for i in range(len(A))] for j in range(len(A[0]))]","auto transpose(auto A) {
    return [[A[i][j] for i in range(len(A))] for j in range(len(A[0]))]
}"
868.py,"def binaryGap(self, N):
        pre = dist = 0
        for i, c in enumerate(bin(N)[2:]):
            if c == ""1"":
                dist = max(dist, i - pre)
                pre = i
        return dist","auto binaryGap(auto N) {
    pre = dist = 0
    for i, c in enumerate(bin(N)[2:]):
    if c == ""1"":
    dist = max(dist, i - pre)
    pre = i
    return dist
}"
869.py,"def reorderedPowerOf2(self, N):
        cnt = collections.Counter(str(N))
        return any(cnt == collections.Counter(str(1 << c)) for c in range(32))","auto reorderedPowerOf2(auto N) {
    cnt = collections.Counter(str(N))
    return any(cnt == collections.Counter(str(1 << c)) for c in range(32))
}"
87.py,"def isScramble(self, s1, s2):
        n, m = len(s1), len(s2)
        if n != m or sorted(s1) != sorted(s2):
            return False
        if n < 4 or s1 == s2:
            return True
        f = self.isScramble
        for i in range(1, n):
            if f(s1[:i], s2[:i]) and f(s1[i:], s2[i:]) or \u005C
               f(s1[:i], s2[-i:]) and f(s1[i:], s2[:-i]):
                return True
        return False","auto isScramble(auto s1, auto s2) {
    n, m = len(s1), len(s2)
    if n != m or sorted(s1) != sorted(s2):
    return False
    if n < 4 or s1 == s2:
    return True
    f = self.isScramble
    for i in range(1, n):
    if f(s1[:i], s2[:i]) and f(s1[i:], s2[i:]) or \u005C
    f(s1[:i], s2[-i:]) and f(s1[i:], s2[:-i]):
    return True
    return False
}"
870.py,"def advantageCount(self, A: List[int], B: List[int]) -> List[int]:
        A.sort(reverse = True)
        non = []
        res = [-1] * len(A)
        for b, i in sorted([(b, i) for i, b in enumerate(B)]):
            while A and A[-1] <= b:
                non.append(A.pop())
            if A:
                res[i] = A.pop()
            else:
                break
        for i in range(len(res)):
            if res[i] == -1:
                res[i] = non.pop()
        return res ","auto advantageCount(auto A, auto B) {
    A.sort(reverse = true)
    non = []
    res = [-1] * len(A)
    for b, i in sorted([(b, i) for i, b in enumerate(B)]):
    while A and A[-1] <= b:
    non.append(A.pop())
    if A:
    res[i] = A.pop()
    else:
    break
    for i in range(len(res)):
    if res[i] == -1:
    res[i] = non.pop()
    return res
}"
871.py,"def minRefuelStops(self, target, startFuel, stations):
        q, n, memo = [(0, -startFuel, 0, 0)], len(stations), set()
        while q:
            refill, fuel, pos, index = heapq.heappop(q)
            fuel *= -1
            if index == n:
                if fuel - (target - pos) >= 0:
                    return refill
            else:
                sPos, add = stations[index]
                if (index, refill) not in memo and fuel - (sPos - pos) >= 0:
                    memo.add((index, refill))
                    f1 = (fuel - (sPos - pos) + add) * -1
                    f2 = (fuel - (sPos - pos)) * -1
                    heapq.heappush(q, (refill + 1, f1, sPos, index + 1))
                    heapq.heappush(q, (refill, f2, sPos, index + 1))
        return -1","auto minRefuelStops(auto target, auto startFuel, auto stations) {
    q, n, memo = [(0, -startFuel, 0, 0)], len(stations), set()
    while q:
    refill, fuel, pos, index = heapq.heappop(q)
    fuel *= -1
    if index == n:
    if fuel - (target - pos) >= 0:
    return refill
    else:
    sPos, add = stations[index]
    if (index, refill) not in memo and fuel - (sPos - pos) >= 0:
    memo.add((index, refill))
    f1 = (fuel - (sPos - pos) + add) * -1
    f2 = (fuel - (sPos - pos)) * -1
    heapq.heappush(q, (refill + 1, f1, sPos, index + 1))
    heapq.heappush(q, (refill, f2, sPos, index + 1))
    return -1
}"
872.py,"def leafSimilar(self, root1, root2):
        def dfs(node, arr):
            if node:
                if not node.left and not node.right: arr += [node.val]
                dfs(node.left, arr)
                dfs(node.right, arr)
                return arr
        return dfs(root1, []) == dfs(root2, [])","auto leafSimilar(auto root1, auto root2) {
    def dfs(node, arr):
    if node:
    if not node.left and not node.right: arr += [node.val]
    dfs(node.left, arr)
    dfs(node.right, arr)
    return arr
    return dfs(root1, []) == dfs(root2, [])
}"
873.py,"def lenLongestFibSubseq(self, A):
        n, pair, res, back = len(A), {}, 0, set()
        for i in range(n):
            back.add(A[i])
            j = i + 1
            mx = 2 * A[i]
            while j < n and A[j] < mx:
                if (A[j] - A[i], A[i]) in pair:
                    pair[(A[i], A[j])] = pair[(A[j] - A[i], A[i])] + 1
                else:
                    pair[(A[i], A[j])] = A[j] - A[i] in back and 3 or 2
                res = max(res, pair[(A[i], A[j])])
                j += 1
        return res > 2 and res or 0","auto lenLongestFibSubseq(auto A) {
    n, pair, res, back = len(A), {}, 0, set()
    for i in range(n):
    back.add(A[i])
    j = i + 1
    mx = 2 * A[i]
    while j < n and A[j] < mx:
    if (A[j] - A[i], A[i]) in pair:
    pair[(A[i], A[j])] = pair[(A[j] - A[i], A[i])] + 1
    else:
    pair[(A[i], A[j])] = A[j] - A[i] in back and 3 or 2
    res = max(res, pair[(A[i], A[j])])
    j += 1
    return res > 2 and res or 0
}"
874.py,"def robotSim(self, commands, obstacles):
        i = j = mx = 0
        d, move, obstacles = 3, [(-1, 0), (0, -1), (1, 0), (0, 1)], set(map(tuple, obstacles))
        for command in commands:
            if command == -2: d = (d + 1) % 4
            elif command == -1: d = (d - 1) % 4
            else:
                x, y = move[d]
                while command and (i + x, j + y) not in obstacles:
                    i += x
                    j += y
                    command -= 1
            mx = max(mx, i ** 2 + j ** 2)
        return mx","auto robotSim(auto commands, auto obstacles) {
    i = j = mx = 0
    d, move, obstacles = 3, [(-1, 0), (0, -1), (1, 0), (0, 1)], set(map(tuple, obstacles))
    for command in commands:
    if command == -2: d = (d + 1) % 4
    elif command == -1: d = (d - 1) % 4
    else:
    x, y = move[d]
    while command and (i + x, j + y) not in obstacles:
    i += x
    j += y
    command -= 1
    mx = max(mx, i ** 2 + j ** 2)
    return mx
}"
875.py,"def minEatingSpeed(self, piles, H):
        piles.sort()
        l, r = 1, max(piles)
        while l <= r:
            mid = (l + r) // 2
            h = sum(math.ceil(p / mid) for p in piles)
            if h > H:
                l = mid + 1
            elif h < H:
                r = mid - 1
            else:
                return mid
        return l","auto minEatingSpeed(auto piles, auto H) {
    piles.sort()
    l, r = 1, max(piles)
    while l <= r:
    mid = (l + r) // 2
    h = sum(math.ceil(p / mid) for p in piles)
    if h > H:
    l = mid + 1
    elif h < H:
    r = mid - 1
    else:
    return mid
    return l
}"
876.py,"def middleNode(self, head):
        root, n = head, 0
        while head:
            head = head.next
            n += 1
        for _ in range(n // 2):
            root = root.next
        return root  ","auto middleNode(auto head) {
    root, n = head, 0
    while head:
    head = head.next
    n += 1
    for _ in range(n // 2):
    root = root.next
    return root
}"
878.py,"def gcd(self, a, b):
        while b:
            a, b = b, a % b
        return a
    
    def count(self, num, A, B, C):
        return num // A + num // B - num // C
    
    def nthMagicalNumber(self, N, A, B):
        l, r, C = 2, 2 ** 63  - 1, A * B // self.gcd(A, B)
        while l < r:
            mid = (l + r) // 2
            if self.count(mid, A, B, C) < N:
                l = mid + 1
            else:
                r = mid
        return l % (10 ** 9 + 7)","auto gcd(auto a, auto b) {
    while b:
    a, b = b, a % b
    return a
    
    def count(self, num, A, B, C):
    return num // A + num // B - num // C
    
    def nthMagicalNumber(self, N, A, B):
    l, r, C = 2, 2 ** 63  - 1, A * B // self.gcd(A, B)
    while l < r:
    mid = (l + r) // 2
    if self.count(mid, A, B, C) < N:
    l = mid + 1
    else:
    r = mid
    return l % (10 ** 9 + 7)
}"
879.py,"def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:
        dp = [[0] * (G + 1) for i in range(P + 1)]
        dp[0][0] = 1
        for p, g in zip(profit, group):
            for i in range(P, -1, -1):
                for j in range(G - g, -1, -1):
                    dp[min(i + p, P)][j + g] += dp[i][j]
        return sum(dp[P]) % (10**9 + 7)","auto profitableSchemes(auto G, auto P, auto group, auto profit) {
    dp = [[0] * (G + 1) for i in range(P + 1)]
    dp[0][0] = 1
    for p, g in zip(profit, group):
    for i in range(P, -1, -1):
    for j in range(G - g, -1, -1):
    dp[min(i + p, P)][j + g] += dp[i][j]
    return sum(dp[P]) % (10**9 + 7)
}"
88.py,"def merge(self, nums1, m, nums2, n):
        """"""
        :type nums1: List[int]
        :type m: int
        :type nums2: List[int]
        :type n: int
        :rtype: void Do not return anything, modify nums1 in-place instead.
        """"""
        while m > 0 and n > 0:
            if nums1[m-1] >= nums2[n-1]:
                nums1[m+n-1] = nums1[m-1]
                m -= 1
            else:
                nums1[m+n-1] = nums2[n-1]
                n -= 1
        if n > 0:
            nums1[:n] = nums2[:n]

                ","auto merge(auto nums1, auto m, auto nums2, auto n) {
    """"""
    :type nums1: List[int]
    :type m: int
    :type nums2: List[int]
    :type n: int
    :rtype: void Do not return anything, modify nums1 in-place instead.
    """"""
    while m > 0 and n > 0:
    if nums1[m-1] >= nums2[n-1]:
    nums1[m+n-1] = nums1[m-1]
    m -= 1
    else:
    nums1[m+n-1] = nums2[n-1]
    n -= 1
    if n > 0:
    nums1[:n] = nums2[:n]
}"
880.py,"def decodeAtIndex(self, S, K):
        stack, l = [], 0
        for c in S:
            l = l + 1 if c.isalpha() else l * int(c)
            stack += c,
            while l >= K:
                while stack[-1].isdigit(): l //= int(stack.pop())
                K = K % l
                if not K: return stack[-1]
                l -= 1
                stack.pop()","auto decodeAtIndex(auto S, auto K) {
    stack, l = [], 0
    for c in S:
    l = l + 1 if c.isalpha() else l * int(c)
    stack += c,
    while l >= K:
    while stack[-1].isdigit(): l //= int(stack.pop())
    K = K % l
    if not K: return stack[-1]
    l -= 1
    stack.pop()
}"
881.py,"def numRescueBoats(self, people, limit):
        """"""
        :type people: List[int]
        :type limit: int
        :rtype: int
        """"""
        people.sort()
        l, r, cnt = 0, len(people) - 1, 0
        while l <= r:
            if l != r and people[l] + people[r] > limit: l -= 1
            l += 1
            r -= 1
            cnt += 1
        return cnt","auto numRescueBoats(auto people, auto limit) {
    """"""
    :type people: List[int]
    :type limit: int
    :rtype: int
    """"""
    people.sort()
    l, r, cnt = 0, len(people) - 1, 0
    while l <= r:
    if l != r and people[l] + people[r] > limit: l -= 1
    l += 1
    r -= 1
    cnt += 1
    return cnt
}"
882.py,"def reachableNodes(self, edges, M, N):
        adj, seen = collections.defaultdict(dict), set()
        for a, b, l in edges:
            adj[a][b] = [l, 0]
            adj[b][a] = [l, 0]
        q = [(0, M, None)]
        while q:
            new = []
            for i, moves, pre in q:
                seen.add(i)
                for j in adj[i]:
                    if moves > adj[i][j][1]:
                        adj[i][j][1] = moves
                        if moves > adj[i][j][0] and j != pre:
                            new.append((j, moves - adj[i][j][0] - 1, i))
            q = new 
        return sum(min(adj[i][j][1] + adj[j][i][1], l) for i, j, l in edges) + len(seen)","auto reachableNodes(auto edges, auto M, auto N) {
    adj, seen = collections.defaultdict(dict), set()
    for a, b, l in edges:
    adj[a][b] = [l, 0]
    adj[b][a] = [l, 0]
    q = [(0, M, None)]
    while q:
    new = []
    for i, moves, pre in q:
    seen.add(i)
    for j in adj[i]:
    if moves > adj[i][j][1]:
    adj[i][j][1] = moves
    if moves > adj[i][j][0] and j != pre:
    new.append((j, moves - adj[i][j][0] - 1, i))
    q = new
    return sum(min(adj[i][j][1] + adj[j][i][1], l) for i, j, l in edges) + len(seen)
}"
883.py,"def projectionArea(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: int
        """"""
        n = len(grid)
        top = sum(grid[i][j] != 0 for i in range(n) for j in range(n))
        front = sum(max(grid[i]) for i in range(n))
        side = sum(max(grid[i][j] for i in range(n)) for j in range(n))
        return top + front + side","auto projectionArea(auto grid) {
    """"""
    :type grid: List[List[int]]
    :rtype: int
    """"""
    n = len(grid)
    top = sum(grid[i][j] != 0 for i in range(n) for j in range(n))
    front = sum(max(grid[i]) for i in range(n))
    side = sum(max(grid[i][j] for i in range(n)) for j in range(n))
    return top + front + side
}"
884.py,"def uncommonFromSentences(self, A: str, B: str) -> List[str]:
        c1 = collections.Counter(A.split())
        c2 = collections.Counter(B.split())
        return list(c for c in c1 if c1[c] == 1 and c not in c2) + list(c for c in c2 if c2[c] == 1 and c not in c1)","auto uncommonFromSentences(auto A, auto B) {
    c1 = collections.Counter(A.split())
    c2 = collections.Counter(B.split())
    return list(c for c in c1 if c1[c] == 1 and c not in c2) + list(c for c in c2 if c2[c] == 1 and c not in c1)
}"
885.py,"def spiralMatrixIII(self, R, C, r0, c0):
        direct, res, n, l, ind = [(-1, 0), (0, 1), (1, 0), (0, -1)], [[r0, c0]], R * C, 1, 1
        while len(res) < n:
            for __ in range(2):
                for _ in range(l):
                    r0 += direct[ind][0]
                    c0 += direct[ind][1]
                    if 0 <= r0 < R and 0 <= c0 < C:
                        res.append([r0, c0])
                ind = (ind + 1) % 4
            l += 1
        return res","auto spiralMatrixIII(auto R, auto C, auto r0, auto c0) {
    direct, res, n, l, ind = [(-1, 0), (0, 1), (1, 0), (0, -1)], [[r0, c0]], R * C, 1, 1
    while len(res) < n:
    for __ in range(2):
    for _ in range(l):
    r0 += direct[ind][0]
    c0 += direct[ind][1]
    if 0 <= r0 < R and 0 <= c0 < C:
    res.append([r0, c0])
    ind = (ind + 1) % 4
    l += 1
    return res
}"
886.py,"def merge(self, node, p, group, disliked):
        group[node] = p
        for v in disliked[node]:
            if group[v] == p or (group[v] == v and not self.merge(v, -p, group, disliked)): return False
        return True
    
    def possibleBipartition(self, N, dislikes):
        group, disliked = [i for i in range(N + 1)], collections.defaultdict(set)
        for a, b in dislikes:
            disliked[a].add(b)
            disliked[b].add(a) 
        for i in range(1, N + 1):
            if group[i] == i and not self.merge(i, 2001, group, disliked): return False
        return True","auto merge(auto node, auto p, auto group, auto disliked) {
    group[node] = p
    for v in disliked[node]:
    if group[v] == p or (group[v] == v and not self.merge(v, -p, group, disliked)): return False
    return True
    
    def possibleBipartition(self, N, dislikes):
    group, disliked = [i for i in range(N + 1)], collections.defaultdict(set)
    for a, b in dislikes:
    disliked[a].add(b)
    disliked[b].add(a)
    for i in range(1, N + 1):
    if group[i] == i and not self.merge(i, 2001, group, disliked): return False
    return True
}"
887.py,"def superEggDrop(self, K, N):
        drops = 0                           # the number of eggs dropped
        floors = [0 for _ in range(K + 1)]  # floors[i] is the number of floors that can be checked with i eggs

        while floors[K] < N:                # until we can reach N floors with K eggs 

            for eggs in range(K, 0, -1):
                floors[eggs] += 1 + floors[eggs - 1]
            drops += 1

        return drops","auto superEggDrop(auto K, auto N) {
    drops = 0                           # the number of eggs dropped
    floors = [0 for _ in range(K + 1)]  # floors[i] is the number of floors that can be checked with i eggs
    
    while floors[K] < N:                # until we can reach N floors with K eggs
    
    for eggs in range(K, 0, -1):
    floors[eggs] += 1 + floors[eggs - 1]
    drops += 1
    
    return drops
}"
888.py,"def fairCandySwap(self, A, B):
        """"""
        :type A: List[int]
        :type B: List[int]
        :rtype: List[int]
        """"""
        a, b = set(A), set(B)
        diff =(sum(A) - sum(B)) // 2
        for c in B:
            if c + diff in a:
                return [c + diff, c]","auto fairCandySwap(auto A, auto B) {
    """"""
    :type A: List[int]
    :type B: List[int]
    :rtype: List[int]
    """"""
    a, b = set(A), set(B)
    diff =(sum(A) - sum(B)) // 2
    for c in B:
    if c + diff in a:
    return [c + diff, c]
}"
889.py,"def constructFromPrePost(self, pre, post):
        if pre:
            root = TreeNode(pre.pop(0))
            post.pop()
            if pre:
                if pre[0] == post[-1]:
                    root.left = self.constructFromPrePost(pre, post)
                else:
                    l, r = post.index(pre[0]), pre.index(post[-1])
                    root.left = self.constructFromPrePost(pre[:r], post[:l + 1])
                    root.right = self.constructFromPrePost(pre[r:], post[l + 1:]) 
            return root","auto constructFromPrePost(auto pre, auto post) {
    if pre:
    root = TreeNode(pre.pop(0))
    post.pop()
    if pre:
    if pre[0] == post[-1]:
    root.left = self.constructFromPrePost(pre, post)
    else:
    l, r = post.index(pre[0]), pre.index(post[-1])
    root.left = self.constructFromPrePost(pre[:r], post[:l + 1])
    root.right = self.constructFromPrePost(pre[r:], post[l + 1:])
    return root
}"
89.py,"def grayCode(self, n: int) -> List[int]:
        results = [0]
        for i in range(n): 
            results += [x + pow(2, i) for x in reversed(results)]
        return results
        ","auto grayCode(auto n) {
    results = [0]
    for i in range(n):
    results += [x + pow(2, i) for x in reversed(results)]
    return results
}"
890.py,"def findAndReplacePattern(self, words, pattern):
        """"""
        :type words: List[str]
        :type pattern: str
        :rtype: List[str]
        """"""
        res = []
        for w in words:
            mp12, mp21, match = {}, {}, True
            for c1, c2 in zip(w, pattern):
                if (c1 in mp12 and mp12[c1] != c2) or (c2 in mp21 and mp21[c2] != c1):
                    match = False
                    break
                mp12[c1], mp21[c2] = c2, c1
            if match: res.append(w)
        return res","auto findAndReplacePattern(auto words, auto pattern) {
    """"""
    :type words: List[str]
    :type pattern: str
    :rtype: List[str]
    """"""
    res = []
    for w in words:
    mp12, mp21, match = {}, {}, True
    for c1, c2 in zip(w, pattern):
    if (c1 in mp12 and mp12[c1] != c2) or (c2 in mp21 and mp21[c2] != c1):
    match = False
    break
    mp12[c1], mp21[c2] = c2, c1
    if match: res.append(w)
    return res
}"
891.py,"def sumSubseqWidths(self, A):
        A.sort()
        res=0
        for i in range(len(A)):
            res*=2
            res-=A[i]
            res+=A[~i]
        return res % (10**9+7)","auto sumSubseqWidths(auto A) {
    A.sort()
    res=0
    for i in range(len(A)):
    res*=2
    res-=A[i]
    res+=A[~i]
    return res % (10**9+7)
}"
892.py,"def surfaceArea(self, grid):
        n, sm = len(grid), 0
        for i in range(n):
            for j in range(n):
                sm += grid[i][j] and grid[i][j] * 4 + 2
                if i > 0: sm -= min(grid[i - 1][j], grid[i][j])
                if j > 0: sm -= min(grid[i][j - 1], grid[i][j])
                if i < n - 1: sm -= min(grid[i + 1][j], grid[i][j])
                if j < n - 1: sm -= min(grid[i][j + 1], grid[i][j])
        return sm","auto surfaceArea(auto grid) {
    n, sm = len(grid), 0
    for i in range(n):
    for j in range(n):
    sm += grid[i][j] and grid[i][j] * 4 + 2
    if i > 0: sm -= min(grid[i - 1][j], grid[i][j])
    if j > 0: sm -= min(grid[i][j - 1], grid[i][j])
    if i < n - 1: sm -= min(grid[i + 1][j], grid[i][j])
    if j < n - 1: sm -= min(grid[i][j + 1], grid[i][j])
    return sm
}"
893.py,"def numSpecialEquivGroups(self, A):
        return len(set("""".join(sorted(s[0::2])) + """".join(sorted(s[1::2])) for s in A))","auto numSpecialEquivGroups(auto A) {
    return len(set("""".join(sorted(s[0::2])) + """".join(sorted(s[1::2])) for s in A))
}"
894.py,"def allPossibleFBT(self, N):
        def constr(N):
            if N == 1: yield TreeNode(0)
            for i in range(1, N, 2):
                for l in constr(i):
                    for r in constr(N - i - 1):
                        m = TreeNode(0)
                        m.left = l
                        m.right = r
                        yield m
        return list(constr(N))","auto allPossibleFBT(auto N) {
    def constr(N):
    if N == 1: yield TreeNode(0)
    for i in range(1, N, 2):
    for l in constr(i):
    for r in constr(N - i - 1):
    m = TreeNode(0)
    m.left = l
    m.right = r
    yield m
    return list(constr(N))
}"
896.py,"def isMonotonic(self, A):
        return all(A[i] <= A[i - 1] for i in range(1, len(A))) or all(A[i] >= A[i - 1] for i in range(1, len(A)))","auto isMonotonic(auto A) {
    return all(A[i] <= A[i - 1] for i in range(1, len(A))) or all(A[i] >= A[i - 1] for i in range(1, len(A)))
}"
898.py,"def subarrayBitwiseORs(self, A):
        nums, n, pre = set(), len(A), set()
        for a in A:
            pre = {a} | {num | a for num in pre}
            nums |= pre
        return len(nums)","auto subarrayBitwiseORs(auto A) {
    nums, n, pre = set(), len(A), set()
    for a in A:
    pre = {a} | {num | a for num in pre}
    nums |= pre
    return len(nums)
}"
899.py,"def orderlyQueue(self, S, K):
        return """".join(sorted(S)) if K > 1 else min(S[i:] + S[:i] for i in range(len(S)))","auto orderlyQueue(auto S, auto K) {
    return """".join(sorted(S)) if K > 1 else min(S[i:] + S[:i] for i in range(len(S)))
}"
9.py,"def isPalindrome(self, x):
        return str(x) == str(x)[::-1]    ","auto isPalindrome(auto x) {
    return str(x) == str(x)[::-1]
}"
90.py,"def subsetsWithDup(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[List[int]]
        """"""
        from itertools import combinations as cb
        res, dic = [], set()
        for i in range(len(nums) + 1):
            for item in cb(nums, i):
                item = tuple(sorted(item))
                if item not in dic:
                    dic.add(item)
                    res.append(item)
        return res","auto subsetsWithDup(auto nums) {
    """"""
    :type nums: List[int]
    :rtype: List[List[int]]
    """"""
    from itertools import combinations as cb
    res, dic = [], set()
    for i in range(len(nums) + 1):
    for item in cb(nums, i):
    item = tuple(sorted(item))
    if item not in dic:
    dic.add(item)
    res.append(item)
    return res
}"
902.py,"def atMostNGivenDigitSet(self, D, N):
        def less(c):
            return len([char for char in D if char < c])
        d, cnt, l = len(D), 0, len(str(N))
        # For numbers which have less digits than N, simply len(D) ** digits_length different numbers can be created
        for i in range(1, l):
            cnt += d ** i
        """"""
        We should also consider edge cases where previous digits match with related digits in N. In this case, we can make a number with             previous digits + (digits less than N[i]) + D ** remaining length
        """"""
        for i, c in enumerate(str(N)):
            cnt += less(c) * (d ** (l - i - 1))
            if c not in D: break
            if i == l - 1: cnt += 1
        return cnt","auto atMostNGivenDigitSet(auto D, auto N) {
    def less(c):
    return len([char for char in D if char < c])
    d, cnt, l = len(D), 0, len(str(N))
    # For numbers which have less digits than N, simply len(D) ** digits_length different numbers can be created
    for i in range(1, l):
    cnt += d ** i
    """"""
    We should also consider edge cases where previous digits match with related digits in N. In this case, we can make a number with             previous digits + (digits less than N[i]) + D ** remaining length
    """"""
    for i, c in enumerate(str(N)):
    cnt += less(c) * (d ** (l - i - 1))
    if c not in D: break
    if i == l - 1: cnt += 1
    return cnt
}"
903.py,"def numPermsDISequence(self, S: str) -> int:
        dp = [1] * (len(S) + 1)
        for c in S:
            if c == ""I"":
                dp = dp[:-1]
                for i in range(1, len(dp)):
                    dp[i] += dp[i - 1]
            else:
                dp = dp[1:]
                for i in range(len(dp) - 1)[::-1]:
                    dp[i] += dp[i + 1]
        return dp[0] % (10**9 + 7)","auto numPermsDISequence(auto S) {
    dp = [1] * (len(S) + 1)
    for c in S:
    if c == ""I"":
    dp = dp[:-1]
    for i in range(1, len(dp)):
    dp[i] += dp[i - 1]
    else:
    dp = dp[1:]
    for i in range(len(dp) - 1)[::-1]:
    dp[i] += dp[i + 1]
    return dp[0] % (10**9 + 7)
}"
904.py,"def totalFruit(self, tree: List[int]) -> int:
        res = i = 0
        last = collections.defaultdict(int)
        for j, val in enumerate(tree):
            if len(last) == 2 and val not in last:
                pre = min(last.values())
                i = pre + 1
                last.pop(tree[pre])
            last[val] = j
            res = max(res, j - i + 1)
        return res","auto totalFruit(auto tree) {
    res = i = 0
    last = collections.defaultdict(int)
    for j, val in enumerate(tree):
    if len(last) == 2 and val not in last:
    pre = min(last.values())
    i = pre + 1
    last.pop(tree[pre])
    last[val] = j
    res = max(res, j - i + 1)
    return res
}"
905.py,"def sortArrayByParity(self, A):
        return [a for a in A if not a % 2] + [a for a in A if a % 2]","auto sortArrayByParity(auto A) {
    return [a for a in A if not a % 2] + [a for a in A if a % 2]
}"
906.py,"def superpalindromesInRange(self, L, R):
        L, R = int(L), int(R)
        left = int(math.floor(math.sqrt(L)))
        right = int(math.ceil(math.sqrt(R)))
        n1, n2 = len(str(left)), len(str(right))
        n1 = n1//2 if n1%2==0 else n1//2+1
        n2 = n2//2 if n2%2==0 else n2//2+1
        start = int('1' + '0'*(n1 - 1))
        end = int('9' * n2) + 1
        ans = 0 
        for i in range(start, end):
            x = str(i)
            num1 = int(x + x[::-1])
            num2 = int(x + x[:-1][::-1])
            for num in [num1, num2]:
                cand = num * num
                if L <= cand <= R and str(cand) == str(cand)[::-1]:
                    ans += 1
        return ans","auto superpalindromesInRange(auto L, auto R) {
    L, R = int(L), int(R)
    left = int(math.floor(math.sqrt(L)))
    right = int(math.ceil(math.sqrt(R)))
    n1, n2 = len(str(left)), len(str(right))
    n1 = n1//2 if n1%2==0 else n1//2+1
    n2 = n2//2 if n2%2==0 else n2//2+1
    start = int('1' + '0'*(n1 - 1))
    end = int('9' * n2) + 1
    ans = 0
    for i in range(start, end):
    x = str(i)
    num1 = int(x + x[::-1])
    num2 = int(x + x[:-1][::-1])
    for num in [num1, num2]:
    cand = num * num
    if L <= cand <= R and str(cand) == str(cand)[::-1]:
    ans += 1
    return ans
}"
907.py,"def sumSubarrayMins(self, A):
        res, stack = 0, []  
        A = [float('-inf')] + A + [float('-inf')]
        for i, n in enumerate(A):
            while stack and A[stack[-1]] > n:
                cur = stack.pop()
                res += A[cur] * (i - cur) * (cur - stack[-1])
            stack.append(i)
        return res % (10 ** 9 + 7)","auto sumSubarrayMins(auto A) {
    res, stack = 0, []
    A = [float('-inf')] + A + [float('-inf')]
    for i, n in enumerate(A):
    while stack and A[stack[-1]] > n:
    cur = stack.pop()
    res += A[cur] * (i - cur) * (cur - stack[-1])
    stack.append(i)
    return res % (10 ** 9 + 7)
}"
908.py,"def smallestRangeI(self, A, K):
        l, r = min(A) + K, max(A) - K 
        return 0 if l >= r else r - l","auto smallestRangeI(auto A, auto K) {
    l, r = min(A) + K, max(A) - K
    return 0 if l >= r else r - l
}"
909.py,"def snakesAndLadders(self, board):
        arr, nn, q, seen, moves = [0], len(board) ** 2, [1], set(), 0
        for i, row in enumerate(board[::-1]): arr += row[::-1] if i % 2 else row
        while q:
            new = []
            for sq in q:
                if sq == nn: return moves 
                for i in range(1, 7):
                    if sq + i <= nn and sq + i not in seen:
                        seen.add(sq + i)
                        new.append(sq + i if arr[sq + i] == -1 else arr[sq + i])
            q, moves = new, moves + 1
        return -1                    ","auto snakesAndLadders(auto board) {
    arr, nn, q, seen, moves = [0], len(board) ** 2, [1], set(), 0
    for i, row in enumerate(board[::-1]): arr += row[::-1] if i % 2 else row
    while q:
    new = []
    for sq in q:
    if sq == nn: return moves
    for i in range(1, 7):
    if sq + i <= nn and sq + i not in seen:
    seen.add(sq + i)
    new.append(sq + i if arr[sq + i] == -1 else arr[sq + i])
    q, moves = new, moves + 1
    return -1
}"
91.py,"def numDecodings(self, s):
        if s[0] == ""0"": return 0
        dp1 = dp2 = 1
        for i in range(1, len(s)):
            if s[i] == ""0"" and (s[i - 1] == ""0"" or s[i - 1] >= ""3""): return 0
            dp1, dp2 = [dp2, dp1] if s[i] == ""0"" else [dp2, dp2 + dp1] if ""10"" <= s[i -1: i + 1] <= ""26"" else [dp2, dp2]
        return dp2  ","auto numDecodings(auto s) {
    if s[0] == ""0"": return 0
    dp1 = dp2 = 1
    for i in range(1, len(s)):
    if s[i] == ""0"" and (s[i - 1] == ""0"" or s[i - 1] >= ""3""): return 0
    dp1, dp2 = [dp2, dp1] if s[i] == ""0"" else [dp2, dp2 + dp1] if ""10"" <= s[i -1: i + 1] <= ""26"" else [dp2, dp2]
    return dp2
}"
910.py,"def smallestRangeII(self, A, K):
        A.sort()
        return min([max(A[-1] - K, A[i] + K) - min(A[0] + K, A[i + 1] - K) for i in range(len(A) - 1)] + [A[-1] - A[0]])","auto smallestRangeII(auto A, auto K) {
    A.sort()
    return min([max(A[-1] - K, A[i] + K) - min(A[0] + K, A[i + 1] - K) for i in range(len(A) - 1)] + [A[-1] - A[0]])
}"
912.py,"def sortArray(self, nums: List[int]) -> List[int]:
        if len(nums) <= 1:
            return nums

        pivot = random.choice(nums)
        lt = [v for v in nums if v < pivot]
        eq = [v for v in nums if v == pivot]
        gt = [v for v in nums if v > pivot]

        return self.sortArray(lt) + eq + self.sortArray(gt)
    ","auto sortArray(auto nums) {
    if len(nums) <= 1:
    return nums
    
    pivot = random.choice(nums)
    lt = [v for v in nums if v < pivot]
    eq = [v for v in nums if v == pivot]
    gt = [v for v in nums if v > pivot]
    
    return self.sortArray(lt) + eq + self.sortArray(gt)
}"
914.py,"def hasGroupsSizeX(self, deck):
        import functools
        def gcd(a, b):
            if not b: return a
            return gcd(b, a % b)
        return functools.reduce(gcd, collections.Counter(deck).values()) != 1","auto hasGroupsSizeX(auto deck) {
    import functools
    def gcd(a, b):
    if not b: return a
    return gcd(b, a % b)
    return functools.reduce(gcd, collections.Counter(deck).values()) != 1
}"
915.py,"def partitionDisjoint(self, A):
        rMin, lMax, mx, mn = [0] * len(A), [0] * len(A), -float(""inf""), float(""inf"")
        for i, num in enumerate(A):
            mx = max(mx, num)
            lMax[i] = mx 
        for i in range(len(A) - 1, -1, -1):
            mn = min(mn, A[i])
            rMin[i] = mn 
        for i in range(len(A) - 1):
            if lMax[i] <= rMin[i + 1]:
                return i + 1","auto partitionDisjoint(auto A) {
    rMin, lMax, mx, mn = [0] * len(A), [0] * len(A), -float(""inf""), float(""inf"")
    for i, num in enumerate(A):
    mx = max(mx, num)
    lMax[i] = mx
    for i in range(len(A) - 1, -1, -1):
    mn = min(mn, A[i])
    rMin[i] = mn
    for i in range(len(A) - 1):
    if lMax[i] <= rMin[i + 1]:
    return i + 1
}"
916.py,"def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:
        cnt = collections.Counter()
        for b in B:
            for k, v in collections.Counter(b).items():
                if cnt[k] < v:
                    cnt[k] = v
        res = []
        for a in A:
            if not cnt - collections.Counter(a):
                res.append(a)
        return res","auto wordSubsets(auto A, auto B) {
    cnt = collections.Counter()
    for b in B:
    for k, v in collections.Counter(b).items():
    if cnt[k] < v:
    cnt[k] = v
    res = []
    for a in A:
    if not cnt - collections.Counter(a):
    res.append(a)
    return res
}"
917.py,"def reverseOnlyLetters(self, S):
        r = [s for s in S if s.isalpha()]
        return """".join(S[i] if not S[i].isalpha() else r.pop() for i in range(len(S)))","auto reverseOnlyLetters(auto S) {
    r = [s for s in S if s.isalpha()]
    return """".join(S[i] if not S[i].isalpha() else r.pop() for i in range(len(S)))
}"
918.py,"def maxSubarraySumCircular(self, A):
        lMn, rMx, res, lSm, rSm, preSm = float(""inf""), [-float(""inf"")] * (len(A) + 1), -float(""inf""), 0, 0, 0
        for i in range(len(A) - 1, -1, -1):
            rSm += A[i]
            rMx[i] = max(rMx[i + 1], rSm)
        for i in range(len(A)):
            preSm += A[i]
            lMn = min(lMn, lSm)
            res = max(res, preSm, preSm - lMn, preSm + rMx[i + 1])
            lSm += A[i]
        return res","auto maxSubarraySumCircular(auto A) {
    lMn, rMx, res, lSm, rSm, preSm = float(""inf""), [-float(""inf"")] * (len(A) + 1), -float(""inf""), 0, 0, 0
    for i in range(len(A) - 1, -1, -1):
    rSm += A[i]
    rMx[i] = max(rMx[i + 1], rSm)
    for i in range(len(A)):
    preSm += A[i]
    lMn = min(lMn, lSm)
    res = max(res, preSm, preSm - lMn, preSm + rMx[i + 1])
    lSm += A[i]
    return res
}"
92.py,"def reverseBetween(self, head, m, n):
        dummy_left, dummy_left.next, i = ListNode(0), head, 1
        prev = dummy_left
        while head:
            latter = head.next
            if m == n: 
                break
            if i == m: 
                head_left, right = prev, head
            if i == n: 
                head_right, left = head.next, head
            if m < i <= n: 
                head.next = prev
            prev, head, i = head, latter, i+1
        if m != n: 
            head_left.next, right.next = left, head_right
        return dummy_left.next","auto reverseBetween(auto head, auto m, auto n) {
    dummy_left, dummy_left.next, i = ListNode(0), head, 1
    prev = dummy_left
    while head:
    latter = head.next
    if m == n:
    break
    if i == m:
    head_left, right = prev, head
    if i == n:
    head_right, left = head.next, head
    if m < i <= n:
    head.next = prev
    prev, head, i = head, latter, i+1
    if m != n:
    head_left.next, right.next = left, head_right
    return dummy_left.next
}"
921.py,"def minAddToMakeValid(self, S):
        r, l = 0, []
        for s in S:
            if s == ""("":
                l.append(s)
            elif l:
                l.pop()
            else:
                r += 1 
        return r + len(l)","auto minAddToMakeValid(auto S) {
    r, l = 0, []
    for s in S:
    if s == ""("":
    l.append(s)
    elif l:
    l.pop()
    else:
    r += 1
    return r + len(l)
}"
922.py,"def sortArrayByParityII(self, A):
        even, odd = [a for a in A if not a % 2], [a for a in A if a % 2]
        return [even.pop() if not i % 2 else odd.pop() for i in range(len(A))]","auto sortArrayByParityII(auto A) {
    even, odd = [a for a in A if not a % 2], [a for a in A if a % 2]
    return [even.pop() if not i % 2 else odd.pop() for i in range(len(A))]
}"
923.py,"def threeSumMulti(self, A, target):
        c = collections.Counter(A)
        res = 0
        for i, j in itertools.combinations_with_replacement(c, 2):
            k = target - i - j
            if i == j == k: res += c[i] * (c[i] - 1) * (c[i] - 2) // 6
            elif i == j != k: res += c[i] * (c[i] - 1) // 2 * c[k]
            elif k > i and k > j: res += c[i] * c[j] * c[k]
        return res % (10**9 + 7)","auto threeSumMulti(auto A, auto target) {
    c = collections.Counter(A)
    res = 0
    for i, j in itertools.combinations_with_replacement(c, 2):
    k = target - i - j
    if i == j == k: res += c[i] * (c[i] - 1) * (c[i] - 2) // 6
    elif i == j != k: res += c[i] * (c[i] - 1) // 2 * c[k]
    elif k > i and k > j: res += c[i] * c[j] * c[k]
    return res % (10**9 + 7)
}"
924.py,"def minMalwareSpread(self, graph, initial):
        def dfs(i):
            nodes.add(i)
            for j in range(len(graph[i])):
                if graph[i][j] and j not in nodes:
                    dfs(j)
        rank, initial = collections.defaultdict(list), set(initial)
        for node in sorted(initial):
            nodes = set()
            dfs(node)
            if nodes & initial == {node}:
                rank[len(nodes)].append(node)
        return rank[max(rank)][0] if rank else min(initial)","auto minMalwareSpread(auto graph, auto initial) {
    def dfs(i):
    nodes.add(i)
    for j in range(len(graph[i])):
    if graph[i][j] and j not in nodes:
    dfs(j)
    rank, initial = collections.defaultdict(list), set(initial)
    for node in sorted(initial):
    nodes = set()
    dfs(node)
    if nodes & initial == {node}:
    rank[len(nodes)].append(node)
    return rank[max(rank)][0] if rank else min(initial)
}"
925.py,"def isLongPressedName(self, name, typed):
        pre, i = None, 0
        for c in typed:
            if i < len(name) and c == name[i]:
                pre, i = name[i], i + 1
            elif c != pre:
                return False
        return i == len(name)","auto isLongPressedName(auto name, auto typed) {
    pre, i = None, 0
    for c in typed:
    if i < len(name) and c == name[i]:
    pre, i = name[i], i + 1
    elif c != pre:
    return False
    return i == len(name)
}"
926.py,"def minFlipsMonoIncr(self, s):
        res = cur = s.count(""0"")
        for c in s: res, cur = c == ""1"" and (res, cur + 1) or (min(res, cur - 1), cur - 1)
        return res","auto minFlipsMonoIncr(auto s) {
    res = cur = s.count(""0"")
    for c in s: res, cur = c == ""1"" and (res, cur + 1) or (min(res, cur - 1), cur - 1)
    return res
}"
928.py,"def minMalwareSpread(self, graph, initial):
        def dfs(i):
            seen.add(i)
            return not any(graph[i][j] and j not in seen and (j in initials or not dfs(j)) for j in range(len(graph[i])))
        res, mx, initials = min(initial), 1, set(initial)
        for node in sorted(initial):
            impact = set()
            for j in range(len(graph[node])):
                seen = {node}
                if graph[node][j] and j not in initials and dfs(j): impact |= seen
            if len(impact) > mx: res, mx = node, len(impact)
        return res","auto minMalwareSpread(auto graph, auto initial) {
    def dfs(i):
    seen.add(i)
    return not any(graph[i][j] and j not in seen and (j in initials or not dfs(j)) for j in range(len(graph[i])))
    res, mx, initials = min(initial), 1, set(initial)
    for node in sorted(initial):
    impact = set()
    for j in range(len(graph[node])):
    seen = {node}
    if graph[node][j] and j not in initials and dfs(j): impact |= seen
    if len(impact) > mx: res, mx = node, len(impact)
    return res
}"
929.py,"def numUniqueEmails(self, emails: List[str]) -> int:
        rec = set()
        for email in emails:
            local, domain = email.split('@')
            local = local.split('+')[0].replace('.', '')
            rec.add(local + '@' + domain)
        return len(rec)","auto numUniqueEmails(auto emails) {
    rec = set()
    for email in emails:
    local, domain = email.split('@')
    local = local.split('+')[0].replace('.', '')
    rec.add(local + '@' + domain)
    return len(rec)
}"
93.py,"def restoreIpAddresses(self, s: str) -> List[str]:
        if len(s) > 12: return []
        bfs = [(0, '')]
        for c in s:
            new = []
            c = int(c)
            for cur, st in bfs:
                if cur * 10 + c <= 255 and (st[-1:] != '0' or cur):
                    new.append((cur * 10 + c, st + str(c)))
                if st:
                    new.append((c, st + '.' + str(c)))
            bfs = new
        return [st for cur, st in bfs if st.count('.') == 3]","auto restoreIpAddresses(auto s) {
    if len(s) > 12: return []
    bfs = [(0, '')]
    for c in s:
    new = []
    c = int(c)
    for cur, st in bfs:
    if cur * 10 + c <= 255 and (st[-1:] != '0' or cur):
    new.append((cur * 10 + c, st + str(c)))
    if st:
    new.append((c, st + '.' + str(c)))
    bfs = new
    return [st for cur, st in bfs if st.count('.') == 3]
}"
930.py,"def numSubarraysWithSum(self, A, S):
        res, sm, sums = 0, 0, collections.defaultdict(int)
        for a in A:
            sm += a
            res += sums[sm - S] + (sm == S)
            sums[sm] += 1
        return res","auto numSubarraysWithSum(auto A, auto S) {
    res, sm, sums = 0, 0, collections.defaultdict(int)
    for a in A:
    sm += a
    res += sums[sm - S] + (sm == S)
    sums[sm] += 1
    return res
}"
931.py,"def minFallingPathSum(self, A):
        for i in range(1, len(A)):
            for j in range(len(A)):
                A[i][j] += min(A[i - 1][j and j - 1:j + 2])
        return min(A[-1])","auto minFallingPathSum(auto A) {
    for i in range(1, len(A)):
    for j in range(len(A)):
    A[i][j] += min(A[i - 1][j and j - 1:j + 2])
    return min(A[-1])
}"
932.py,"def beautifulArray(self, N):
        if N == 1: return [1]
        half = self.beautifulArray(N - N // 2)
        return [i * 2 - 1 for i in half] + [i * 2 for i in half if i * 2 <= N]","auto beautifulArray(auto N) {
    if N == 1: return [1]
    half = self.beautifulArray(N - N // 2)
    return [i * 2 - 1 for i in half] + [i * 2 for i in half if i * 2 <= N]
}"
934.py,"def shortestBridge(self, A):
        def dfs(i, j):
            A[i][j] = -1
            q.append((i, j))
            for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
                if 0 <= x < n and 0 <= y < n and A[x][y] == 1:
                    dfs(x, y)
        def first():
            for i in range(n):
                for j in range(n):
                    if A[i][j]:
                        return i, j
        n, step, q = len(A), 0, []
        dfs(*first())
        while True:
            new = []
            for i, j in q:
                for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
                    if 0 <= x < n and 0 <= y < n:
                        if A[x][y] == 1:
                            return step
                        elif not A[x][y]:
                            A[x][y] = -1
                            new.append((x, y))
            step += 1
            q = new","auto shortestBridge(auto A) {
    def dfs(i, j):
    A[i][j] = -1
    q.append((i, j))
    for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
    if 0 <= x < n and 0 <= y < n and A[x][y] == 1:
    dfs(x, y)
    def first():
    for i in range(n):
    for j in range(n):
    if A[i][j]:
    return i, j
    n, step, q = len(A), 0, []
    dfs(*first())
    while True:
    new = []
    for i, j in q:
    for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
    if 0 <= x < n and 0 <= y < n:
    if A[x][y] == 1:
    return step
    elif not A[x][y]:
    A[x][y] = -1
    new.append((x, y))
    step += 1
    q = new
}"
935.py,"def knightDialer(self, N):
        x1 = x2 = x3 = x4 = x5 = x6 = x7 = x8 = x9 = x0 = 1
        for _ in range(N - 1):
            x1, x2, x3, x4, x5, x6, x7, x8, x9, x0 = \u005C
                x6 + x8, x7 + x9, x4 + x8, \u005C
                x7 + x9 + x0, 0, x1 + x7 + x0, \u005C
                x2 + x6, x1 + x7, x2 + x4, \u005C
                x4 + x6
        return (x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9 + x0) % (10 ** 9 + 7)","auto knightDialer(auto N) {
    x1 = x2 = x3 = x4 = x5 = x6 = x7 = x8 = x9 = x0 = 1
    for _ in range(N - 1):
    x1, x2, x3, x4, x5, x6, x7, x8, x9, x0 = \u005C
    x6 + x8, x7 + x9, x4 + x8, \u005C
    x7 + x9 + x0, 0, x1 + x7 + x0, \u005C
    x2 + x6, x1 + x7, x2 + x4, \u005C
    x4 + x6
    return (x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9 + x0) % (10 ** 9 + 7)
}"
936.py,"def movesToStamp(self, stamp, target):
        def okay(s):
            ret = False
            for c1, c2 in zip(s, stamp):
                if c1 == ""*"": continue
                elif c1 != c2: return False
                else: ret = True
            return ret
        t, move, mx, arr = ""*"" * len(target), 0, 10 * len(target), []
        while move < mx:
            pre = move
            for i in range(len(target) - len(stamp) + 1):
                if okay(target[i:i + len(stamp)]):
                    move += 1
                    arr = [i] + arr
                    target = target[:i] + ""*"" * len(stamp) + target[i + len(stamp):]
            if target == t: return arr
            if move == pre: break
        return []","auto movesToStamp(auto stamp, auto target) {
    def okay(s):
    ret = False
    for c1, c2 in zip(s, stamp):
    if c1 == ""*"": continue
    elif c1 != c2: return False
    else: ret = True
    return ret
    t, move, mx, arr = ""*"" * len(target), 0, 10 * len(target), []
    while move < mx:
    pre = move
    for i in range(len(target) - len(stamp) + 1):
    if okay(target[i:i + len(stamp)]):
    move += 1
    arr = [i] + arr
    target = target[:i] + ""*"" * len(stamp) + target[i + len(stamp):]
    if target == t: return arr
    if move == pre: break
    return []
}"
937.py,"def reorderLogFiles(self, logs):
        return sorted(filter(lambda l: l[l.find("" "") + 1].isalpha(), logs), key = lambda x: (x[x.find("" ""):], x[:x.find("" "")])) + list(filter(lambda l: l[l.find("" "") + 1].isdigit(), logs))","auto reorderLogFiles(auto logs) {
    return sorted(filter(lambda l: l[l.find("" "") + 1].isalpha(), logs), key = lambda x: (x[x.find("" ""):], x[:x.find("" "")])) + list(filter(lambda l: l[l.find("" "") + 1].isdigit(), logs))
}"
938.py,"def rangeSumBST(self, root, L, R):
        if not root: return 0
        l = self.rangeSumBST(root.left, L, R)
        r = self.rangeSumBST(root.right, L, R)
        return l + r + (L <= root.val <= R) * root.val","auto rangeSumBST(auto root, auto L, auto R) {
    if not root: return 0
    l = self.rangeSumBST(root.left, L, R)
    r = self.rangeSumBST(root.right, L, R)
    return l + r + (L <= root.val <= R) * root.val
}"
939.py,"def minAreaRect(self, points):
        seen, bases, baseX, res = collections.defaultdict(dict), [], -1, float(""inf"")
        for x, y in sorted(points):
            if x != baseX:
                baseX, bases = x, []
            for base in bases:
                if y in seen[base]:
                    res = min(res, (x - seen[base][y]) * (y - base))
                seen[base][y] = x
            bases.append(y)
        return res if res < float(""inf"") else 0","auto minAreaRect(auto points) {
    seen, bases, baseX, res = collections.defaultdict(dict), [], -1, float(""inf"")
    for x, y in sorted(points):
    if x != baseX:
    baseX, bases = x, []
    for base in bases:
    if y in seen[base]:
    res = min(res, (x - seen[base][y]) * (y - base))
    seen[base][y] = x
    bases.append(y)
    return res if res < float(""inf"") else 0
}"
940.py,"def distinctSubseqII(self, S):
        res, end = 0, collections.Counter()
        for c in S:
            res, end[c] = res * 2 + 1 - end[c], res + 1
        return res % (10**9 + 7)","auto distinctSubseqII(auto S) {
    res, end = 0, collections.Counter()
    for c in S:
    res, end[c] = res * 2 + 1 - end[c], res + 1
    return res % (10**9 + 7)
}"
941.py,"def validMountainArray(self, A):
        i = A and A.index(max(A))
        return A and 0<i<len(A)-1 and all(a1<a2 for a1,a2 in zip(A[:i],A[1:i+1])) and all(a2>a3 for a2,a3 in zip(A[i:],A[i+1:])) or False","auto validMountainArray(auto A) {
    i = A and A.index(max(A))
    return A and 0<i<len(A)-1 and all(a1<a2 for a1,a2 in zip(A[:i],A[1:i+1])) and all(a2>a3 for a2,a3 in zip(A[i:],A[i+1:])) or False
}"
942.py,"def diStringMatch(self, S):
        l, r, arr = 0, len(S), []
        for s in S:
            arr.append(l if s == ""I"" else r)
            l, r = l + (s == ""I""), r - (s == ""D"")
        return arr + [l]","auto diStringMatch(auto S) {
    l, r, arr = 0, len(S), []
    for s in S:
    arr.append(l if s == ""I"" else r)
    l, r = l + (s == ""I""), r - (s == ""D"")
    return arr + [l]
}"
943.py,"def shortestSuperstring(self, A):
        def merge(a, b):
            for i in range(len(b), 0, -1):
                if a.endswith(b[:i]):
                    return i
            return 0
        def dfs(sup, s, st):
            if len(sup + """".join(st)) < len(res[0]):
                res[0] = sup + """".join(st)
            if st and any(new in st for new in merged[s][1:]):
                for new in merged[s][1:]:
                    if new in st:
                        dfs(sup + new[merged[s][0]:], new, st - {new})
            else:
                for nex in st:
                    for new in merged[nex][1:]:
                        if new in st:
                            dfs(sup + nex + new[merged[nex][0]:], new, st - {nex, new})
        merged = {}
        for a, b in itertools.combinations(A, 2):
            for a, b in ((a, b), (b, a)):
                s = merge(a, b)
                if a not in merged or s > merged[a][0]:
                    merged[a] = [s, b]
                elif s == merged[a][0]:
                    merged[a].append(b)
        res, st = ["""".join(A)], set(A)
        for a in A:
            dfs(a, a, st - {a})
        return res[0]","auto shortestSuperstring(auto A) {
    def merge(a, b):
    for i in range(len(b), 0, -1):
    if a.endswith(b[:i]):
    return i
    return 0
    def dfs(sup, s, st):
    if len(sup + """".join(st)) < len(res[0]):
    res[0] = sup + """".join(st)
    if st and any(new in st for new in merged[s][1:]):
    for new in merged[s][1:]:
    if new in st:
    dfs(sup + new[merged[s][0]:], new, st - {new})
    else:
    for nex in st:
    for new in merged[nex][1:]:
    if new in st:
    dfs(sup + nex + new[merged[nex][0]:], new, st - {nex, new})
    merged = {}
    for a, b in itertools.combinations(A, 2):
    for a, b in ((a, b), (b, a)):
    s = merge(a, b)
    if a not in merged or s > merged[a][0]:
    merged[a] = [s, b]
    elif s == merged[a][0]:
    merged[a].append(b)
    res, st = ["""".join(A)], set(A)
    for a in A:
    dfs(a, a, st - {a})
    return res[0]
}"
944.py,"def minDeletionSize(self, A):
        return sum(any(a[j] > b[j] for a, b in zip(A, A[1:])) for j in range(len(A[0])))","auto minDeletionSize(auto A) {
    return sum(any(a[j] > b[j] for a, b in zip(A, A[1:])) for j in range(len(A[0])))
}"
945.py,"def minIncrementForUnique(self, A):
        st, used, move = set(A), set(), 0
        heapq.heapify(A)
        empty = [i for i in range(80000) if i not in st][::-1] if A else [] 
        while A:
            num = heapq.heappop(A)
            if num not in used:
                used.add(num)
            else:
                while empty[-1] < num:
                    empty.pop()
                move += empty[-1] - num
                heapq.heappush(A, empty.pop())
        return move","auto minIncrementForUnique(auto A) {
    st, used, move = set(A), set(), 0
    heapq.heapify(A)
    empty = [i for i in range(80000) if i not in st][::-1] if A else []
    while A:
    num = heapq.heappop(A)
    if num not in used:
    used.add(num)
    else:
    while empty[-1] < num:
    empty.pop()
    move += empty[-1] - num
    heapq.heappush(A, empty.pop())
    return move
}"
946.py,"def validateStackSequences(self, pushed, popped):
        """"""
        :type pushed: List[int]
        :type popped: List[int]
        :rtype: bool
        """"""
        arr, i = [], 0
        for num in pushed:
            arr.append(num)
            while arr and arr[-1] == popped[i]:
                i += 1
                arr.pop()
        return arr == popped[i:][::-1]","auto validateStackSequences(auto pushed, auto popped) {
    """"""
    :type pushed: List[int]
    :type popped: List[int]
    :rtype: bool
    """"""
    arr, i = [], 0
    for num in pushed:
    arr.append(num)
    while arr and arr[-1] == popped[i]:
    i += 1
    arr.pop()
    return arr == popped[i:][::-1]
}"
947.py,"def removeStones(self, stones):
        def dfs(i, j):
            points.discard((i, j))
            for y in rows[i]:
                if (i, y) in points:
                    dfs(i, y)
            for x in cols[j]:
                if (x, j) in points:
                    dfs(x, j)
        points, island, rows, cols = {(i, j) for i, j in stones}, 0, collections.defaultdict(list), collections.defaultdict(list)
        for i, j in stones:
            rows[i].append(j)
            cols[j].append(i)
        for i, j in stones:
            if (i, j) in points:
                dfs(i, j)
                island += 1
        return len(stones) - island","auto removeStones(auto stones) {
    def dfs(i, j):
    points.discard((i, j))
    for y in rows[i]:
    if (i, y) in points:
    dfs(i, y)
    for x in cols[j]:
    if (x, j) in points:
    dfs(x, j)
    points, island, rows, cols = {(i, j) for i, j in stones}, 0, collections.defaultdict(list), collections.defaultdict(list)
    for i, j in stones:
    rows[i].append(j)
    cols[j].append(i)
    for i, j in stones:
    if (i, j) in points:
    dfs(i, j)
    island += 1
    return len(stones) - island
}"
948.py,"def bagOfTokensScore(self, tokens, P):
        """"""
        :type tokens: List[int]
        :type P: int
        :rtype: int
        """"""
        tokens.sort()
        l, r, score = 0, len(tokens) - 1, 0
        while l <= r:
            if P >= tokens[l]:
                P -= tokens[l]
                score += 1
                l += 1
            elif score and l != r:
                P += tokens[r]
                score -= 1
                r -= 1
            else:
                break
        return score","auto bagOfTokensScore(auto tokens, auto P) {
    """"""
    :type tokens: List[int]
    :type P: int
    :rtype: int
    """"""
    tokens.sort()
    l, r, score = 0, len(tokens) - 1, 0
    while l <= r:
    if P >= tokens[l]:
    P -= tokens[l]
    score += 1
    l += 1
    elif score and l != r:
    P += tokens[r]
    score -= 1
    r -= 1
    else:
    break
    return score
}"
949.py,"def largestTimeFromDigits(self, A):
        h = m = -float(""inf"")
        for n1, n2, n3, n4 in itertools.permutations(A):
            hh, mm = n1 * 10 + n2, n3 * 10 + n4
            if 0 <= hh <= 23 and 0 <= mm <= 59 and (hh > h or hh == h and mm > m):
                h, m = hh, mm
        sh = str(h) if h > 9 else ""0"" + str(h)
        sm = str(m) if m > 9 else ""0"" + str(m)
        return 0 <= h <= 23 and 0 <= m <= 59 and sh + "":"" + sm or """"","auto largestTimeFromDigits(auto A) {
    h = m = -float(""inf"")
    for n1, n2, n3, n4 in itertools.permutations(A):
    hh, mm = n1 * 10 + n2, n3 * 10 + n4
    if 0 <= hh <= 23 and 0 <= mm <= 59 and (hh > h or hh == h and mm > m):
    h, m = hh, mm
    sh = str(h) if h > 9 else ""0"" + str(h)
    sm = str(m) if m > 9 else ""0"" + str(m)
    return 0 <= h <= 23 and 0 <= m <= 59 and sh + "":"" + sm or """"
}"
950.py,"def deckRevealedIncreasing(self, deck):
        ind = list(range(len(deck)))
        for num in sorted(deck):
            deck[ind[0]] = num
            ind = ind[2:] + [ind[1]] if len(ind) > 1 else []
        return deck","auto deckRevealedIncreasing(auto deck) {
    ind = list(range(len(deck)))
    for num in sorted(deck):
    deck[ind[0]] = num
    ind = ind[2:] + [ind[1]] if len(ind) > 1 else []
    return deck
}"
951.py,"def flipEquiv(self, root1, root2):
        if not root1 or not root2: return root1 == root2
        if root1.left and root2.left and root1.left.val != root2.left.val or (not root1.left and root2.left) or (root1.left and not root2.left):
            root1.left, root1.right = root1.right, root1.left
        return root1.val == root2.val and self.flipEquiv(root1.left, root2.left) and self.flipEquiv(root1.right, root2.right)","auto flipEquiv(auto root1, auto root2) {
    if not root1 or not root2: return root1 == root2
    if root1.left and root2.left and root1.left.val != root2.left.val or (not root1.left and root2.left) or (root1.left and not root2.left):
    root1.left, root1.right = root1.right, root1.left
    return root1.val == root2.val and self.flipEquiv(root1.left, root2.left) and self.flipEquiv(root1.right, root2.right)
}"
952.py,"def largestComponentSize(self, A):
        def find(i):
            return i if i == parent[i] else find(parent[i])
        
        def prime_factors(n):  
            res = set()
            while n % 2 == 0: 
                res.add(2)
                n //= 2
            for i in range(3, int(n**0.5) + 1, 2): 
                while n % i== 0: 
                    res.add(i) 
                    n //= i 
            if n > 2: 
                res.add(n)
            return res
        parent, dic = list(range(len(A))), {} 
        for i, n in enumerate(A):
            for p in prime_factors(n):
                if p in dic:
                    parent[find(i)] = find(dic[p])
                dic[p] = i
        for i, x in enumerate(parent):
            parent[i] = find(x)
        return max(collections.Counter(parent).values())","auto largestComponentSize(auto A) {
    def find(i):
    return i if i == parent[i] else find(parent[i])
    
    def prime_factors(n):
    res = set()
    while n % 2 == 0:
    res.add(2)
    n //= 2
    for i in range(3, int(n**0.5) + 1, 2):
    while n % i== 0:
    res.add(i)
    n //= i
    if n > 2:
    res.add(n)
    return res
    parent, dic = list(range(len(A))), {}
    for i, n in enumerate(A):
    for p in prime_factors(n):
    if p in dic:
    parent[find(i)] = find(dic[p])
    dic[p] = i
    for i, x in enumerate(parent):
    parent[i] = find(x)
    return max(collections.Counter(parent).values())
}"
953.py,"def isAlienSorted(self, words, order):
        """"""
        :type words: List[str]
        :type order: str
        :rtype: bool
        """"""
        ind = {c: i for i, c in enumerate(order)}
        for a, b in zip(words, words[1:]):
            if len(a) > len(b) and a[:len(b)] == b:
                return False
            for s1, s2 in zip(a, b):
                if ind[s1] < ind[s2]:
                    break
                elif ind[s1] == ind[s2]:
                    continue
                else: 
                    return False
        return True","auto isAlienSorted(auto words, auto order) {
    """"""
    :type words: List[str]
    :type order: str
    :rtype: bool
    """"""
    ind = {c: i for i, c in enumerate(order)}
    for a, b in zip(words, words[1:]):
    if len(a) > len(b) and a[:len(b)] == b:
    return False
    for s1, s2 in zip(a, b):
    if ind[s1] < ind[s2]:
    break
    elif ind[s1] == ind[s2]:
    continue
    else:
    return False
    return True
}"
954.py,"def canReorderDoubled(self, A):
        cnt = collections.Counter(A)
        for a in sorted(A, key = abs):
            if cnt[a] and cnt[a * 2]:
                cnt[a] -= 1
                cnt[a * 2] -= 1
            elif cnt[a] and a % 2 == 0 and cnt[a // 2]:
                cnt[a] -= 1
                cnt[a // 2] -= 1   
        return all(cnt[a] == 0 for a in A)","auto canReorderDoubled(auto A) {
    cnt = collections.Counter(A)
    for a in sorted(A, key = abs):
    if cnt[a] and cnt[a * 2]:
    cnt[a] -= 1
    cnt[a * 2] -= 1
    elif cnt[a] and a % 2 == 0 and cnt[a // 2]:
    cnt[a] -= 1
    cnt[a // 2] -= 1
    return all(cnt[a] == 0 for a in A)
}"
955.py,"def minDeletionSize(self, A):
        res = 0
        cur = [""""] * len(A)
        for col in zip(*A):
            cur2 = list(zip(cur, col))
            if cur2 == sorted(cur2):
                cur = cur2
            else:
                res += 1
        return res","auto minDeletionSize(auto A) {
    res = 0
    cur = [""""] * len(A)
    for col in zip(*A):
    cur2 = list(zip(cur, col))
    if cur2 == sorted(cur2):
    cur = cur2
    else:
    res += 1
    return res
}"
956.py,"def tallestBillboard(self, rods):
        dp = {0: 0}
        for x in rods:
            for d, h in list(dp.items()):
                dp[d + x] = max(dp.get(x + d, 0), h)
                dp[abs(d - x)] = max(dp.get(abs(d - x), 0), h + min(d, x))
        return dp[0]         ","auto tallestBillboard(auto rods) {
    dp = {0: 0}
    for x in rods:
    for d, h in list(dp.items()):
    dp[d + x] = max(dp.get(x + d, 0), h)
    dp[abs(d - x)] = max(dp.get(abs(d - x), 0), h + min(d, x))
    return dp[0]
}"
957.py,"def prisonAfterNDays(self, cells, N):
        day, state, cur = 0, {}, """".join(map(str, cells))
        while cur not in state:
            state[cur] = day
            state[day] = cur
            if day == N:
                return list(map(int, cur))
            day += 1
            cur = ""0"" + """".join(cur[i - 1] == cur[i + 1] and ""1"" or ""0"" for i in range(1, len(cur) - 1)) + ""0""
        return list(map(int, state[state[cur] + (N - state[cur]) % (day - state[cur])]))","auto prisonAfterNDays(auto cells, auto N) {
    day, state, cur = 0, {}, """".join(map(str, cells))
    while cur not in state:
    state[cur] = day
    state[day] = cur
    if day == N:
    return list(map(int, cur))
    day += 1
    cur = ""0"" + """".join(cur[i - 1] == cur[i + 1] and ""1"" or ""0"" for i in range(1, len(cur) - 1)) + ""0""
    return list(map(int, state[state[cur] + (N - state[cur]) % (day - state[cur])]))
}"
958.py,"def isCompleteTree(self, root):
        q, pre = [root, None], 1
        while any(q):
            i = q.index(None)
            if any(q[i:]) or pre > 1:
                return False
            pre = len(q[i:])
            q = [child for node in q[:i] for child in (node.left, node.right)] + [None]
        return True","auto isCompleteTree(auto root) {
    q, pre = [root, None], 1
    while any(q):
    i = q.index(None)
    if any(q[i:]) or pre > 1:
    return False
    pre = len(q[i:])
    q = [child for node in q[:i] for child in (node.left, node.right)] + [None]
    return True
}"
959.py,"def regionsBySlashes(self, grid):
        def dfs(i, j, k):
            if 0 <= i < n > j >= 0 and not matrix[i][j][k]:
                if grid[i][j] == ""*"":
                    if k <= 1:
                        matrix[i][j][0] = matrix[i][j][1] = cnt
                        dfs(i - 1, j, 2)
                        dfs(i, j + 1, 3)
                    else:
                        matrix[i][j][2] = matrix[i][j][3] = cnt
                        dfs(i + 1, j, 0)
                        dfs(i, j - 1, 1)
                elif grid[i][j] == ""/"":
                    if 1 <= k <= 2:
                        matrix[i][j][1] = matrix[i][j][2] = cnt
                        dfs(i, j + 1, 3)
                        dfs(i + 1, j, 0)
                    else:
                        matrix[i][j][0] = matrix[i][j][3] = cnt
                        dfs(i - 1, j, 2)
                        dfs(i, j - 1, 1)
                else:
                    matrix[i][j][0] = matrix[i][j][1] = matrix[i][j][2] = matrix[i][j][3] = cnt
                    dfs(i - 1, j, 2)
                    dfs(i, j + 1, 3)
                    dfs(i + 1, j, 0)
                    dfs(i, j - 1, 1)
        grid, n = [row.replace(""\u005C\u005C"", ""*"") for row in grid], len(grid)
        matrix, cnt = [[[0, 0, 0, 0] for j in range(n)] for i in range(n)], 0
        for i in range(n):
            for j in range(n):
                for k in range(4):
                    if not matrix[i][j][k]:
                        cnt += 1
                        dfs(i, j, k)
        return cnt","auto regionsBySlashes(auto grid) {
    def dfs(i, j, k):
    if 0 <= i < n > j >= 0 and not matrix[i][j][k]:
    if grid[i][j] == ""*"":
    if k <= 1:
    matrix[i][j][0] = matrix[i][j][1] = cnt
    dfs(i - 1, j, 2)
    dfs(i, j + 1, 3)
    else:
    matrix[i][j][2] = matrix[i][j][3] = cnt
    dfs(i + 1, j, 0)
    dfs(i, j - 1, 1)
    elif grid[i][j] == ""/"":
    if 1 <= k <= 2:
    matrix[i][j][1] = matrix[i][j][2] = cnt
    dfs(i, j + 1, 3)
    dfs(i + 1, j, 0)
    else:
    matrix[i][j][0] = matrix[i][j][3] = cnt
    dfs(i - 1, j, 2)
    dfs(i, j - 1, 1)
    else:
    matrix[i][j][0] = matrix[i][j][1] = matrix[i][j][2] = matrix[i][j][3] = cnt
    dfs(i - 1, j, 2)
    dfs(i, j + 1, 3)
    dfs(i + 1, j, 0)
    dfs(i, j - 1, 1)
    grid, n = [row.replace(""\u005C\u005C"", ""*"") for row in grid], len(grid)
    matrix, cnt = [[[0, 0, 0, 0] for j in range(n)] for i in range(n)], 0
    for i in range(n):
    for j in range(n):
    for k in range(4):
    if not matrix[i][j][k]:
    cnt += 1
    dfs(i, j, k)
    return cnt
}"
96.py,"def numTrees(self, n):
        if n <= 1:
            return 1
        catalan = [0] * (n + 1)
        catalan[0] = catalan[1] = 1
        for i in range(2, n + 1):
            for j in range(i):
                catalan[i] += catalan[j] * catalan[i - j - 1]
        return catalan[n]","auto numTrees(auto n) {
    if n <= 1:
    return 1
    catalan = [0] * (n + 1)
    catalan[0] = catalan[1] = 1
    for i in range(2, n + 1):
    for j in range(i):
    catalan[i] += catalan[j] * catalan[i - j - 1]
    return catalan[n]
}"
960.py,"def minDeletionSize(self, A):
        m, n = len(A), len(A[0])
        dp = [1] * n
        for j in range(1, n):
            for i in range(j):
                if all(A[k][i] <= A[k][j] for k in range(m)):
                    dp[j] = max(dp[j], dp[i] + 1)
        return n - max(dp)","auto minDeletionSize(auto A) {
    m, n = len(A), len(A[0])
    dp = [1] * n
    for j in range(1, n):
    for i in range(j):
    if all(A[k][i] <= A[k][j] for k in range(m)):
    dp[j] = max(dp[j], dp[i] + 1)
    return n - max(dp)
}"
961.py,"def repeatedNTimes(self, A):
        """"""
        :type A: List[int]
        :rtype: int
        """"""
        return collections.Counter(A).most_common(1)[0][0]","auto repeatedNTimes(auto A) {
    """"""
    :type A: List[int]
    :rtype: int
    """"""
    return collections.Counter(A).most_common(1)[0][0]
}"
962.py,"def maxWidthRamp(self, A):
        """"""
        :type A: List[int]
        :rtype: int
        """"""
        ind, mx, index = float(""inf""), 0, collections.defaultdict(list)
        for i, num in enumerate(A):
            index[num].append(i)
        A.sort()
        for i in range(len(A)):
            mx = max(mx, index[A[i]][-1] - ind)
            ind = min(ind, index[A[i]][0])
        return mx","auto maxWidthRamp(auto A) {
    """"""
    :type A: List[int]
    :rtype: int
    """"""
    ind, mx, index = float(""inf""), 0, collections.defaultdict(list)
    for i, num in enumerate(A):
    index[num].append(i)
    A.sort()
    for i in range(len(A)):
    mx = max(mx, index[A[i]][-1] - ind)
    ind = min(ind, index[A[i]][0])
    return mx
}"
963.py,"
def minAreaFreeRect(self, points):
        mn, st, n = float('inf'), {(x, y) for x, y in points}, len(points) 
        for i in range(n):
            x1, y1 = points[i]
            for j in range(i + 1, n):
                x2, y2 = points[j]
                for k in range(j + 1, n):
                    x3, y3 = points[k]
                    if not (x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1) and (x3 + (x2 - x1), y3 + (y2 - y1)) in st:
                        mn = min(mn, ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5 * ((x3 - x1) ** 2 + (y3 - y1) ** 2) ** 0.5)
        return mn if mn < float(""inf"") else 0","auto minAreaFreeRect(auto points) {
    mn, st, n = float('inf'), {(x, y) for x, y in points}, len(points)
    for i in range(n):
    x1, y1 = points[i]
    for j in range(i + 1, n):
    x2, y2 = points[j]
    for k in range(j + 1, n):
    x3, y3 = points[k]
    if not (x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1) and (x3 + (x2 - x1), y3 + (y2 - y1)) in st:
    mn = min(mn, ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5 * ((x3 - x1) ** 2 + (y3 - y1) ** 2) ** 0.5)
    return mn if mn < float(""inf"") else 0
}"
964.py,"def leastOpsExpressTarget(self, x: int, y: int) -> int:
        pos = neg = k = 0
        while y:
            y, cur = divmod(y, x)
            if k:
                pos, neg = min(cur * k + pos, (cur + 1) * k + neg), min((x - cur) * k + pos, (x - cur - 1) * k + neg)
            else:
                pos, neg = cur * 2, (x - cur) * 2
            k += 1
        return min(pos, k + neg) - 1","auto leastOpsExpressTarget(auto x, auto y) {
    pos = neg = k = 0
    while y:
    y, cur = divmod(y, x)
    if k:
    pos, neg = min(cur * k + pos, (cur + 1) * k + neg), min((x - cur) * k + pos, (x - cur - 1) * k + neg)
    else:
    pos, neg = cur * 2, (x - cur) * 2
    k += 1
    return min(pos, k + neg) - 1
}"
966.py,"def spellchecker(self, wordlist, queries):
        """"""
        :type wordlist: List[str]
        :type queries: List[str]
        :rtype: List[str]
        """"""
        st, cap, vow = set(wordlist), {}, {}
        for w in wordlist:
            newC = w.lower()
            newW = """".join(c if c not in ""aeiou"" else ""*"" for c in newC)
            if newC not in cap:
                cap[newC] = w
            if newW not in vow:
                vow[newW] = w
        for i, w in enumerate(queries):
            if w in st:
                pass
            elif w.lower() in cap:
                queries[i] = cap[w.lower()]
            else:
                new = """".join(c if c not in ""aeiou"" else ""*"" for c in w.lower())
                if new in vow:
                    queries[i] = vow[new]
                else:
                    queries[i] = """"
        return queries","auto spellchecker(auto wordlist, auto queries) {
    """"""
    :type wordlist: List[str]
    :type queries: List[str]
    :rtype: List[str]
    """"""
    st, cap, vow = set(wordlist), {}, {}
    for w in wordlist:
    newC = w.lower()
    newW = """".join(c if c not in ""aeiou"" else ""*"" for c in newC)
    if newC not in cap:
    cap[newC] = w
    if newW not in vow:
    vow[newW] = w
    for i, w in enumerate(queries):
    if w in st:
    pass
    elif w.lower() in cap:
    queries[i] = cap[w.lower()]
    else:
    new = """".join(c if c not in ""aeiou"" else ""*"" for c in w.lower())
    if new in vow:
    queries[i] = vow[new]
    else:
    queries[i] = """"
    return queries
}"
967.py,"def numsSameConsecDiff(self, N, K):
        """"""
        :type N: int
        :type K: int
        :rtype: List[int]
        """"""
        q = {i for i in range(10)}
        for _ in range(N - 1):
            new = set()
            for num in q:
                last = num % 10
                if num and 0 <= last + K <= 9:
                    new.add(num * 10 + last + K)
                if num and 0 <= last - K <= 9:
                    new.add(num * 10 + last - K)
            q = new
        return list(q)","auto numsSameConsecDiff(auto N, auto K) {
    """"""
    :type N: int
    :type K: int
    :rtype: List[int]
    """"""
    q = {i for i in range(10)}
    for _ in range(N - 1):
    new = set()
    for num in q:
    last = num % 10
    if num and 0 <= last + K <= 9:
    new.add(num * 10 + last + K)
    if num and 0 <= last - K <= 9:
    new.add(num * 10 + last - K)
    q = new
    return list(q)
}"
969.py,"def pancakeSort(self, A):
        res = []
        for x in range(len(A), 1, -1):
            i = A.index(x)
            res.extend([i + 1, x])
            A = A[:i:-1] + A[:i]
        return res  ","auto pancakeSort(auto A) {
    res = []
    for x in range(len(A), 1, -1):
    i = A.index(x)
    res.extend([i + 1, x])
    A = A[:i:-1] + A[:i]
    return res
}"
97.py,"def isInterleave(self, s1, s2, s3):
        def dfs(i, j, k):
            if (i, j, k) not in memo:
                memo[(i, j, k)] = k>=l3 or (i<l1 and s3[k]==s1[i] and dfs(i+1,j,k+1)) or (j<l2 and s3[k]==s2[j] and dfs(i,j+1,k+1))
            return memo[(i, j, k)]
        l1, l2, l3, memo = len(s1), len(s2), len(s3), {}
        if l3 != l1 + l2: return False
        return dfs(0, 0, 0)","auto isInterleave(auto s1, auto s2, auto s3) {
    def dfs(i, j, k):
    if (i, j, k) not in memo:
    memo[(i, j, k)] = k>=l3 or (i<l1 and s3[k]==s1[i] and dfs(i+1,j,k+1)) or (j<l2 and s3[k]==s2[j] and dfs(i,j+1,k+1))
    return memo[(i, j, k)]
    l1, l2, l3, memo = len(s1), len(s2), len(s3), {}
    if l3 != l1 + l2: return False
    return dfs(0, 0, 0)
}"
970.py,"def powerfulIntegers(self, x, y, bound):
        """"""
        :type x: int
        :type y: int
        :type bound: int
        :rtype: List[int]
        """"""
        res = set()
        i = j = 0
        while x ** i <= bound:
            while x ** i + y ** j <= bound:
                if x ** i + y ** j not in res:
                    res.add(x ** i + y ** j)
                j += 1
                if y == 1: 
                    break
            j = 0
            i += 1
            if x == 1:
                break
        return list(res)
","auto powerfulIntegers(auto x, auto y, auto bound) {
    """"""
    :type x: int
    :type y: int
    :type bound: int
    :rtype: List[int]
    """"""
    res = set()
    i = j = 0
    while x ** i <= bound:
    while x ** i + y ** j <= bound:
    if x ** i + y ** j not in res:
    res.add(x ** i + y ** j)
    j += 1
    if y == 1:
    break
    j = 0
    i += 1
    if x == 1:
    break
    return list(res)
}"
972.py,"def isRationalEqual(self, S, T):
        def f(s):
            i = s.find('(')
            if i >= 0:
                s = s[:i] + s[i + 1:-1] * 20
            return float(s[:20])
        return f(S) == f(T)","auto isRationalEqual(auto S, auto T) {
    def f(s):
    i = s.find('(')
    if i >= 0:
    s = s[:i] + s[i + 1:-1] * 20
    return float(s[:20])
    return f(S) == f(T)
}"
973.py,"def kClosest(self, points, K):
        return sorted(points, key = lambda p: p[0] ** 2 + p[1] ** 2)[:K]","auto kClosest(auto points, auto K) {
    return sorted(points, key = lambda p: p[0] ** 2 + p[1] ** 2)[:K]
}"
974.py,"def subarraysDivByK(self, A: List[int], K: int) -> int:
        res = sm = 0
        sums = collections.defaultdict(int)
        sums[0] = 1
        for a in A:
            sm = (sm + a) % K
            sums[sm] += 1
            res += sums[sm] - 1
        return res","auto subarraysDivByK(auto A, auto K) {
    res = sm = 0
    sums = collections.defaultdict(int)
    sums[0] = 1
    for a in A:
    sm = (sm + a) % K
    sums[sm] += 1
    res += sums[sm] - 1
    return res
}"
975.py,"def oddEvenJumps(self, A: List[int]) -> int:
        n = len(A)
        next_higher, next_lower = [0] * n, [0] * n

        stack = []
        for a, i in sorted([a, i] for i, a in enumerate(A)):
            while stack and stack[-1] < i:
                next_higher[stack.pop()] = i
            stack.append(i)

        stack = []
        for a, i in sorted([-a, i] for i, a in enumerate(A)):
            while stack and stack[-1] < i:
                next_lower[stack.pop()] = i
            stack.append(i)

        higher, lower = [0] * n, [0] * n
        higher[-1] = lower[-1] = 1
        for i in range(n - 1)[::-1]:
            higher[i] = lower[next_higher[i]]
            lower[i] = higher[next_lower[i]]
        return sum(higher)
        ","auto oddEvenJumps(auto A) {
    n = len(A)
    next_higher, next_lower = [0] * n, [0] * n
    
    stack = []
    for a, i in sorted([a, i] for i, a in enumerate(A)):
    while stack and stack[-1] < i:
    next_higher[stack.pop()] = i
    stack.append(i)
    
    stack = []
    for a, i in sorted([-a, i] for i, a in enumerate(A)):
    while stack and stack[-1] < i:
    next_lower[stack.pop()] = i
    stack.append(i)
    
    higher, lower = [0] * n, [0] * n
    higher[-1] = lower[-1] = 1
    for i in range(n - 1)[::-1]:
    higher[i] = lower[next_higher[i]]
    lower[i] = higher[next_lower[i]]
    return sum(higher)
}"
976.py,"def largestPerimeter(self, A):
        """"""
        :type A: List[int]
        :rtype: int
        """"""
        A.sort()
        return ([0] + [a + b + c for a, b, c in zip(A, A[1:], A[2:]) if c < a + b])[-1]","auto largestPerimeter(auto A) {
    """"""
    :type A: List[int]
    :rtype: int
    """"""
    A.sort()
    return ([0] + [a + b + c for a, b, c in zip(A, A[1:], A[2:]) if c < a + b])[-1]
}"
977.py,"def sortedSquares(self, A):
        """"""
        :type A: List[int]
        :rtype: List[int]
        """"""
        return sorted([x ** 2 for x in A])","auto sortedSquares(auto A) {
    """"""
    :type A: List[int]
    :rtype: List[int]
    """"""
    return sorted([x ** 2 for x in A])
}"
978.py,"def maxTurbulenceSize(self, A):
        arr = [A[i - 1] < A[i] for i in range(1, len(A))]
        cur = mx = 1 + (len(A) > 1)
        for i in range(1, len(arr)):
            if A[i] != A[i + 1] and arr[i] != arr[i - 1]:
                cur += 1
                mx = max(cur, mx)
            else:
                cur = 2
        return mx","auto maxTurbulenceSize(auto A) {
    arr = [A[i - 1] < A[i] for i in range(1, len(A))]
    cur = mx = 1 + (len(A) > 1)
    for i in range(1, len(arr)):
    if A[i] != A[i + 1] and arr[i] != arr[i - 1]:
    cur += 1
    mx = max(cur, mx)
    else:
    cur = 2
    return mx
}"
979.py,"def distributeCoins(self, root):
        self.ans = 0

        def dfs(node):
            if not node: return 0
            L, R = dfs(node.left), dfs(node.right)
            self.ans += abs(L) + abs(R)
            return node.val + L + R - 1

        dfs(root)
        return self.ans","auto distributeCoins(auto root) {
    self.ans = 0
    
    def dfs(node):
    if not node: return 0
    L, R = dfs(node.left), dfs(node.right)
    self.ans += abs(L) + abs(R)
    return node.val + L + R - 1
    
    dfs(root)
    return self.ans
}"
980.py,"def uniquePathsIII(self, grid: List[List[int]]) -> int:
        def dfs(i, j, visited):
            if grid[i][j] == 2:
                self.walks += visited == self.visit
                return
            for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
                if 0 <= x < m and 0 <= y < n and grid[x][y] != -1:
                    grid[i][j] -= 1
                    dfs(x, y, visited + 1)
                    grid[i][j] += 1
        m, n = len(grid), len(grid[0])
        self.visit = m * n - sum(c == -1 for row in grid for c in row)
        self.walks = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    grid[i][j] -= 1
                    dfs(i, j, 1)
        return self.walks","auto uniquePathsIII(auto grid) {
    def dfs(i, j, visited):
    if grid[i][j] == 2:
    self.walks += visited == self.visit
    return
    for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
    if 0 <= x < m and 0 <= y < n and grid[x][y] != -1:
    grid[i][j] -= 1
    dfs(x, y, visited + 1)
    grid[i][j] += 1
    m, n = len(grid), len(grid[0])
    self.visit = m * n - sum(c == -1 for row in grid for c in row)
    self.walks = 0
    for i in range(m):
    for j in range(n):
    if grid[i][j] == 1:
    grid[i][j] -= 1
    dfs(i, j, 1)
    return self.walks
}"
982.py,"def countTriplets(self, A: List[int]) -> int:
        cnt = collections.Counter([a & b for a in A for b in A])
        return sum(cnt[k] for a in A for k in cnt if not a & k)","auto countTriplets(auto A) {
    cnt = collections.Counter([a & b for a in A for b in A])
    return sum(cnt[k] for a in A for k in cnt if not a & k)
}"
983.py,"def mincostTickets(self, days: List[int], costs: List[int]) -> int:
        day, days, last = [0] * 366, set(days), days[-1]
        for i in range(1, last + 1):
            if i not in days:
                day[i] = day[i - 1]
            else:
                day[i] = min(day[i - 1] + costs[0], day[i - 7 if i>= 7 else 0] + costs[1], day[i - 30 if i >= 30 else 0] + costs[2])
        return day[last]","auto mincostTickets(auto days, auto costs) {
    day, days, last = [0] * 366, set(days), days[-1]
    for i in range(1, last + 1):
    if i not in days:
    day[i] = day[i - 1]
    else:
    day[i] = min(day[i - 1] + costs[0], day[i - 7 if i>= 7 else 0] + costs[1], day[i - 30 if i >= 30 else 0] + costs[2])
    return day[last]
}"
984.py,"def strWithout3a3b(self, A: int, B: int) -> str:
        if not A and not B: return ''
        if A >= B:
            a = 2 if A >= 2 else 1
            b = 2 if A - a - B < 1 and B >= 2 else 1 if B else 0
            return a * 'a' + b * 'b' + self.strWithout3a3b(A - a, B - b)
        else:
            b = 2 if B >= 2 else 1
            a = 2 if B - b - A < 1 and A >= 2 else 1 if A else 0
            return b * 'b' + a * 'a' + self.strWithout3a3b(A - a, B - b)
            ","auto strWithout3a3b(auto A, auto B) {
    if not A and not B: return ''
    if A >= B:
    a = 2 if A >= 2 else 1
    b = 2 if A - a - B < 1 and B >= 2 else 1 if B else 0
    return a * 'a' + b * 'b' + self.strWithout3a3b(A - a, B - b)
    else:
    b = 2 if B >= 2 else 1
    a = 2 if B - b - A < 1 and A >= 2 else 1 if A else 0
    return b * 'b' + a * 'a' + self.strWithout3a3b(A - a, B - b)
}"
985.py,"def sumEvenAfterQueries(self, A: List[int], queries: List[List[int]]) -> List[int]:
        sm = sum(a for a in A if a % 2 == 0)
        for i in range(len(queries)):
            val, ind = queries[i]
            sm -= A[ind] % 2 == 0 and A[ind]
            A[ind] += val
            sm += A[ind] % 2 == 0 and A[ind]
            queries[i] = sm
        return queries","auto sumEvenAfterQueries(auto A, auto queries) {
    sm = sum(a for a in A if a % 2 == 0)
    for i in range(len(queries)):
    val, ind = queries[i]
    sm -= A[ind] % 2 == 0 and A[ind]
    A[ind] += val
    sm += A[ind] % 2 == 0 and A[ind]
    queries[i] = sm
    return queries
}"
986.py,"def intervalIntersection(self, A: List[Interval], B: List[Interval]) -> List[Interval]:
        i = j = 0
        res = []
        while i < len(A) and j < len(B):
            s = max(A[i].start, B[j].start)
            e = min(A[i].end, B[j].end)
            if s <= e:
                res.append(Interval(s, e))
            if A[i].end < B[j].end:
                i += 1
            elif A[i].end == B[j].end:
                i += 1
                j += 1
            else:
                j += 1
        return res","auto intervalIntersection(auto A, auto B) {
    i = j = 0
    res = []
    while i < len(A) and j < len(B):
    s = max(A[i].start, B[j].start)
    e = min(A[i].end, B[j].end)
    if s <= e:
    res.append(Interval(s, e))
    if A[i].end < B[j].end:
    i += 1
    elif A[i].end == B[j].end:
    i += 1
    j += 1
    else:
    j += 1
    return res
}"
987.py,"def verticalTraversal(self, root: TreeNode) -> List[List[int]]:
        self.arr = []
        def dfs(node, x, y):
            if node:
                self.arr.append((x, y, node.val))
                dfs(node.left, x - 1, y + 1)
                dfs(node.right, x + 1, y + 1)
        dfs(root, 0, 0)
        return [list(map(lambda x: x[-1], g)) for k, g in itertools.groupby(sorted(self.arr), key = lambda x: x[0])]","auto verticalTraversal(auto root) {
    self.arr = []
    def dfs(node, x, y):
    if node:
    self.arr.append((x, y, node.val))
    dfs(node.left, x - 1, y + 1)
    dfs(node.right, x + 1, y + 1)
    dfs(root, 0, 0)
    return [list(map(lambda x: x[-1], g)) for k, g in itertools.groupby(sorted(self.arr), key = lambda x: x[0])]
}"
988.py,"def smallestFromLeaf(self, root: TreeNode, s = '') -> str:
        if not root.right and not root.left:
            return chr(97 + root.val) + s
        if not root.right:
            return self.smallestFromLeaf(root.left, chr(97 + root.val) + s)
        if not root.left:
            return self.smallestFromLeaf(root.right, chr(97 + root.val) + s)
        return min(self.smallestFromLeaf(root.left, chr(97 + root.val) + s), self.smallestFromLeaf(root.right, chr(97 + root.val) + s))","auto smallestFromLeaf(auto root, auto s = '') {
    if not root.right and not root.left:
    return chr(97 + root.val) + s
    if not root.right:
    return self.smallestFromLeaf(root.left, chr(97 + root.val) + s)
    if not root.left:
    return self.smallestFromLeaf(root.right, chr(97 + root.val) + s)
    return min(self.smallestFromLeaf(root.left, chr(97 + root.val) + s), self.smallestFromLeaf(root.right, chr(97 + root.val) + s))
}"
989.py,"def addToArrayForm(self, A, K):
        for i in range(len(A))[::-1]:
            A[i], K = (A[i] + K) % 10, (A[i] + K) // 10
        return [int(i) for i in str(K)] + A if K else A","auto addToArrayForm(auto A, auto K) {
    for i in range(len(A))[::-1]:
    A[i], K = (A[i] + K) % 10, (A[i] + K) // 10
    return [int(i) for i in str(K)] + A if K else A
}"
990.py,"def equationsPossible(self, equations: List[str]) -> bool:
        def uf(c):
            return uf(parent[ord(c) - ord('a')]) if parent[ord(c) - ord('a')] != c else ord(c) - ord('a')
        parent = [c for c in string.ascii_lowercase]
        for eq in equations:
            if eq[1] == '=':
                parent[uf(eq[0])] = parent[uf(eq[-1])]
        for eq in equations:
            if eq[1] == '!' and parent[uf(eq[0])] == parent[uf(eq[-1])]:
                return False
        return True","auto equationsPossible(auto equations) {
    def uf(c):
    return uf(parent[ord(c) - ord('a')]) if parent[ord(c) - ord('a')] != c else ord(c) - ord('a')
    parent = [c for c in string.ascii_lowercase]
    for eq in equations:
    if eq[1] == '=':
    parent[uf(eq[0])] = parent[uf(eq[-1])]
    for eq in equations:
    if eq[1] == '!' and parent[uf(eq[0])] == parent[uf(eq[-1])]:
    return false
    return true
}"
991.py,"def brokenCalc(self, X, Y):
        res = 0
        while X < Y:
            res += Y % 2 + 1
            Y = (Y + 1) // 2
        return res + X - Y","auto brokenCalc(auto X, auto Y) {
    res = 0
    while X < Y:
    res += Y % 2 + 1
    Y = (Y + 1) // 2
    return res + X - Y
}"
993.py,"def isCousins(self, root: TreeNode, x: int, y: int) -> bool:
        def dfs(node, parent, depth, mod):
            if node:
                if node.val == mod:
                    return depth, parent
                return dfs(node.left, node, depth + 1, mod) or dfs(node.right, node, depth + 1, mod)
        dx, px, dy, py = dfs(root, None, 0, x) + dfs(root, None, 0, y)
        return dx == dy and px != py","auto isCousins(auto root, auto x, auto y) {
    def dfs(node, parent, depth, mod):
    if node:
    if node.val == mod:
    return depth, parent
    return dfs(node.left, node, depth + 1, mod) or dfs(node.right, node, depth + 1, mod)
    dx, px, dy, py = dfs(root, nullptr, 0, x) + dfs(root, nullptr, 0, y)
    return dx == dy and px != py
}"
994.py,"def orangesRotting(self, grid: List[List[int]]) -> int:
        bfs, t, m, n = [(i, j) for i, row in enumerate(grid) for j, val in enumerate(row) if val == 2], 0, len(grid), len(grid[0])
        while bfs:
            new = []
            for i, j in bfs:
                for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
                    if 0 <= x < m and 0 <= y < n and grid[x][y] == 1:
                        grid[x][y] = 2
                        new.append((x, y))
            bfs = new
            t += bool(bfs)
        return t if all(val != 1 for row in grid for val in row) else -1","auto orangesRotting(auto grid) {
    bfs, t, m, n = [(i, j) for i, row in enumerate(grid) for j, val in enumerate(row) if val == 2], 0, len(grid), len(grid[0])
    while bfs:
    new = []
    for i, j in bfs:
    for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
    if 0 <= x < m and 0 <= y < n and grid[x][y] == 1:
    grid[x][y] = 2
    new.append((x, y))
    bfs = new
    t += bool(bfs)
    return t if all(val != 1 for row in grid for val in row) else -1
}"
995.py,"def minKBitFlips(self, a: List[int], k: int) -> int:
        q = collections.deque()
        res = 0
        for i in range(len(a)):
            if len(q) % 2 != 0 and a[i] == 1 or len(q) % 2 == a[i] == 0:
                res += 1
                q.append(i+k-1)
            if q and q[0] == i: q.popleft()
            if q and q[-1] >= len(a): return -1
        return res","auto minKBitFlips(auto a, auto k) {
    q = collections.deque()
    res = 0
    for i in range(len(a)):
    if len(q) % 2 != 0 and a[i] == 1 or len(q) % 2 == a[i] == 0:
    res += 1
    q.append(i+k-1)
    if q and q[0] == i: q.popleft()
    if q and q[-1] >= len(a): return -1
    return res
}"
996.py,"def numSquarefulPerms(self, A: List[int]) -> int:
        self.res = 0
        def dfs(cnt, num):
            if not cnt:
                self.res += 1
            for new in nex[num]:
                if cnt[new]:
                    cnt[new] -= 1
                    if not cnt[new]:
                        cnt.pop(new)
                    dfs(cnt, new)
                    cnt[new] += 1
            
        nex = collections.defaultdict(set)  
        cnt = collections.Counter(A)
        for a, b in itertools.permutations(A, 2):
            if not (a + b) ** 0.5 % 1:
                nex[a].add(b)
                nex[b].add(a)
        for a in set(A):
            cnt[a] -= 1
            if not cnt[a]:
                cnt.pop(a)
            dfs(cnt, a)
            cnt[a] += 1
        return self.res","auto numSquarefulPerms(auto A) {
    self.res = 0
    def dfs(cnt, num):
    if not cnt:
    self.res += 1
    for new in nex[num]:
    if cnt[new]:
    cnt[new] -= 1
    if not cnt[new]:
    cnt.pop(new)
    dfs(cnt, new)
    cnt[new] += 1
    
    nex = collections.defaultdict(set)
    cnt = collections.Counter(A)
    for a, b in itertools.permutations(A, 2):
    if not (a + b) ** 0.5 % 1:
    nex[a].add(b)
    nex[b].add(a)
    for a in set(A):
    cnt[a] -= 1
    if not cnt[a]:
    cnt.pop(a)
    dfs(cnt, a)
    cnt[a] += 1
    return self.res
}"
997.py,"def findJudge(self, N: int, trust: List[List[int]]) -> int:
        j, cnt = collections.Counter(b for a, b in trust).most_common(1)[0] if trust else (N, 0)
        return j if j not in {a for a, b in trust} and cnt == N - 1 else -1","auto findJudge(auto N, auto trust) {
    j, cnt = collections.Counter(b for a, b in trust).most_common(1)[0] if trust else (N, 0)
    return j if j not in {a for a, b in trust} and cnt == N - 1 else -1
}"
998.py,"def insertIntoMaxTree(self, root: TreeNode, val: int, parent = None) -> TreeNode:
        if not root or val > root.val:
            new = TreeNode(val)
            new.left = root
            if parent:
                if parent.right == root:
                    parent.right = new
                else:
                    parent.left = new
            root = new
        else:
            root.right = self.insertIntoMaxTree(root.right, val, root)
        return root","auto insertIntoMaxTree(auto root, auto val, auto parent = None) {
    if not root or val > root.val:
    new = TreeNode(val)
    new.left = root
    if parent:
    if parent.right == root:
    parent.right = new
    else:
    parent.left = new
    root = new
    else:
    root.right = self.insertIntoMaxTree(root.right, val, root)
    return root
}"
999.py,"def numRookCaptures(self, board: List[List[str]], res = 0) -> int:
        for i in range(8):
            for j in range(8):
                if board[i][j] == 'R':
                    for x in range(i - 1, -1, -1):
                        if board[x][j] in 'Bp':
                            res += board[x][j] == 'p'
                            break
                    for x in range(i + 1, 8):
                        if board[x][j] in 'Bp':
                            res += board[x][j] == 'p'
                            break
                    for y in range(j - 1, -1, -1):
                        if board[i][y] in 'Bp':
                            res += board[i][y] == 'p'
                            break
                    for y in range(j + 1, 8):
                        if board[i][y] in 'Bp':
                            res += board[i][y] == 'p'
                            break
                    return res","auto numRookCaptures(auto board, auto res = 0) {
    for i in range(8):
    for j in range(8):
    if board[i][j] == 'R':
    for x in range(i - 1, -1, -1):
    if board[x][j] in 'Bp':
    res += board[x][j] == 'p'
    break
    for x in range(i + 1, 8):
    if board[x][j] in 'Bp':
    res += board[x][j] == 'p'
    break
    for y in range(j - 1, -1, -1):
    if board[i][y] in 'Bp':
    res += board[i][y] == 'p'
    break
    for y in range(j + 1, 8):
    if board[i][y] in 'Bp':
    res += board[i][y] == 'p'
    break
    return res
}"
